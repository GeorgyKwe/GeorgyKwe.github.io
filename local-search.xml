<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>组件引用</title>
    <link href="/2023/04/24/%E7%BB%84%E4%BB%B6%E5%BC%95%E7%94%A8/"/>
    <url>/2023/04/24/%E7%BB%84%E4%BB%B6%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>进行项目开发时，根据角色登录信息的不同，显示页面略微会有差异，但显示页面中大部分内容都是相同的，因此想把差异化的部分抽象成组件，在共同页面中引用，利用传递的状态值，控制差异化部分的内容是否可见。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>这里以 Element 中 [Transfer 穿梭框]<a href="https://element.eleme.cn/2.0/#/zh-CN/component/transfer">(</a> 为例进行差异化引用。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;template&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-transfer</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;value1&quot;</span> <span class="hljs-attr">:data</span>=<span class="hljs-string">&quot;data&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;transfer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-transfer</span>&gt;</span></span><br>  &lt;/template&gt;<br>  <br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">const</span> <span class="hljs-title function_">generateData</span> = _ =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">const</span> data = [];</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">15</span>; i++) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            data.<span class="hljs-title function_">push</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">              <span class="hljs-attr">key</span>: i,</span></span><br><span class="language-javascript"><span class="language-xml">              <span class="hljs-attr">label</span>: <span class="hljs-string">`备选项 <span class="hljs-subst">$&#123; i &#125;</span>`</span>,</span></span><br><span class="language-javascript"><span class="language-xml">              <span class="hljs-attr">disabled</span>: i % <span class="hljs-number">4</span> === <span class="hljs-number">0</span></span></span><br><span class="language-javascript"><span class="language-xml">            &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">          &#125;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">return</span> data;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-attr">data</span>: <span class="hljs-title function_">generateData</span>(),</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-attr">value1</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>]</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.transfer</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">   <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span> <span class="hljs-number">0px</span> <span class="hljs-number">0px</span> <span class="hljs-number">0px</span>,</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><p>在前端页面中需要显示的位置上加入以下代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;div&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">transfer</span> <span class="hljs-attr">:state</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">transfer</span>&gt;</span></span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>在脚本中引用需要配置好的组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;srcipt&gt;<br><span class="hljs-keyword">import</span> transfer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./transfer.vue&#x27;</span>;      <span class="hljs-comment">// 同文件夹下引用组件</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">components</span>: &#123;                           <span class="hljs-comment">// 组件中声明</span><br>        transfer,                             <br>    &#125;<br>&#125;,<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><img src="/../image/transfer.png" alt="Transfer 穿梭框"></p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>Vue 使用 <code>import...from...</code> 来导入组件、库、变量等，<code>from</code> 后的来源可以是 js，vue，json。引入文件可以在<br><code>webpack.base.conf.js</code> 中设置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">resolve</span>: &#123;<br>        <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;.js&#x27;</span>, <span class="hljs-string">&#x27;.vue&#x27;</span>, <span class="hljs-string">&#x27;.json&#x27;</span>],<br>        <span class="hljs-attr">alias</span>: &#123;<br>            <span class="hljs-string">&#x27;@&#x27;</span>: <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;src&#x27;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br>...<br><br></code></pre></td></tr></table></figure><h3 id="引用文件"><a href="#引用文件" class="headerlink" title="引用文件"></a>引用文件</h3><p>extensions 指定了 from 后可导入的文件类型。上面定义的 3 类文件，js 和 vue 可以省略后缀。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> test <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test.vue&#x27;</span>   <span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">import</span> test <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test&#x27;</span><br><br><span class="hljs-keyword">import</span> test <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test.js&#x27;</span>    <span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">import</span> test <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test&#x27;</span><br><br><span class="hljs-comment">// json不可以省略后缀</span><br><br><span class="hljs-keyword">import</span> test <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test.json&#x27;</span><br></code></pre></td></tr></table></figure><p>若 <code>test.vue</code> 和 <code>test.js</code> 同时存在于同一个文件夹下，则 import 引入优先级为 <code>js &gt; vue</code>。</p><h3 id="引入文件夹"><a href="#引入文件夹" class="headerlink" title="引入文件夹"></a>引入文件夹</h3><p><code>import test from &#39;./components&#39;</code> 在该情况下的逻辑是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">if</span>(package.<span class="hljs-property">json</span> 存在 &amp;&amp; package.<span class="hljs-property">main</span> 字段存在 &amp;&amp; package.<span class="hljs-property">main</span> 指定的 js 存在) &#123;<br>    取 package.<span class="hljs-property">main</span> 指定的 js 作为 <span class="hljs-keyword">from</span> 的来源，即使该 js 可能格式或内容错误<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( index.<span class="hljs-property">js</span> 存在)&#123;<br>    取 index.<span class="hljs-property">js</span> 作为 <span class="hljs-keyword">from</span> 的来源<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    取 index.<span class="hljs-property">vue</span> 作为 <span class="hljs-keyword">from</span> 的来源<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，若 from 的来源是文件夹，那么在 <code>package.json</code> 存在且设置正确的情况下，会默认加载 <code>package.json</code>；若不满足，则加载 <code>index.js</code>；若不满足，则加载 <code>index.vue</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/jin-zhe/p/9268602.html">https://www.cnblogs.com/jin-zhe/p/9268602.html</a></p><p><a href="https://blog.51cto.com/BADAOLIUMANGQZ/6116184">https://blog.51cto.com/BADAOLIUMANGQZ/6116184</a></p><p><a href="https://blog.csdn.net/fyyyr/article/details/83657828">https://blog.csdn.net/fyyyr/article/details/83657828</a></p><p><a href="https://v2.cn.vuejs.org/v2/guide/components-registration.html#%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F">https://v2.cn.vuejs.org/v2/guide/components-registration.html#%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F</a></p><p><a href="https://zh.javascript.info/import-export">https://zh.javascript.info/import-export</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECharts X轴坐标文字显示不全</title>
    <link href="/2023/04/20/X%E8%BD%B4%E5%9D%90%E6%A0%87%E6%96%87%E5%AD%97%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%85%A8/"/>
    <url>/2023/04/20/X%E8%BD%B4%E5%9D%90%E6%A0%87%E6%96%87%E5%AD%97%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在 ECharts 中应用柱状图或折线图时，当数据量过多时，X 轴坐标信息就会显示不全。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="旋转属性"><a href="#旋转属性" class="headerlink" title="旋转属性"></a>旋转属性</h3><p>ECharts 图表组件内部有一个机制，用于统计 xAxis 坐标刻度的个数和图表宽度，从而会自动调整刻度间隔个数以此达到刻度互相之间不至于很拥挤而影响图表欣赏性。</p><p><code> xAxis.axisLabel. interval</code>：坐标轴刻度标签的显示间隔</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">interval = <span class="hljs-string">&#x27;auto&#x27;</span>,  <span class="hljs-comment">// 采用标签不重叠的策略间隔显示标签</span><br>interval = <span class="hljs-number">0</span>,       <span class="hljs-comment">// 强制显示所有标签</span><br>interval = <span class="hljs-number">1</span>,       <span class="hljs-comment">// 隔一个标签显示一个标签</span><br>interval = <span class="hljs-number">2</span>,       <span class="hljs-comment">// 隔两个标签显示一个标签</span><br></code></pre></td></tr></table></figure><p><code>xAxis.axisLabel. rotate</code>：刻度标签旋转的角度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">rotate = <span class="hljs-number">30</span>,        <span class="hljs-comment">// 旋转角度从 -90° 到 90°</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-attr">xAxis</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;category&#x27;</span>,<br>    <span class="hljs-attr">axisTick</span>: &#123;<br>        <span class="hljs-attr">alignWithLabel</span>: <span class="hljs-literal">true</span><br>    &#125;,<br>    <span class="hljs-attr">data</span>: [],<br>    <span class="hljs-attr">axisLabel</span>: &#123;<br>        <span class="hljs-attr">interval</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">rotate</span>: <span class="hljs-number">0</span>,<br>    &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="dataZoom"><a href="#dataZoom" class="headerlink" title="dataZoom"></a>dataZoom</h3><p>dataZoom 组件用于区域缩放，从而能自由关注细节的数据信息，或者概览数据整体，或者去除离群点的影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-attr">dataZoom</span>: [&#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;slider&#x27;</span>,<br>    <span class="hljs-attr">orient</span>: <span class="hljs-string">&quot;horizontal&quot;</span>,<br>    <span class="hljs-attr">show</span>: <span class="hljs-literal">true</span>,     <span class="hljs-comment">// 控制滚动条显示隐藏</span><br>    <span class="hljs-attr">realtime</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 拖动滚动条时是否动态的更新图表数据</span><br>    <span class="hljs-attr">height</span>: <span class="hljs-number">20</span>,     <span class="hljs-comment">// 滚动条高度</span><br>    <span class="hljs-attr">startValue</span>: <span class="hljs-number">0</span>,  <span class="hljs-comment">// 数据窗口范围的起始数值</span><br>    <span class="hljs-attr">endValue</span>: <span class="hljs-number">6</span>,    <span class="hljs-comment">// 数据窗口范围的结束数值</span><br>    <span class="hljs-attr">bottom</span>: <span class="hljs-string">&#x27;3%&#x27;</span>,   <span class="hljs-comment">// 滚动条距边距离</span><br>    <span class="hljs-attr">zoomLock</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 控制面板是否进行缩放</span><br>&#125;],<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://echarts.apache.org/zh/option.html#xAxis.axisLabel.interval">https://echarts.apache.org/zh/option.html#xAxis.axisLabel.interval</a></p><p><a href="https://my.oschina.net/u/4307631/blog/4012684">https://my.oschina.net/u/4307631/blog/4012684</a></p>]]></content>
    
    
    <categories>
      
      <category>ECharts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈 OTP</title>
    <link href="/2023/04/18/OTP/"/>
    <url>/2023/04/18/OTP/</url>
    
    <content type="html"><![CDATA[<h2 id="OTP-定义"><a href="#OTP-定义" class="headerlink" title="OTP 定义"></a>OTP 定义</h2><p><a href="https://en.wikipedia.org/wiki/Programmable_ROM">OTP</a>（One Time Programmable）是一种非易失性存储器（<a href="https://en.wikipedia.org/wiki/Non-volatile_memory">NVM</a>），有两种不同的实现方式：基于熔丝（<a href="https://en.wikipedia.org/wiki/EFuse">eFuse</a>）实现方式和基于反熔丝（<a href="https://en.wikipedia.org/wiki/Antifuse">AntiFuse</a>）实现方式，两种方式均可以实现一次编程后无法修改数据的目的。</p><p>与 EEPROM 和 Flash Memory 等多次可编程存储器（MTP）相比，OTP 存储器优势在于面积更小，且无需额外的晶圆加工步骤。同时，随着各种安全芯片、安全 SOC 设计的提出，OTP 中能够储存公私钥、加解密等私密数据，一旦经过编程或熔断，内容将无法更改，断电后内容将保留，且支持在制造后进行编程。</p><h2 id="eFuse-和-AntiFuse-区别和联系"><a href="#eFuse-和-AntiFuse-区别和联系" class="headerlink" title="eFuse 和 AntiFuse 区别和联系"></a>eFuse 和 AntiFuse 区别和联系</h2><p>eFuse 和 AntiFuse 存在差异，主要为：编程机制、安全性和功耗等方面。</p><table><thead><tr><th></th><th align="left">Efuse</th><th align="left">AntiFuse</th></tr></thead><tbody><tr><td>熔丝构成</td><td align="left">多晶硅栅极&#x2F;金属栅</td><td align="left">两层金属电极和金属电极间的反熔丝介质层构成</td></tr><tr><td>编程原理</td><td align="left">I&#x2F;O电压施加高密度电流，Efuse<br/>中的低电阻金属由于高密度电流通过<br/>窄金属或多晶硅而被电迁移熔断</td><td align="left">薄栅氧施加高电压，使栅极氧化物击穿</td></tr><tr><td>读取特点</td><td align="left">可读次数较少</td><td align="left">可读次数较多</td></tr><tr><td>阻值变化</td><td align="left">阻值变大</td><td align="left">阻值变小</td></tr><tr><td>安全性</td><td align="left">易被破解，安全性较差，可靠性相对较低</td><td align="left">安全性较高，可靠性较高</td></tr><tr><td>功耗</td><td align="left">功耗较高</td><td align="left">功耗较低</td></tr><tr><td>初始值</td><td align="left">0</td><td align="left">1</td></tr><tr><td></td><td align="left"></td><td align="left"></td></tr></tbody></table><h3 id="编程机制"><a href="#编程机制" class="headerlink" title="编程机制"></a>编程机制</h3><ul><li><p>eFuse</p><p>  eFuse 通过使用 I&#x2F;O 电压以高密度电流流过电熔断金属条或多晶硅类进行编程。当高密度电流流过狭窄的金属或多晶硅时，eFuse 中的低电阻金属因电迁移而熔断。</p><p>  <img src="/../image/%E5%B7%B2%E7%BC%96%E7%A8%8B%E7%9A%84%E5%A4%9A%E6%99%B6%E7%A1%85%20eFuse.png" alt="已编程的多晶硅 eFuse，资料来源：MA-Tek"></p><p>  在烧写过程中，eFuse 两端宽度较大的区域比 eFuse 中间宽度较窄的区域散热效果更好，因此，eFuse 的熔断部分始终位于 eFuse 中间的窄宽度区域。此外，要对一个位（Bit）进行编程需要一对 eFuse 布局，其中一个用于编程，另一个用于差分感应放大器的参考电阻器。同样，eFuse 只能编程一次 “1”，如果编程后 eFuse 无法读取 “1”，则编程失败，这意味着良率损失。</p></li><li><p>AntiFuse</p><p>  AntiFuse 通过雪崩击穿晶体管的栅极和源极电短路进行编程。</p></li></ul><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><ul><li><p>eFuse</p><p>  传统的多晶硅栅极 CMOS 逻辑工艺中，多晶 eFuse 非常流行（如图 1 所示），且 EM 发生在硅化物层。为降低 MOSFET 漏电而开发的新一代高<br>  K 金属栅极（HKMG）CMOS 逻辑工艺中，没有多晶硅层用作 eFuse。因此，英特尔生产的一种不同类型的 eFuse 被实现为金属 1 迹线（如图 2 所示）。</p><p>  <img src="/../image/%E8%8B%B1%E7%89%B9%E5%B0%94%E7%94%9F%E4%BA%A7%E7%9A%84%20Westmere/Clarkdale%20%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A8%8B%20eFuse.png" alt="英特尔生产的 Westmere/Clarkdale 处理器中的编程 eFuse。资料来源：[Intel Westmere Clarkdale 32nm 处理器中使用的 eFUSE 结构的自定义分析](https://www.techinsights.com/reports-and-subscriptions/open-market-reports/Report-Profile/?ReportKey=6907)，TechInsights"></p><p>  在图 2 中，金属 1 形成了四对 eFuse，有两个熔断的 eFuse 和六个完好无损的 eFuse，以及与底层驱动晶体管的互连。值得注意的是，eFuse 的熔断部分形状不规则很容易看到。</p><p>  <img src="/../image/TSMC%20eFuse%2020%20nm%20%E5%B9%B3%E9%9D%A2%20HKMG%20%E5%B7%A5%E8%89%BA%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A8%8B%20eFuse.png" alt="TSMC eFuse 20 nm 平面 HKMG 工艺中的编程 eFuse。资料来源：Qualcomm Gobi MDM9235 调制解调器 20 nm HKMG 逻辑详细结构分析，TechInsights。"></p><p>  如图 3 所示，金属 2 形成了四对 eFuse，有两个熔断的 eFuse。</p><p>  <img src="/../image/%E5%B7%B2%E7%BC%96%E7%A8%8B%E7%9A%84%20TSMC%20eFuse%20%E7%9A%84%E6%94%BE%E5%A4%A7%E5%9B%BE.png" alt="已编程的 TSMC eFuse 的放大图。资料来源：Qualcomm Gobi MDM9235 调制解调器 20 nm HKMG 逻辑详细结构分析，TechInsights。"></p><p>  如图 4 所示，显示了两个熔断的 eFuse。</p><p>  从上述图中可以看出，熔断（或编程后）的 eFuse 很容易被检测到。</p></li><li><p>AntiFuse</p><p>  <img src="/../image/eFuse.png" alt="反熔丝结构图"></p><p>  <img src="/../image/%E5%B7%B2%E7%BC%96%E7%A8%8B%E7%9A%84%E5%8F%8D%E7%86%94%E4%B8%9D.png" alt="已编程的反熔丝。资料来源：http://archive.eettaiwan.com/www.eettaiwan.com/emag/1302_15_DC.html，Kilopass。"></p><p>  如图 5 和 图 6 所示，已编程的反熔丝，其横截面或俯视图中没有熔断部分，电压对比 FIB 也没有热点，这能够保证未经授权的用户很难获得存储在反熔丝存储器中的数据内容。</p></li></ul><h3 id="功耗"><a href="#功耗" class="headerlink" title="功耗"></a>功耗</h3><ul><li><p>eFuse</p><p>  未编程的 eFuse 的典型电阻值约为 50 至 100 欧姆，而已编程的 eFuse 的典型电阻值约为 10K 欧姆 至 100K 欧姆。eFuse 中存储的 “0” 越多，消耗的电量就越多。此外，eFuse 的待机功率或泄漏比反熔丝高得多。</p></li><li><p>AntiFuse</p><p>  反熔丝在未编程状态下使用的功率更少，且反熔丝的电阻在未编程状态下更高。未编程位（Bit）的默认值为“0”，因此只需对为“1”的位进行编程。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>采用 AntiFuse 实现方式的 OTP 存储器具有更好的编程良率、更低的未编程位功耗以及总体上更出色的安全性。因此，具有 AntiFuse 的 OTP 存储器比具有 eFuse 的 OTP 存储器更适合移动支付、物联网 (IoT) 和其他应用。</p><h2 id="OTP-基本-Feature"><a href="#OTP-基本-Feature" class="headerlink" title="OTP 基本 Feature"></a>OTP 基本 Feature</h2><h3 id="读（Read）"><a href="#读（Read）" class="headerlink" title="读（Read）"></a>读（Read）</h3><p>支持重复读取 OTP Memory 内容。</p><h3 id="写（Program）"><a href="#写（Program）" class="headerlink" title="写（Program）"></a>写（Program）</h3><p>若对 OTP Memory 进行烧写，不支持对烧写后的位（Bit）再次烧写。支持一次烧写 1 Byte（8 Bit）数据。</p><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>OTP Memory 可拓展支持 Lock 机制。</p><h3 id="写保护机制"><a href="#写保护机制" class="headerlink" title="写保护机制"></a>写保护机制</h3><p>Mask 和 Program 数据位一一对应。写完后将数据读出来，若两者一致，说明数据成功写入，若两者不一致，找到哪一个比特位写入失败，将其赋值给 Mask。Mask 与 Program 数据进行与运算，再对写失败的位（Bit）进行写入。</p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li>OTP（One Time Programmable）：一次性可编程存储器</li><li>FTP（Few-Time Programmable）：有限次数的可编程储存器</li><li>MTP（Multi Time Programmable）：多次可编程存储器</li><li>eFuse（electronic fuse）：电子保险丝</li><li>NVM（Non-volatile memory）：非易失性存储器</li><li>EM (electro-migration)：电迁移</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://semiengineering.com/knowledge_centers/memory/one-time-programmable-memory/">https://semiengineering.com/knowledge_centers/memory/one-time-programmable-memory/</a></p><p><a href="https://zhuanlan.zhihu.com/p/354196694">https://zhuanlan.zhihu.com/p/354196694</a></p><p><a href="https://semiengineering.com/the-benefits-of-antifuse-otp/">https://semiengineering.com/the-benefits-of-antifuse-otp/</a></p><p><a href="https://zhuanlan.zhihu.com/p/354196694">https://zhuanlan.zhihu.com/p/354196694</a></p><p><a href="https://blog.csdn.net/impossible1224/article/details/122412789">https://blog.csdn.net/impossible1224/article/details/122412789</a></p>]]></content>
    
    
    <categories>
      
      <category>OTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串</title>
    <link href="/2023/04/18/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/04/18/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>文本数据被以字符串形式存储，单个字符没有单独的类型。字符串的内部格式始终是 UTF-16，不依赖于页面编码。</p><h2 id="引号（Quotes）"><a href="#引号（Quotes）" class="headerlink" title="引号（Quotes）"></a>引号（Quotes）</h2><p>字符串可以包含在单引号、双引号或反引号中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> single = <span class="hljs-string">&#x27;single-quoted&#x27;</span><br><span class="hljs-keyword">let</span> double = <span class="hljs-string">&quot;double-quoted&quot;</span><br><br><span class="hljs-keyword">let</span> backticks = <span class="hljs-string">`backticks`</span><br></code></pre></td></tr></table></figure><p>单引号和双引号基本相同，但反引号允许通过 <code>$&#123;...&#125;</code> 将任何表达式嵌入到字符串中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">`1 + 2 = <span class="hljs-subst">$&#123;sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)&#125;</span>`</span>);  <span class="hljs-comment">// 1 + 2 = 3</span><br></code></pre></td></tr></table></figure><p>使用反引号的另一个优点：允许字符串跨行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> guestList = <span class="hljs-string">`Guests:</span><br><span class="hljs-string">    * A</span><br><span class="hljs-string">    * B</span><br><span class="hljs-string">    * C</span><br><span class="hljs-string">`</span>;<br><span class="hljs-title function_">alert</span>(guestList);   <span class="hljs-comment">// 客人清单，多行</span><br></code></pre></td></tr></table></figure><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>上述换行中，也可通过使用“换行符 <code>\n</code>”支持单引号和双引号来创建跨行字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> guestList = <span class="hljs-string">&quot;Guests:\n * A\n * B\n * C&quot;</span>;<br><span class="hljs-title function_">alert</span>(guestList);   <span class="hljs-comment">// 客人清单，多行</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str1 = <span class="hljs-string">&quot;Hello\nWorld&quot;</span>;  <span class="hljs-comment">// 使用“换行符”创建的两行字符串</span><br><br><span class="hljs-comment">// 使用反引号和普通的换行创建的两行字符串</span><br><span class="hljs-keyword">let</span> str2 = <span class="hljs-string">`Hello           </span><br><span class="hljs-string">World`</span>;<br><br><span class="hljs-title function_">alert</span>(str1 == str2); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>不常见“特殊”字符表。</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>\n</code></td><td>换行</td></tr><tr><td><code>\r</code></td><td>在非 Windows OS 上，等同于 <code>\n</code></td></tr><tr><td><code>\&#39;</code>, <code>\&quot;</code></td><td>引号</td></tr><tr><td><code>\\</code></td><td>反斜线</td></tr><tr><td><code>\t</code></td><td>制表符</td></tr><tr><td><code>\xXX</code></td><td>具有给定十六进制 Unicode <code>xx</code> 的 Unicode 字符，例如：<code>\x7A</code> 和 <code>z</code> 相同</td></tr><tr><td><code>\uXXXX</code></td><td>以 UTF-16 编码的十六进制代码 <code>XXXX</code> 的 Unicode 字符，例如 <code>\u00A9</code> —— 是版权符号 © 的 Unicode。它必须正好是 4 个十六进制数字</td></tr><tr><td><code>\u&#123;X...XXXXXX&#125;</code>（1到6个十六进制字符）</td><td>具有给定 UTF-32 编码的 Unicode 符号。一些罕见的字符用两个 Unicode 符号编码，占用 4 个字节</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>所有特殊符号都以反斜杠字符 <code>\</code> 开始。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;\u00A9&quot;</span>);        <span class="hljs-comment">// ©</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;\u&#123;20331&#125;&quot;</span>);     <span class="hljs-comment">// 佫，罕见的中国象形文字（长 Unicode）</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;\u&#123;1F60D&#125;&quot;</span> );   <span class="hljs-comment">// 😍，笑脸符号（另一个长 Unicode）</span><br></code></pre></td></tr></table></figure><p>如果想要在字符串中插入一个引号，用来表示引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;I\&#x27;m George!&#x27;</span>);  <span class="hljs-comment">// I&#x27;m George!</span><br></code></pre></td></tr></table></figure><p>上面单引号 <code>&#39;&#39;</code> 示例中必须要在内部引号前加上反斜杠 <code>\&#39;</code>，否则将表示字符串结束。</p><p>还可改用双引号或反引号来实现相同效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">`I&#x27;m the George!`</span> ); <span class="hljs-comment">// I&#x27;m the George!</span><br></code></pre></td></tr></table></figure><p>如果要在字符串中显示一个实际的反斜杠 <code>\</code>，只需要书写两次 <code>\\</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">`The Burberry: \\`</span> ); <span class="hljs-comment">// The Burberry: \</span><br></code></pre></td></tr></table></figure><h2 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h2><p><code>length</code> 表示字符串长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">` My\n`</span>.<span class="hljs-property">length</span>);  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>注：<code>\n</code> 是一个单独的“特殊”字符，长度确实是 3。</p><blockquote><p><code>length</code> 是一个属性。</p><p><code>str.length</code> 是一个数字属性，而不是函数，后面不需要添加括号。</p></blockquote><h2 id="访问字符"><a href="#访问字符" class="headerlink" title="访问字符"></a>访问字符</h2><p>若要获取 <code>pos</code> 位置的一个字符，可以使用方括号 <code>[pos]</code> 或者调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/charAt">str.charAt(pos)</a> 方法。第一个字符从零位置开始：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;<br><br><span class="hljs-comment">// 第一个字符</span><br><span class="hljs-title function_">alert</span>( str[<span class="hljs-number">0</span>] );        <span class="hljs-comment">// H</span><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>) ); <span class="hljs-comment">// H</span><br><br><span class="hljs-comment">// 最后一个字符</span><br><span class="hljs-title function_">alert</span>( str[str.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] );   <span class="hljs-comment">// o</span><br></code></pre></td></tr></table></figure><p><code>[]</code> 和 <code>charAt</code> 区别：</p><ul><li>方括号是获取字符的一种现代化方法；<code>charAt</code> 是历史原因才存在；</li><li>唯一区别在于，若没有找到字符，<code>[]</code> 返回 <code>undefined</code>，而 <code>charAt</code>返回一个空字符串。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">`Hello`</span>;<br><br><span class="hljs-title function_">alert</span>( str[<span class="hljs-number">1000</span>] );         <span class="hljs-comment">// undefined</span><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">1000</span>) );  <span class="hljs-comment">// &#x27;&#x27;（空字符串）</span><br></code></pre></td></tr></table></figure><p>同样，可以使用 <code>for...of</code> 遍历字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> <span class="hljs-string">&quot;Hello&quot;</span>) &#123;<br>    <span class="hljs-title function_">alert</span>(char);            <span class="hljs-comment">// H,e,l,l,o（char 变成&quot;H&quot;，然后是&quot;e&quot;...）</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串不可变"><a href="#字符串不可变" class="headerlink" title="字符串不可变"></a>字符串不可变</h2><p>在 JavaScript 中，字符串不可更改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hi&#x27;</span>;<br><br>str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;h&#x27;</span>;       <span class="hljs-comment">// error</span><br><span class="hljs-title function_">alert</span>( str[<span class="hljs-number">0</span>] );    <span class="hljs-comment">// 无法运行</span><br></code></pre></td></tr></table></figure><p>常见的解决方法是创建一个新的字符串，并将其分配给 <code>str</code> 而不是以前的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hi&#x27;</span>;<br><br>str = <span class="hljs-string">&#x27;h&#x27;</span> + str[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 替换字符串</span><br><span class="hljs-title function_">alert</span>( str );       <span class="hljs-comment">// hi</span><br></code></pre></td></tr></table></figure><h2 id="改变大小写"><a href="#改变大小写" class="headerlink" title="改变大小写"></a>改变大小写</h2><h3 id="toLowerCase-和-toUpperCase"><a href="#toLowerCase-和-toUpperCase" class="headerlink" title="toLowerCase() 和 toUpperCase()"></a>toLowerCase() 和 toUpperCase()</h3><p>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase">toLowerCase()</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase">toUpperCase()</a> 方法可以改变大小写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">&#x27;Interface&#x27;</span>.<span class="hljs-title function_">toUpperCase</span>() ); <span class="hljs-comment">// INTERFACE</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&#x27;Interface&#x27;</span>.<span class="hljs-title function_">toLowerCase</span>() ); <span class="hljs-comment">// interface</span><br></code></pre></td></tr></table></figure><p>也可使一个字符变成小写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">&#x27;Interface&#x27;</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">toLowerCase</span>() );  <span class="hljs-comment">// i</span><br></code></pre></td></tr></table></figure><h2 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h2><p>在字符串中查找子字符串的方法。</p><h3 id="str-indexOf"><a href="#str-indexOf" class="headerlink" title="str.indexOf"></a>str.indexOf</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf">str.indexOf(substr, pos)</a> 从给定位置 <code>pos</code> 开始，在 <code>str</code> 中查找 <code>substr</code>，若没有找到，则返回 <code>-1</code>，否则返回匹配成功的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Widget with id&#x27;</span>;<br><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;Widget&#x27;</span>) ); <span class="hljs-comment">// 0，因为 &#x27;Widget&#x27; 一开始就被找到</span><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;widget&#x27;</span>) ); <span class="hljs-comment">// -1，没有找到，检索是大小写敏感的</span><br><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;id&quot;</span>) );     <span class="hljs-comment">// 1，&quot;id&quot; 在位置 1 处（……idget 和 id）</span><br></code></pre></td></tr></table></figure><p>可选的第二个参数允许从一个给定的位置开始检索。例如，<code>id</code> 第一次出现的位置是 <code>1</code>，查询到下一个存在的位置时，从 2 开始检索。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Widget with id&#x27;</span>;<br><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-number">2</span>) ) <span class="hljs-comment">// 12</span><br></code></pre></td></tr></table></figure><p>若对所有存在的位置都感兴趣，可以在一个循环中使用 <code>indexOf</code>。每一次新的调用都发生在上一匹配位置之后。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;As sly as a fox, as strong as an ox&#x27;</span>;<br><span class="hljs-keyword">let</span> target = <span class="hljs-string">&#x27;as&#x27;</span>;  <span class="hljs-comment">// 这是我们要查找的目标</span><br><br><span class="hljs-keyword">let</span> pos = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">let</span> foundPos = str.<span class="hljs-title function_">indexOf</span>(target, pos);<br>    <span class="hljs-keyword">if</span>(foundPos == -<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-title function_">alert</span>( <span class="hljs-string">`Found at <span class="hljs-subst">$&#123;foundPos&#125;</span>`</span> );<br>    pos = foundPos + <span class="hljs-number">1</span>; <span class="hljs-comment">// 继续从下一位置查找</span><br>&#125;<br>---------- 算法简写 ---------<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;As sly as a fox, as strong as an ox&quot;</span>;<br><span class="hljs-keyword">let</span> target = <span class="hljs-string">&quot;as&quot;</span>;<br><br><span class="hljs-keyword">let</span> pos = -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>((pos = str.<span class="hljs-title function_">indexOf</span>(target, pos + <span class="hljs-number">1</span>)) != -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-title function_">alert</span>( pos );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="str-lastIndexOf-substr-pos"><a href="#str-lastIndexOf-substr-pos" class="headerlink" title="str.lastIndexOf(substr, pos)"></a>str.lastIndexOf(substr, pos)</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf">str.lastIndexOf(substr, position)</a>，它从字符串的末尾开始搜索到开头，将会以相反的顺序列出这些事件。</p><h2 id="按位（bitwise）NOT技巧"><a href="#按位（bitwise）NOT技巧" class="headerlink" title="按位（bitwise）NOT技巧"></a>按位（bitwise）NOT技巧</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_NOT">bitwise NOT</a> <code>~</code> 运算符，能将数字转化为 32-bit 整数，（若存在小数部分，则删除小数部分），然后对其二进制表示形式中的所有位取反。</p><p>对于 32-bit 整数，<code>~n</code> 等于 <code>-(n+1)</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( ~<span class="hljs-number">2</span> );    <span class="hljs-comment">// -3，和 -(2+1) 相同</span><br><span class="hljs-title function_">alert</span>( ~<span class="hljs-number">1</span> );    <span class="hljs-comment">// -2，和 -(1+1) 相同</span><br><span class="hljs-title function_">alert</span>( ~<span class="hljs-number">0</span> );    <span class="hljs-comment">// -1，和 -(0+1) 相同</span><br><span class="hljs-title function_">alert</span>( ~-<span class="hljs-number">1</span> );   <span class="hljs-comment">// 0，和 -(-1+1) 相同</span><br></code></pre></td></tr></table></figure><p>只有当 <code>n == -1</code> 时，<code>~n</code> 才为零。</p><h2 id="includes-startWith-endsWith"><a href="#includes-startWith-endsWith" class="headerlink" title="includes, startWith, endsWith"></a>includes, startWith, endsWith</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/includes">str.includes(substr, pos)</a>方法根据 <code>str</code> 中是否包含 <code>substr</code> 来返回 <code>true/false</code>。</p><p>如果需要检测匹配，则不需要第二个位置参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Widget with id&quot;</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;Widget&quot;</span>) );   <span class="hljs-comment">// true</span><br><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Hello&quot;</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;Bye&quot;</span>) );               <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><code>str.includes</code> 的第二个可选参数是开始搜索的起始位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Widget&quot;</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;id&quot;</span>) );       <span class="hljs-comment">// true</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Widget&quot;</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">3</span>) );    <span class="hljs-comment">// false, 从位置 3 开始没有 &quot;id&quot;</span><br></code></pre></td></tr></table></figure><p>方法 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith">str.startsWith</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith">str.endsWith</a> 的功能与其名称所表示的意思相同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Widget&quot;</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;Wid&quot;</span>) );    <span class="hljs-comment">// true，&quot;Widget&quot; 以 &quot;Wid&quot; 开始</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Widget&quot;</span>.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&quot;get&quot;</span>) );      <span class="hljs-comment">// true，&quot;Widget&quot; 以 &quot;get&quot; 结束</span><br></code></pre></td></tr></table></figure><h2 id="获取子字符串"><a href="#获取子字符串" class="headerlink" title="获取子字符串"></a>获取子字符串</h2><p>JavaScript 中有三种获取字符串的方法：<code>substring</code>、<code>substr</code>、<code>slice</code>。</p><h3 id="str-slice-start-end"><a href="#str-slice-start-end" class="headerlink" title="str.slice(start [, end])"></a>str.slice(start [, end])</h3><p><code>str.slice(start [, end])</code> 返回字符串从 <code>start</code> 到（但不包括） end 的部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;stringify&quot;</span>;<br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>) );   <span class="hljs-comment">// &#x27;strin&#x27;，从 0 到 5 的子字符串（不包括 5）</span><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) );   <span class="hljs-comment">// &#x27;s&#x27;，从 0 到 1，但不包括 1，所以只有在 0 处的字符</span><br></code></pre></td></tr></table></figure><p>若没有第二个参数，slice 会一直运行到字符串末尾。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;stringify&quot;</span>;<br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>) );      <span class="hljs-comment">// 从第二个位置直到结束</span><br></code></pre></td></tr></table></figure><p><code>start/end</code> 也有可能是负值，意思为起始位置从字符串结尾计算。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;stringify&quot;</span>;<br><br><span class="hljs-comment">// 从右边的第四个位置开始，在右边的第一个位置结束</span><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">slice</span>(-<span class="hljs-number">4</span>, -<span class="hljs-number">1</span>) ); <span class="hljs-comment">// &#x27;gif&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="str-substring-start-end"><a href="#str-substring-start-end" class="headerlink" title="str.substring(start [, end])"></a>str.substring(start [, end])</h3><p><code>str.substring(start [, end])</code> 方法与 <code>slice</code> 几乎相同，但其允许 <code>start</code> 大于 <code>end</code>，将返回字符串从 <code>start</code> 到（但不包括）<code>end</code> 的部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;stringify&quot;</span>;<br><br><span class="hljs-comment">// 这些对于 substring 是相同的</span><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>) );   <span class="hljs-comment">// &quot;ring&quot;</span><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">6</span>, <span class="hljs-number">2</span>) );   <span class="hljs-comment">// &quot;ring&quot;</span><br><br><span class="hljs-comment">// ……但对 slice 是不同的：</span><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>) );       <span class="hljs-comment">// &quot;ring&quot;（一样）</span><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">6</span>, <span class="hljs-number">2</span>) );       <span class="hljs-comment">// &quot;&quot;（空字符串）</span><br></code></pre></td></tr></table></figure><h3 id="str-substr-start-length"><a href="#str-substr-start-length" class="headerlink" title="str.substr(start [, length])"></a>str.substr(start [, length])</h3><p><code>str.substr(start [, length])</code> 方法允许指定 length 而不是结束位置，返回字符串从 <code>start</code> 开始的给定 <code>length</code> 的部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;stringify&quot;</span>;<br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">substr</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>) );  <span class="hljs-comment">// &#x27;ring&#x27;，从位置 2 开始，获取 4 个字符</span><br></code></pre></td></tr></table></figure><p>若第一个参数为负数，则从结尾算起。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;stringify&quot;</span>;<br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">substr</span>(-<span class="hljs-number">4</span>, <span class="hljs-number">2</span>) ); <span class="hljs-comment">// &#x27;gi&#x27;，从第 4 位获取 2 个字符</span><br></code></pre></td></tr></table></figure><h2 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h2><p>字符串按照字母顺序逐字比较，但总存在一些问题。</p><ol><li><p>小写字母总大于大写字母。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">&#x27;a&#x27;</span> &gt; <span class="hljs-string">&#x27;Z&#x27;</span> ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p>带变音符号的字母存在“乱序”的情况。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">&#x27;Österreich&#x27;</span> &gt; <span class="hljs-string">&#x27;Zealand&#x27;</span> ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ol><p>上述两种情况原因为，所有的字符串都使用 UTF-16 编码。即：每个字符都有对应的数字代码。有特殊的方法可以获取代码表示的字符，以及字符对应的代码。</p><h3 id="str-codePointAt-pos"><a href="#str-codePointAt-pos" class="headerlink" title="str.codePointAt(pos)"></a>str.codePointAt(pos)</h3><p><code>str.codePointAt(pos)</code> 方法返回在 <code>pos</code> 位置的字符代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 不同的字母有不同的代码</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;z&quot;</span>.<span class="hljs-title function_">codePointAt</span>(<span class="hljs-number">0</span>) );    <span class="hljs-comment">// 122</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Z&quot;</span>.<span class="hljs-title function_">codePointAt</span>(<span class="hljs-number">0</span>) );    <span class="hljs-comment">// 90</span><br></code></pre></td></tr></table></figure><h3 id="String-fromCodePoint-code"><a href="#String-fromCodePoint-code" class="headerlink" title="String.fromCodePoint(code)"></a>String.fromCodePoint(code)</h3><p><code>String.fromCodePoint(code)</code> 方法通过数字 <code>code</code> 创建字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCodePoint</span>(<span class="hljs-number">90</span>) );  <span class="hljs-comment">// Z</span><br></code></pre></td></tr></table></figure><p>还可以用 <code>\u</code> 后跟十六进制代码，通过这些代码添加 Unicode 字符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 在十六进制系统中 90 为 5a</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&#x27;\u005a&#x27;</span> );  <span class="hljs-comment">// Z</span><br></code></pre></td></tr></table></figure><p>代码为 65..220 的字符（拉丁字母和一些额外的字符），方法是创建一个字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#x27;</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">65</span>; i &lt;= <span class="hljs-number">220</span>; i++) &#123;<br>  str += <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCodePoint</span>(i);<br>&#125;<br><span class="hljs-title function_">alert</span>( str );<br><span class="hljs-comment">// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz&#123;|&#125;~</span><br><span class="hljs-comment">// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ</span><br></code></pre></td></tr></table></figure><p>字符通过数字代码进行比较。越大的代码意味着字符越大。<code>a</code>（97）的代码大于 <code>Z</code>（90）的代码。</p><ul><li>所有小写字母追随在大写字母之后，因为它们的代码更大；</li><li>一些像 <code>Ö</code> 的字母与主要字母表不同。这里，它的代码比任何从 <code>a</code> 到 <code>z</code> 的代码都要大。</li></ul><h2 id="正确的比较"><a href="#正确的比较" class="headerlink" title="正确的比较"></a>正确的比较</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare">String.prototype.localeCompare()</a> 方法会根据语言规则返回一个整数，这个整数能指示字符串 <code>str</code> 在排序顺序中排在字符串 <code>str2</code> 前面、后面、还是相同。</p><ul><li>如果 <code>str</code> 排在 <code>str2</code> 前面，则返回负数；</li><li>如果 <code>str</code> 排在 <code>str2</code> 后面，则返回正数；</li><li>如果他们在相同位置，则返回 <code>0</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">&#x27;Österreich&#x27;</span>.<span class="hljs-title function_">localeCompare</span>(<span class="hljs-string">&#x27;Zealand&#x27;</span>) ); <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>有 3 种类型的引号。反引号允许字符串跨越多行并可以使用 <code>$&#123;…&#125;</code> 在字符串中嵌入表达式；</li><li>JavaScript 中的字符串使用的是 UTF-16 编码；</li><li>我们可以使用像 <code>\n</code> 这样的特殊字符或通过使用 <code>\u...</code> 来操作它们的 Unicode 进行字符插入；</li><li>获取字符时，使用 <code>[]</code>；</li><li>获取子字符串，使用 <code>slice</code> 或 <code>substring</code>；</li><li>字符串的大&#x2F;小写转换，使用：<code>toLowerCase/toUpperCase</code>；</li><li>查找子字符串时，使用 <code>indexOf</code> 或 <code>includes/startsWith/endsWith</code> 进行简单检查；</li><li>根据语言比较字符串时使用 <code>localeCompare</code>，否则将按字符代码进行比较。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.javascript.info/string">https://zh.javascript.info/string</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字类型</title>
    <link href="/2023/04/17/%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/04/17/%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>JavaScript 中 数字（number）有两种类型：</p><ol><li>常规类型，常规数字以 64 位的格式存储，也被称为“双精度浮点数”；</li><li>特殊类型，<code>BigInt</code> 用于表示任意长度的整数。</li></ol><h2 id="编写数字的更多方法"><a href="#编写数字的更多方法" class="headerlink" title="编写数字的更多方法"></a>编写数字的更多方法</h2><p>例如，10 亿的常规表示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> billion = <span class="hljs-number">1000000000</span>;<br></code></pre></td></tr></table></figure><p>同样，也可使用下划线 <code>_</code> 作为分隔符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> billion = <span class="hljs-number">1_000_000_000</span>;<br></code></pre></td></tr></table></figure><p>下划线扮演“语法糖”的角色，使得数字具有更强的可读性。</p><p>同样，也可通过数字后面附加字母 <code>e</code> 并指定零的个数来缩短数字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> billion = <span class="hljs-number">1e9</span>;  <span class="hljs-comment">// 1o亿，字面意思：数字 1 后面跟 9 个 0</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-number">7.3e9</span>);       <span class="hljs-comment">// 73亿，（与 7300000000 和 7_300_000_000 相同）</span><br>-----------------------<br><span class="hljs-number">1e3</span> === <span class="hljs-number">1</span> * <span class="hljs-number">1000</span>;   <span class="hljs-comment">// e3 表示 *1000</span><br><span class="hljs-number">1.23e6</span> === <span class="hljs-number">1.23</span> * <span class="hljs-number">1000000</span>;  <span class="hljs-comment">// e6 表示 *1000000</span><br>-----------------------<br><span class="hljs-keyword">let</span> mcs = <span class="hljs-number">0.000001</span>;<br><span class="hljs-keyword">let</span> mcs = <span class="hljs-number">1e-6</span>;     <span class="hljs-comment">// 1 的左边有 6 个 0</span><br>-----------------------<br><span class="hljs-number">1e-3</span> === <span class="hljs-number">1</span> / <span class="hljs-number">1000</span>;  <span class="hljs-comment">// 0.001</span><br><span class="hljs-number">1.23e-6</span> === <span class="hljs-number">1.23</span> / <span class="hljs-number">1000000</span>; <span class="hljs-comment">// 0.00000123</span><br><span class="hljs-number">1234e-2</span> === <span class="hljs-number">1234</span> / <span class="hljs-number">100</span>;     <span class="hljs-comment">// 12.34，小数点移动两次</span><br></code></pre></td></tr></table></figure><h2 id="十六进制、二进制和八进制"><a href="#十六进制、二进制和八进制" class="headerlink" title="十六进制、二进制和八进制"></a>十六进制、二进制和八进制</h2><ul><li>十六进制（0x）：常用于表示颜色、编码字符等；</li><li>八进制（0o）</li><li>二进制（0b）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-number">0xff</span> );      <span class="hljs-comment">// 255</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-number">0xFF</span> );      <span class="hljs-comment">// 255（一样，大小写没影响）</span><br>-----------------------<br><span class="hljs-keyword">let</span> a = <span class="hljs-number">0b11111111</span>; <span class="hljs-comment">// 二进制形式的 255</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">0o377</span>;      <span class="hljs-comment">// 八进制形式的 255</span><br><br><span class="hljs-title function_">alert</span>( a == b );    <span class="hljs-comment">// true，两边是相同的数字，都是 255</span><br></code></pre></td></tr></table></figure><h3 id="toString-base"><a href="#toString-base" class="headerlink" title="toString(base)"></a>toString(base)</h3><p>字符串方法 <code>num.toString(base)</code> 返回在给定 <code>base</code> 进制数字系统中 <code>num</code> 的字符串表示形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">255</span>;<br><span class="hljs-title function_">alert</span>( num.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>) );  <span class="hljs-comment">// ff</span><br><span class="hljs-title function_">alert</span>( num.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>) );   <span class="hljs-comment">// 11111111</span><br></code></pre></td></tr></table></figure><p>base 的范围可以从 2 到 36，默认情况为 10.</p><ul><li>base&#x3D;16，用于十六进制颜色，字符编码等，数字可以是 0..9 或 A..F。</li><li>base&#x3D;2，主要用于调试按位操作，数字可以是 0 或 1。</li><li>base&#x3D;36，是最大进制，数字可以是 0..9 或 A..Z。所有拉丁字母都被用于了表示数字。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-number">123456.</span>.<span class="hljs-title function_">toString</span>(<span class="hljs-number">36</span>) ); <span class="hljs-comment">// 2n9c</span><br></code></pre></td></tr></table></figure><h2 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h2><p>舍入（rounding）是使用数字时最常用的操作之一。</p><h3 id="Math-floor"><a href="#Math-floor" class="headerlink" title="Math.floor"></a>Math.floor</h3><p>向下舍入：<code>3.1</code> 变成 <code>3</code>，<code>-1.1</code> 变成 <code>-2</code>。</p><h3 id="Math-ceil"><a href="#Math-ceil" class="headerlink" title="Math.ceil"></a>Math.ceil</h3><p>向上舍入：<code>3.1</code> 变成 <code>4</code>，<code>-1.1</code> 变成 <code>-1</code>。</p><h3 id="Math-round"><a href="#Math-round" class="headerlink" title="Math.round"></a>Math.round</h3><p>向最近的整数舍入：<code>3.1</code> 变成 <code>3</code>，<code>3.6</code> 变成 <code>4</code>，中间值 <code>3.5</code> 变成 <code>4</code>。</p><h3 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc"></a>Math.trunc</h3><p>移除小数点后的所有内容而没有舍入：<code>3.1</code> 变成 <code>3</code>，<code>-1.1</code> 变成 <code>-1</code>。</p><h3 id="parseInt-和-parseFloat"><a href="#parseInt-和-parseFloat" class="headerlink" title="parseInt 和 parseFloat"></a>parseInt 和 parseFloat</h3><p><code>parseInt</code>、<code>parseFloat</code>： 从 <code>100px</code>、<code>19€</code> 带有单位的值中提取出一个数值，可以从字符串中“读取”数字，直到无法读取为止，若发生 error，则返回收集到的数字。</p><ul><li><code>parseInt</code>：返回一个整数；</li><li><code>parseFloat</code>：返回一个浮点数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;100px&#x27;</span>) );     <span class="hljs-comment">// 100</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;12.5em&#x27;</span>) );  <span class="hljs-comment">// 12.5</span><br><br><span class="hljs-title function_">alert</span>( <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;12.3&#x27;</span>) );      <span class="hljs-comment">// 12，只有整数部分被返回了</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;12.3.4&#x27;</span>) );  <span class="hljs-comment">// 12.3，在第二个点出停止了读取</span><br></code></pre></td></tr></table></figure><p>在某种情况下，当没有数据可读时，<code>parseInt/parseFloat</code> 会返回 <code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;a123&#x27;</span>) );      <span class="hljs-comment">// NaN，第一个符号停止了读取</span><br></code></pre></td></tr></table></figure><p><strong>parseInt(str, radix) 的第二个参数</strong></p><p><code>parseInt()</code> 函数具有可选的第二个参数。它指定了数字系统的基数，因此 <code>parseInt</code> 还可以解析十六进制数字、二进制数字等的字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;0xff&#x27;</span>, <span class="hljs-number">16</span>) );  <span class="hljs-comment">// 255</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;ff&#x27;</span>, <span class="hljs-number">16</span>) );    <span class="hljs-comment">// 255，没有 0x 仍然有效</span><br><br><span class="hljs-title function_">alert</span>( <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;2n9c&#x27;</span>, <span class="hljs-number">36</span>) );  <span class="hljs-comment">// 123456</span><br></code></pre></td></tr></table></figure><h2 id="其他数学函数"><a href="#其他数学函数" class="headerlink" title="其他数学函数"></a>其他数学函数</h2><p>JavaScript 有一个内建的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math">Math</a> 对象，它包含了一个小型的数学函数和常量库。</p><h3 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h3><p>返回一个从 0 到 1 的随机数（不包括 1）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() );     <span class="hljs-comment">// 0.1234567894322</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() );     <span class="hljs-comment">// 0.5435252343232</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() );     <span class="hljs-comment">// ... (任何随机数)</span><br></code></pre></td></tr></table></figure><h3 id="Math-max-a-b-c…-和-Math-min-a-b-c…"><a href="#Math-max-a-b-c…-和-Math-min-a-b-c…" class="headerlink" title="Math.max(a, b, c…) 和 Math.min(a, b, c…)"></a>Math.max(a, b, c…) 和 Math.min(a, b, c…)</h3><p>从任意数量的参数中返回最大值和最小值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, -<span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) ); <span class="hljs-comment">// 5</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) );            <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h3 id="Math-pow-n-power"><a href="#Math-pow-n-power" class="headerlink" title="Math.pow(n, power)"></a>Math.pow(n, power)</h3><p>返回 n 的给定（power）次幂。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>) );   <span class="hljs-comment">// 2 的 10 次幂 = 1024</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>带有很多零的数字</p><ul><li>将 “e” 和 0 的数量附加到数字后。就像：123e6 与 123 后面接 6 个 0 相同；</li><li>“e” 后面的负数将使数字除以 1 后面接着给定数量的零的数字。例如 123e-6 表示 0.000123（123 的百万分之一）。</li></ul><p>对于不同的数字系统：</p><ul><li>可以直接在十六进制（<code>0x</code>），八进制（<code>0o</code>）和二进制（<code>0b</code>）系统中写入数字；</li><li><code>parseInt(str, base)</code> 将字符串 <code>str</code> 解析为在给定的 base 数字系统中的整数，<code>2 ≤ base ≤ 36</code>；</li><li><code>num.toString(base)</code> 将数字转换为在给定的 base 数字系统中的字符串。</li></ul><p>小数：</p><ul><li>使用 <code>Math.floor</code>，<code>Math.ceil</code>，<code>Math.trunc</code>，<code>Math.round</code> 或 <code>num.toFixed(precision)</code> 进行舍入；</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.javascript.info/number">https://zh.javascript.info/number</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原始类型的方法</title>
    <link href="/2023/04/17/%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2023/04/17/%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="原始类型和对象区别"><a href="#原始类型和对象区别" class="headerlink" title="原始类型和对象区别"></a>原始类型和对象区别</h2><p>一个原始值：</p><ul><li>是原始类型中的一种值；</li><li>在 JavaScript 中有7中原始类型：<code>string</code>、<code>number</code>、<code>bigint</code>、<code>boolean</code>、<code>symbol</code>、<code>null</code> 和 <code>undefined</code>。</li></ul><p>一个对象：</p><ul><li>能够存储多个值作为属性；</li><li>可以使用大括号 <code>&#123;&#125;</code> 创建对象，例如：<code>&#123;name：&quot;John&quot;, age: 30&#125;</code>。函数也是对象。</li></ul><p>例如：将一个函数作为对象的属性存储到对象中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> john = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>    <span class="hljs-attr">syaHi</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>    &#125;<br>&#125;;<br><br>john.<span class="hljs-title function_">sayHi</span>();   <span class="hljs-comment">// Hello World!</span><br></code></pre></td></tr></table></figure><p>上述创建了一个包含 <code>sayHi</code> 方法的对象 <code>john</code>，但对象比原始类型“更重”，需要额外的资源来支持运作。</p><h2 id="当做对象的原始类型"><a href="#当做对象的原始类型" class="headerlink" title="当做对象的原始类型"></a>当做对象的原始类型</h2><p>为解决如下两个问题：</p><ol><li>想对诸如字符串或数字之类的原始类型执行操作；</li><li>原始类型必须尽可能的简单轻量。</li></ol><p>提出如下的解决方法：</p><ol><li>原始类型仍然是原始的，与预期相同，提供单个值；</li><li>JavaScript 允许访问字符串、数字、布尔值和 symbol 的方法和属性；</li><li>为使它们起作用，创建了提供额外功能的特殊“对象包装器”，使用后即被销毁。</li></ol><p>“对象包装器”对于每种原始类型都是不同的，其被称为 <code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Symbol</code> 和 <code>Bigint</code>。因此提供了不同的方法。</p><h3 id="str-toUpperCase"><a href="#str-toUpperCase" class="headerlink" title="str.toUpperCase()"></a>str.toUpperCase()</h3><p>字符串方法 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase">str.toUpperCase()</a> 返回一个大写化处理的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-title function_">alert</span>(str.<span class="hljs-title function_">toUpperCase</span>());   <span class="hljs-comment">// HELLO</span><br></code></pre></td></tr></table></figure><p><code>toUpperCase()</code> 中实际发生的情况：</p><ol><li>字符串 str 是一个原始值。在访问其属性时，会创建一个包含字符串字面量的特殊对象，并且具有可用的方法，如 <code>toUpperCase()</code>；</li><li>该方法运行并返回一个新的字符串（由 <code>alert</code> 显示）；</li><li>特殊对象被销毁后，只留下原始值 <code>str</code>。</li></ol><p>所以原始类型可以提供方法，但他们依然是轻量级。</p><h3 id="toFixed-n"><a href="#toFixed-n" class="headerlink" title="toFixed(n)"></a>toFixed(n)</h3><p>数量方法，如 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed">toFixed(n)</a> 将数字舍入到给定的精度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> n = <span class="hljs-number">1.23456</span>;<br><br><span class="hljs-title function_">alert</span>(n.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>));    <span class="hljs-comment">// 1.23</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>除 null 和 undefined 以外的原始类型都提供了许多有用的方法；</li><li>从形式上看，这些方法通过临时对象工作，但 JavaScript 引擎可以很好的调整，以在内部对齐进行优化，因此调用并不需要太高的成本。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.javascript.info/primitives-methods">https://zh.javascript.info/primitives-methods</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构造器和操作符“new”</title>
    <link href="/2023/04/17/%E6%9E%84%E9%80%A0%E5%99%A8/"/>
    <url>/2023/04/17/%E6%9E%84%E9%80%A0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数一般为常规函数，在构造时通常有以下两个约定：</p><ul><li>命名以答谢字母开始；</li><li>只能由 <code>new</code> 操作符来执行；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Jack&quot;</span>);<br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>);       <span class="hljs-comment">// Jack</span><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">isAdmin</span>);    <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>当一个函数被使用 <code>new</code> 操作符执行时，会执行如下步骤：</p><ul><li>一个新的空对象会被创建并分配给 <code>this</code>；</li><li>函数体执行，通常会修改 <code>this</code>，为其添加新的属性；</li><li>返回 <code>this</code> 的值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-comment">// this = &#123;&#125;; 隐式创建</span><br><br>    <span class="hljs-comment">// 添加属性到 this</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// return this； 隐式返回</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>new User(&quot;Jack&quot;)</code> 的结果与上面为同样的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">User</span> =  &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="构造器模式测试"><a href="#构造器模式测试" class="headerlink" title="构造器模式测试"></a>构造器模式测试</h2><p>在函数内部，可使用 <code>new.target</code> 属性来检查是否被 <code>new</code> 调用。对于常规调用，结果为 <code>undefined</code>，对于使用 <code>new</code> 的调用，则等于该函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span>  <span class="hljs-title function_">User</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>);<br>&#125;<br><br><span class="hljs-comment">// 不带 new</span><br><span class="hljs-title class_">User</span>();     <span class="hljs-comment">// undefined</span><br><br><span class="hljs-comment">// 带 new</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(); <span class="hljs-comment">// function User &#123;...&#125;</span><br></code></pre></td></tr></table></figure><p><code>new.target</code> 属性可被用在函数内部，来判断该函数是被通过 <code>new</code> 调用的“构造器模式”，还是没被通过 <code>new</code> 调用的“常规模式”。</p><p>同时，也可让 new 调用和常规调用做相同的工作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>) &#123;           <span class="hljs-comment">// 若没有通过 new 运行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(name);  <span class="hljs-comment">// 将会添加 new</span><br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-keyword">let</span> john = <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;John&quot;</span>);    <span class="hljs-comment">// 将调用重定向到新用户</span><br><span class="hljs-title function_">alert</span>(john.<span class="hljs-property">name</span>);           <span class="hljs-comment">// John</span><br></code></pre></td></tr></table></figure><h2 id="构造器的-return"><a href="#构造器的-return" class="headerlink" title="构造器的 return"></a>构造器的 return</h2><p>通常，构造器没有 return 语句，其任务是将所有必要的东西写入 this，并自动转化为结果。</p><p>但如果这有一个 return 语句，规则就简单：</p><ul><li>若 return 返回值是一个对象，则返回这个对虾干，而不是 this；</li><li>若 return 返回的是一个原始类型，则忽略；</li></ul><p>换句话说，带有对象的 return 返回该对象，在所有其他情况下返回 this。</p><p>例如，<code>return</code> 通过返回一个对象覆盖 <code>this</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">BigUser</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;John&quot;</span>;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;George&quot;</span>&#125;;    <span class="hljs-comment">// 返回这个对象</span><br>&#125;<br><br><span class="hljs-title function_">alert</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUser</span>().<span class="hljs-property">name</span>);      <span class="hljs-comment">// George，得到那个对象</span><br></code></pre></td></tr></table></figure><p>例如，有一个 return 为空的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SmallUser</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;John&quot;</span>;<br>    <span class="hljs-keyword">return</span>;                     <span class="hljs-comment">// 返回 this</span><br>&#125;<br><br><span class="hljs-title function_">alert</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SmallUser</span>().<span class="hljs-property">name</span>);    <span class="hljs-comment">// John</span><br></code></pre></td></tr></table></figure><h2 id="构造器中的方法"><a href="#构造器中的方法" class="headerlink" title="构造器中的方法"></a>构造器中的方法</h2><p>使用构造函数来创建对象会带来很大的灵活性。既可以将属性添加到 this 中，还可以添加方法。</p><p>例如，下面的 <code>new User(name)</code> 用给定的 <code>name</code> 和方法 <code>sayHi</code> 创建了一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;My name is:&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;John&quot;</span>);<br>john.<span class="hljs-title function_">sayHi</span>();   <span class="hljs-comment">// My name is: John</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>构造函数，简称构造器，就是常规函数；</li><li>构造函数只能使用 <code>new</code> 来调用，这样调用意味着在开始时创建了空的 <code>this</code>，并在最后返回填充了值得 <code>this</code>。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.javascript.info/constructor-new">https://zh.javascript.info/constructor-new</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对象方法</title>
    <link href="/2023/04/14/%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/"/>
    <url>/2023/04/14/%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="对象方法，“this”"><a href="#对象方法，“this”" class="headerlink" title="对象方法，“this”"></a>对象方法，“this”</h2><p>在 JavaScript 中，行为（action）由属性中的函数来表示。行为可以理解为各种动作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br>user.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello!&quot;</span>)<br>&#125;;<br><br>user.<span class="hljs-title function_">sayHi</span>();   <span class="hljs-comment">// Hello!</span><br></code></pre></td></tr></table></figure><p>使用函数表达式创建了一个函数，并将其指定给对象的 <code>user.sayHi</code> 属性，随后使用 <code>user.say</code> 调用，这种作为对象属性的函数被称为 <strong>方法</strong>。</p><p>也可以使用预先声明的函数作为方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><span class="hljs-comment">// 首先，声明函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 然后，将其作为一个方法添加</span><br>user.<span class="hljs-property">sayHi</span> = sayHi;<br>user.<span class="hljs-title function_">sayHi</span>();   <span class="hljs-comment">// Hello!</span><br></code></pre></td></tr></table></figure><blockquote><p>OOP（Object-oriented programming）：<a href="https://en.wikipedia.org/wiki/Object-oriented_programming">面向对象编程</a>，指的是用对象表示实体。</p></blockquote><h2 id="方法简写"><a href="#方法简写" class="headerlink" title="方法简写"></a>方法简写</h2><p>在对象字面量中，有一种更短的（声明）方法的语法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">user = &#123;<br>    <span class="hljs-attr">sayHi</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>    &#125;<br>&#125;;<br>-----------------------------------<br><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;   <span class="hljs-comment">// 与 &quot;sayHi: function()&#123;...&#125;&quot; 一样</span><br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="方法中的”this”"><a href="#方法中的”this”" class="headerlink" title="方法中的”this”"></a>方法中的”this”</h2><p>对象方法需要访问对象中存储的信息才能完成其工作。如 <code>user.sayHi()</code> 中的代码可能需要用到 <code>user</code> 的 name 属性。</p><p><strong>为访问该对象，方法中可使用 <code>this</code> 关键字。</strong><code>this</code> 的值就是在点之前的这个对象，即调用该方法的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br><br>    <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// this 指的是 “当前的对象”</span><br>        <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;；<br>user.<span class="hljs-title function_">sayHi</span>();   <span class="hljs-comment">// John</span><br>-----------------------------------<br><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br><br>    <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;user&quot; 替代 &quot;this&quot;</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="“this”不受限制"><a href="#“this”不受限制" class="headerlink" title="“this”不受限制"></a>“this”不受限制</h2><p><code>this</code> 可用于任何函数，即使它不是对象的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> ); <span class="hljs-comment">// 不会报错</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>this</code> 的值取决于代码上下文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><span class="hljs-keyword">let</span> admin = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Admin&quot;</span> &#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> );<br>&#125;<br><br><span class="hljs-comment">// 在两个对象中使用相同的函数</span><br>user.<span class="hljs-property">f</span> = sayHi;<br>admin.<span class="hljs-property">f</span> = sayHi;<br><br><span class="hljs-comment">// 这两个调用有不同的 this 值</span><br><span class="hljs-comment">// 函数内部的 &quot;this&quot; 是“点符号前面”的那个对象</span><br>user.<span class="hljs-title function_">f</span>();       <span class="hljs-comment">// John（this == user）</span><br>admin.<span class="hljs-title function_">f</span>();      <span class="hljs-comment">// Admin（this == admin）</span><br>admin[<span class="hljs-string">&#x27;f&#x27;</span>]();   <span class="hljs-comment">// Admin（使用点符号或方括号语法来访问这个方法，都没有关系。）</span><br></code></pre></td></tr></table></figure><p>在没有对象的情况下调用：<code>this == undefined</code>。</p><h2 id="箭头函数没有自己的”this”"><a href="#箭头函数没有自己的”this”" class="headerlink" title="箭头函数没有自己的”this”"></a>箭头函数没有自己的”this”</h2><p>箭头函数没有自己的 <code>this</code>，若在函数中引用 <code>this</code>，<code>this</code> 值取决于外部 “正常的” 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Ilya&quot;</span>,<br>    <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-title function_">arrow</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span>);<br>        <span class="hljs-title function_">arrow</span>();<br>    &#125;<br>&#125;;<br><br>user.<span class="hljs-title function_">sayHi</span>();   <span class="hljs-comment">// Ilya</span><br><span class="hljs-comment">// arrow() 使用的 this 来自于外部的 user.sayHi() 方法</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>存储在对象属性中的函数被称为“方法”；</li><li>方法允许对象进行像 <code>object.doSomething()</code> 这样的“操作”；</li><li>方法可以将对象引用为 <code>this</code>。</li></ul><p><code>this</code> 的值是在程序运行时得到的。</p><ul><li>一个函数在声明时，可能就使用了 <code>this</code>，但是这个 <code>this</code> 只有在函数被调用时才会有值。</li><li>可以在对象之间复制函数。</li><li>以“方法”的语法调用函数时：<code>object.method()</code>，调用过程中的 <code>this</code> 值是 <code>object</code>。</li></ul><p>请注意箭头函数有些特别：它们没有 <code>this</code>。在箭头函数内部访问到的 <code>this</code> 都是从外部获取的。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSON Object 对象 &lt;二&gt;</title>
    <link href="/2023/04/13/JSON%20Object%20%E5%AF%B9%E8%B1%A1(2)/"/>
    <url>/2023/04/13/JSON%20Object%20%E5%AF%B9%E8%B1%A1(2)/</url>
    
    <content type="html"><![CDATA[<h2 id="对象引用和复制"><a href="#对象引用和复制" class="headerlink" title="对象引用和复制"></a>对象引用和复制</h2><p>对象与原始类型的根本区别之一是，对象是“通过引用”存储和复制的，而原始类型：字符串、数字、布尔值等是“作为一个整体复制”。</p><ul><li>原始类型复制值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-keyword">let</span> phrase = message    <span class="hljs-comment">// 两个独立变量，每个中都存储着字符串 &quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/../image/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%AF%94%E5%96%BB%E5%9B%BE7.png" alt="键值对比喻图"></p><ul><li>对象复制值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>赋值了对象的变量存储的不是对象本身，而是该对象“在内存中的地址”，就是对该对象的“引用”。</p><p><img src="/../image/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%AF%94%E5%96%BB%E5%9B%BE8.png" alt="键值对比喻图"></p><p>上图表示该对象被存储在内存中的某个位置（在图片的右侧），而变量 <code>user</code> (在左侧)保存的是对其的“引用”。</p><p>可以将一个对象变量（如 <code>user</code> ）想象成一张写有对象的地址的纸，当对对象执行操作时，例如获取一个属性 <code>user.name</code>，JavaScript 引擎会查看该地址中的内容，并在实际对象上执行操作。</p><p><strong>当一个对象变量被复制，则引用被复制，而该对象本身并未被复制。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><span class="hljs-keyword">let</span> admin = user;   <span class="hljs-comment">// 复制引用</span><br></code></pre></td></tr></table></figure><p><img src="/../image/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%AF%94%E5%96%BB%E5%9B%BE9.png" alt="键值对比喻图"></p><p>变量 <code>user</code> 和 <code>admin</code> 都保存着对同一个对象的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br><span class="hljs-keyword">let</span> admin = user;<br>admin.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Pete&#x27;</span>; <span class="hljs-comment">// 通过 &quot;admin&quot; 引用来修改</span><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;Pete&#x27;，修改能通过 &quot;user&quot; 引用看到</span><br></code></pre></td></tr></table></figure><p>可以通过其中任意一个变量来访问该对象并修改它的内容。这就像有一个带有两把钥匙的柜子，使用其中一把钥匙（<code>admin</code>）打开柜子并更改了里面的东西。那么，如果我们稍后用另一把钥匙（<code>user</code>），我们仍然可以打开同一个柜子并且可以访问更改的内容。</p><h2 id="通过引用来比较"><a href="#通过引用来比较" class="headerlink" title="通过引用来比较"></a>通过引用来比较</h2><p>仅当两个对象为同一对象时，两者才相等。例如，这里的 <code>a</code> 和 <code>b</code> 两个变量都引用同一个对象，所以两者相等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> a = &#123;&#125;;<br><span class="hljs-keyword">let</span> b = a;      <span class="hljs-comment">// 复制引用</span><br><span class="hljs-title function_">alert</span>(a == b);  <span class="hljs-comment">// true，都引用同一对象</span><br><span class="hljs-title function_">alert</span>(a === b); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>但两个独立的对象并不相等，即使两者看起来很像（都为空）；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> a = &#123;&#125;;<br><span class="hljs-keyword">let</span> b = &#123;&#125;;         <span class="hljs-comment">// 两个独立的对象</span><br><span class="hljs-title function_">alert</span>( a == b );    <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="克隆与合并，Object-assign"><a href="#克隆与合并，Object-assign" class="headerlink" title="克隆与合并，Object.assign"></a>克隆与合并，Object.assign</h2><p>如上所述，复制一个对象变量会创建一个对相同对象的引用。若想要复制一个对象，需要如下做法。</p><p>创建一个新对象，通过遍历已有对象的属性，并在原始类性值的层面复制它们，以实现对已有对象结构的复制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;George&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">27</span><br>&#125;;<br><span class="hljs-keyword">let</span> clone = &#123;&#125;;             <span class="hljs-comment">// 创建一个新的空对象</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) &#123;     <span class="hljs-comment">// 将 user 中所有的属性拷贝到其中</span><br>    clone[key] = user[key];<br>&#125;<br><br><span class="hljs-comment">// 现在 clone 是带有相同内容的完全独立的对象</span><br>clone.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Pete&quot;</span>; <span class="hljs-comment">// 改变了其中的数据</span><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">name</span> ); <span class="hljs-comment">// 原来的对象中的 name 属性依然是 George</span><br></code></pre></td></tr></table></figure><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(dest, [src1, src2, src3...])<br></code></pre></td></tr></table></figure><ul><li>第一个参数 <code>dest</code> 是指目标对象；</li><li>后面的参数 <code>src1, ..., srcN</code> （可按需传递多个参数）是源对象；</li><li>该方法将所有源对象的属性拷贝到目标对象 <code>dest</code> 中。换句话说，从第二个开始的所有参数的属性都被拷贝到第一个参数的对象中；</li><li>调用结果返回 dest。</li></ul><p>使用 <code>Object.assign</code> 来合并多个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><br><span class="hljs-keyword">let</span> permissions1 = &#123; <span class="hljs-attr">canView</span>: <span class="hljs-literal">true</span> &#125;;<br><span class="hljs-keyword">let</span> permissions2 = &#123; <span class="hljs-attr">canEdit</span>: <span class="hljs-literal">true</span> &#125;;<br><br><span class="hljs-comment">// 将 permission1 和 permission2 中的所有属性都拷贝到 user 中</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(user, permission1, permission2);<br><span class="hljs-comment">// 现在 user = &#123; name: &quot;John&quot;, canView: true, canEdit: true &#125;</span><br></code></pre></td></tr></table></figure><p>如果被拷贝的属性的属性名已经存在，那该属性名会被覆盖。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(user, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span> &#125;);<br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>);   <span class="hljs-comment">// 现在 user = &#123; name: &quot;Pete&quot; &#125;</span><br></code></pre></td></tr></table></figure><p>也可使用 <code>Object.assign</code> 代替 <code>for..in</code> 循环来进行简单克隆。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, user);<br><span class="hljs-comment">// 将 user 中的所有属性拷贝到了一个空对象中，并返回这个新的对象。</span><br></code></pre></td></tr></table></figure><h2 id="深层克隆"><a href="#深层克隆" class="headerlink" title="深层克隆"></a>深层克隆</h2><p>上述例子中，均假设 <code>user</code> 的所有属性均为原始类型，但属性也可以是对其他对象的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br>------------------------------------------<br><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>    <span class="hljs-attr">sizes</span>: &#123;            <span class="hljs-comment">// 对其他对象的引用</span><br>        <span class="hljs-attr">height</span>: <span class="hljs-number">182</span>,<br>        <span class="hljs-attr">width</span>: <span class="hljs-number">50</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>    <span class="hljs-attr">sizes</span>: &#123;            <span class="hljs-comment">// 对其他对象的引用</span><br>        <span class="hljs-attr">height</span>: <span class="hljs-number">182</span>,<br>        <span class="hljs-attr">width</span>: <span class="hljs-number">50</span><br>    &#125;<br>&#125;;<br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">sizes</span>.<span class="hljs-property">height</span> ); <span class="hljs-comment">// 182</span><br><br><span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, user);<br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">sizes</span> === clone.<span class="hljs-property">sizes</span> );    <span class="hljs-comment">// true,同为一个对象</span><br><br><span class="hljs-comment">// user 和 clone 分享同一个 sizes</span><br>user.<span class="hljs-property">sizes</span>.<span class="hljs-property">width</span>++;         <span class="hljs-comment">// 通过 user 改变属性值</span><br><span class="hljs-title function_">alert</span>(clone.<span class="hljs-property">sizes</span>.<span class="hljs-property">width</span>);   <span class="hljs-comment">// 51,能从clone中获取到变更后的结果</span><br></code></pre></td></tr></table></figure><p>深拷贝：为使 <code>user</code> 和 <code>clone</code> 成为两个真正独立的对象，可使用一个拷贝循环来检查 <code>user[key]</code> 的每个值，如果 <code>user[key]</code> 是一个对象，也复制其结构。</p><p>可使用递归来实现，或采用现有的实现，例如 <code>lodash</code> 库的 <code>_.cloneDeep(obj)</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对象通过引用被赋值和拷贝。一个变量存储的不是 “对象的值”，而是一个对值的 “引用”（内存地址），因此拷贝此类变量或将其作为函数参数传递时，所拷贝是引用，而不是对象本身。</p><p>所有通过被拷贝的引用的操作（如添加、删除属性）都作用在同一对象上。</p><p>创建 “真正的拷贝”（一个克隆），可使用 <code>Object.assign</code> 实现 “浅拷贝”（嵌套对象被通过引用进行拷贝），或使用 “深拷贝” 函数，如 <code>_.cloneDeep(obj)</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.javascript.info/object-copy">https://zh.javascript.info/object-copy</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSON Object 对象 &lt;一&gt;</title>
    <link href="/2023/04/11/JSON%20Object%20%E5%AF%B9%E8%B1%A1(1)/"/>
    <url>/2023/04/11/JSON%20Object%20%E5%AF%B9%E8%B1%A1(1)/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Object（对象）是用来存储键值对和更复杂的实体。通过使用带有可选 <strong>属性列表</strong> 的花括号 <code>&#123;...&#125;</code> 创建对象。一个属性就是一个键值对 （”key:value”），其中键（key）是一个字符串，值（value）可以是任何值。</p><p>可以把对象想象成一个带有签名文件的文件柜，每条数据都基于键（key）存储在文件中，这样可根据文件名（也就是“键”）添加&#x2F;删除&#x2F;查找文件。</p><p><img src="/../image/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%AF%94%E5%96%BB%E5%9B%BE1.png" alt="键值对比喻图"></p><p>创建一个空的对象（“空柜子”）方法：构造函数或者字面量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();    <span class="hljs-comment">// &quot;构造函数&quot;</span><br><span class="hljs-keyword">let</span> user = &#123;&#125;;              <span class="hljs-comment">// &quot;字面量&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/../image/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%AF%94%E5%96%BB%E5%9B%BE2.png" alt="键值对比喻图"></p><h2 id="文本和属性"><a href="#文本和属性" class="headerlink" title="文本和属性"></a>文本和属性</h2><p>创建对象时，可以立即将一些属性以键值对的形式放入 <code>&#123;...&#125;</code> 中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> usr = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;George&quot;</span>,     <span class="hljs-comment">// 键 &quot;name&quot;，值 &quot;George&quot;</span><br>    <span class="hljs-attr">age</span>: <span class="hljs-number">27</span>             <span class="hljs-comment">// 键 &quot;age&quot;，值 27</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>user</code> 对象中，有两个属性：</p><ol><li>第一个的键是 <code>&quot;name&quot;</code>，值是 <code>&quot;George&quot;</code>;</li><li>第一个的键是 <code>&quot;age&quot;</code>，值是 <code>&quot;27&quot;</code>。</li></ol><p>生成的 <code>user</code> 对象可以被想象为一个放置着两个标记有 <code>“name”</code> 和 <code>“age”</code> 的文件的柜子，能够随时添加、删除和读取文件。</p><p><img src="/../image/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%AF%94%E5%96%BB%E5%9B%BE3.png" alt="键值对比喻图"></p><ul><li><p>使用 <code>.</code> 点符号访问属性值；</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>);   <span class="hljs-comment">// George</span><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">age</span>);    <span class="hljs-comment">// 27</span><br></code></pre></td></tr></table></figure><p>  属性值可以是任意类型。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javaScript">user.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>  <img src="/../image/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%AF%94%E5%96%BB%E5%9B%BE4.png" alt="键值对比喻图"></p></li><li><p>使用 <code>delete</code> 操作符移除属性；</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">delete</span> user.<span class="hljs-property">age</span><br></code></pre></td></tr></table></figure><p>  <img src="/../image/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%AF%94%E5%96%BB%E5%9B%BE5.png" alt="键值对比喻图"></p></li><li><p>使用多字词语来作为属性名，但必须给它们加上引号；</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;George&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">27</span>,<br>    <span class="hljs-string">&quot;likes birds&quot;</span>: <span class="hljs-literal">true</span>  <span class="hljs-comment">// 多词属性名必须加引号</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>  <img src="/../image/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%AF%94%E5%96%BB%E5%9B%BE6.png" alt="键值对比喻图">   </p></li><li><p>列表中最后一个属性应以逗号结尾；</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;George&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">27</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="点符号与方括号"><a href="#点符号与方括号" class="headerlink" title="点符号与方括号"></a>点符号与方括号</h2><p>点操作不能用于多次属性。</p><ul><li>点符号：要求 <code>key</code> 是有效的变量标识符，不能包含空格，不以数字开头，不包含特殊符号（允许使用 <code>$</code> 和 <code>_</code>）</li><li>方括号：可用于任何字符串，方括号中的字符串需要放在引号中，单&#x2F;双引号均可；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javaScript">user.<span class="hljs-property">likes</span> birds = <span class="hljs-literal">true</span>     <span class="hljs-comment">// 误以为处理 user.likes，遇到 birds 时会报语法错误</span><br>-----------------------<br><span class="hljs-keyword">let</span> user = &#123;&#125;<br>user[<span class="hljs-string">&quot;likes birds&quot;</span>] = <span class="hljs-literal">true</span>  <span class="hljs-comment">// 设置</span><br><span class="hljs-title function_">alert</span>(user[<span class="hljs-string">&quot;likes birds&quot;</span>]); <span class="hljs-comment">// 读取，true</span><br><span class="hljs-keyword">delete</span> user[<span class="hljs-string">&quot;likes birds&quot;</span>]; <span class="hljs-comment">// 删除</span><br></code></pre></td></tr></table></figure><p>同时，方括号提供了一种可以通过任意表达式来获取属性名的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> key = <span class="hljs-string">&quot;likes birds&quot;</span>;<br>user[key] = <span class="hljs-literal">true</span>;<br>-----------------------<br>user[<span class="hljs-string">&quot;likes birds&quot;</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 与上面等同</span><br></code></pre></td></tr></table></figure><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>计算属性：当创建一个对象时，可以在对象字面量中使用方括号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> fruit = <span class="hljs-string">&#x27;apple&#x27;</span>;<br><span class="hljs-keyword">let</span> bag = &#123;<br>    [fruit]: <span class="hljs-number">5</span>,     <span class="hljs-comment">// 属性名从 fruit 变量中得到，此时 bag 变为 &#123;apple：5&#125;</span><br>&#125;<br><span class="hljs-title function_">alert</span>(bag.<span class="hljs-property">apple</span>);   <span class="hljs-comment">// 5</span><br>-----------------------<br><span class="hljs-keyword">let</span> fruit = <span class="hljs-string">&#x27;apple&#x27;</span>;<br><span class="hljs-keyword">let</span> bag = &#123;&#125;;<br>bag[fruit] = <span class="hljs-number">5</span>;     <span class="hljs-comment">// 与上面等同</span><br></code></pre></td></tr></table></figure><p>计算属性含义为：<code>[fruit]</code> 含义是属性名从 <code>fruit</code> 变量中获取。</p><p>方括号可用于更复杂的表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> fruit = <span class="hljs-string">&#x27;apple&#x27;</span>;<br><span class="hljs-keyword">let</span> bag = &#123;<br>    [fruit + <span class="hljs-string">&#x27;Computers&#x27;</span>]: <span class="hljs-number">5</span>    <span class="hljs-comment">// bag.appleComputers = 5</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="属性值简写"><a href="#属性值简写" class="headerlink" title="属性值简写"></a>属性值简写</h2><p>使用已经存在的变量当作属性名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeUser</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">name</span>: name,<br>        <span class="hljs-attr">age</span>: age,<br>        <span class="hljs-comment">// ……其他的属性</span><br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-title function_">makeUser</span>(<span class="hljs-string">&quot;George&quot;</span>, <span class="hljs-number">27</span>);<br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>);   <span class="hljs-comment">// George</span><br></code></pre></td></tr></table></figure><h2 id="属性名称限制"><a href="#属性名称限制" class="headerlink" title="属性名称限制"></a>属性名称限制</h2><p>变量名不能是某个保留字，如 <code>&quot;for&quot;</code>、<code>&quot;let&quot;</code>、<code>&quot;return&quot;</code>，但对象的属性名不受限制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">for</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">let</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">return</span>: <span class="hljs-number">3</span><br>&#125;;<br><span class="hljs-title function_">alert</span>( obj.<span class="hljs-property">for</span> + obj.<span class="hljs-property">let</span> + obj.<span class="hljs-property">return</span> );    <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure><h2 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for..in 循环"></a>for..in 循环</h2><p><code>for..in</code> 可以遍历一个对象中的所有键（key）.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">for</span>(key <span class="hljs-keyword">in</span> object)&#123;<br>    <span class="hljs-comment">// </span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;George&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">27</span>,<br>    <span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">true</span><br>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user)&#123;<br>    <span class="hljs-title function_">alert</span>(key);         <span class="hljs-comment">// name，age，isAdmin</span><br>    <span class="hljs-title function_">alert</span>(user[key]);   <span class="hljs-comment">// George，27，true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>所有 “for” 结构体都允许在循环体中定义变量，例如 <code>let key</code>；</li><li>可以使用其他属性名来替代 <code>key</code>，例如 <code>for(let prop in obj)</code>。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对象是具有一些特殊特性的关联数组，存储属性（键值对），其中：</p><p>属性的键必须是字符串或者 symbol（通常是字符串），值可以是任何类型。可以用下面的方法访问属性：</p><ul><li>点符号: obj.property；</li><li>方括号：obj[“property”]，方括号允许从变量中获取键，例如 obj[varWithKey]。</li></ul><p>其他操作：</p><ul><li>删除属性：delete obj.prop；</li><li>检查是否存在给定键的属性：”key” in obj；</li><li>遍历对象：for(let key in obj) 循环。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.javascript.info/object#shu-xing-cun-zai-xing-ce-shi-in-cao-zuo-fu">https://zh.javascript.info/object#shu-xing-cun-zai-xing-ce-shi-in-cao-zuo-fu</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端未响应</title>
    <link href="/2023/04/07/%E5%89%8D%E7%AB%AF%E6%9C%AA%E5%93%8D%E5%BA%94/"/>
    <url>/2023/04/07/%E5%89%8D%E7%AB%AF%E6%9C%AA%E5%93%8D%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<h2 id="前端未响应"><a href="#前端未响应" class="headerlink" title="前端未响应"></a>前端未响应</h2><p>前端未响应，显示连接不上 <code>localhost:8092</code> (自己的端口号)，可以尝试使用以下命令解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsof -i:8092    // 查看占用的 pid，比如查出来是 1221<br><span class="hljs-built_in">kill</span> 1221<br>ctrl+<span class="hljs-built_in">shift</span>+p    // 输入 reloadwindow  重新加载vscode<br></code></pre></td></tr></table></figure><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><p><a href="https://en.wikipedia.org/wiki/Lsof">lsof</a>（list open files）意为列出打开的文件，主要用作查看类 Unix 系统中所有打开的文件和打开它们进度的列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsof -i -n -P | grep sendmail<br>sendmail  31649    root    4u  IPv4 521738       TCP *:25 (LISTEN)<br></code></pre></td></tr></table></figure><p>从上面可以看出，“sendmail”正在监听其标准端口“25”。</p><ul><li><code>-i</code><br>  Lists IP sockets.</li><li><code>-n</code><br>  Do not resolve hostnames (no DNS).</li><li><code>-P</code><br>  Do not resolve port names (list port number instead of its name).</li></ul><pre><code class="hljs"></code></pre>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>element 日期选择器</title>
    <link href="/2023/04/07/element%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <url>/2023/04/07/element%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="日期范围选择器"><a href="#日期范围选择器" class="headerlink" title="日期范围选择器"></a>日期范围选择器</h2><p>日期范围选择器限制只选择今天及以前的日期。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;el-date-picker <br>    style=&quot;margin-left: 5px;&quot; <br>    v-model=&quot;valueTime&quot; <br>    type=&quot;daterange&quot; <br>    format=&quot;yyyy-MM-dd&quot; <br>    unlink-panels<br>    value-format=&quot;yyyy-MM-dd&quot;<br>    range-separator=&quot;至&quot;<br>    start-placeholder=&quot;开始日期&quot;<br>    end-placeholder=&quot;结束日期&quot;<br>    :picker-options=&quot;pickerOptions&quot;&gt;<br>&lt;/el-date-picker&gt;<br></code></pre></td></tr></table></figure><ul><li><code>unlink-panels</code>: 在范围选择器里取消两个日期面板之间的联动。</li></ul><p>在组件中需进行如下设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>    valueTime: &quot;&quot;,<br>    pickerOptions: &#123;<br>        disabledDate (time) &#123;<br>            return time.getTime() &gt; Date.now();<br>        &#125;<br>    &#125;,<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>实际效果如下：</p><p><img src="/../image/element%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%E5%99%A8_1.1.png" alt="element日期选择器1"></p><p><img src="/../image/element%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%E5%99%A8_1.2.png" alt="element日期选择器2"></p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>其他几种常见日期设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>    pickerOptions: &#123;<br>        disabledDate(time) &#123;<br>            // 设置选择今天以及今天之后的日期<br>            return time.getTime() &lt; Date.now() - 8.64e7<br>            // 设置选择今天以及今天以前的日期<br>            return time.getTime() &gt; Date.now();<br>            // 设置选择今天之后的日期（不能选择当天时间）<br>            return time.getTime() &lt; Date.now();        <br>            // 设置选择今天之前的日期（不能选择当天）<br>            return time.getTime() &gt; Date.now() - 8.64e7 <br>            // 设置当天23：59：59可选<br>            let currentTime = this.getNowMonthDay() + ` 23:59:59`<br>                return time.getTime() &gt; new Date(currentTime).getTime()<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://element.eleme.cn/2.0/#/zh-CN/component/date-picker">https://element.eleme.cn/2.0/#/zh-CN/component/date-picker</a></p><p><a href="https://segmentfault.com/q/1010000037421298">https://segmentfault.com/q/1010000037421298</a></p>]]></content>
    
    
    <categories>
      
      <category>Element</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2023/04/07/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2023/04/07/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><p><img src="/../image/404.jpg" alt="测试图片"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/07/hello-world/"/>
    <url>/2023/04/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
