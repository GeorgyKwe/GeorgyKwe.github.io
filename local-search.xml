<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SSH免密登录</title>
    <link href="/2023/12/21/SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"/>
    <url>/2023/12/21/SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="SSH简介"><a href="#SSH简介" class="headerlink" title="SSH简介"></a>SSH简介</h2><p>SSH（Secure Shell，安全外壳）是一种网络安全协议，通过加密和认证机制实现安全的访问和文件传输等业务。</p><h2 id="SSH安装"><a href="#SSH安装" class="headerlink" title="SSH安装"></a>SSH安装</h2><p>SSH开源实现有<a href="https://www.openssh.com/">OpenSSH</a>，存在服务端（sshd）和客户端（ssh）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#Linux</span><br>sudo apt-get install openssh-server<br></code></pre></td></tr></table></figure><h2 id="SSH秘钥生成"><a href="#SSH秘钥生成" class="headerlink" title="SSH秘钥生成"></a>SSH秘钥生成</h2><p>执行<code>ssh-keygen</code>即可生成SSH钥匙，一路回车即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa<br></code></pre></td></tr></table></figure><p>参数说明：</p><p><code>-t</code>：指定秘钥生成算法，通常是<code>rsa</code>或<code>dsa</code>算法；</p><p>在<code>~/.ssh</code>目录下会生成<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，其中<code>id_rsa</code>为私钥文件，<code>id_rsa.pub</code>为对应的公钥文件。</p><h2 id="SSH免密登录"><a href="#SSH免密登录" class="headerlink" title="SSH免密登录"></a>SSH免密登录</h2><p>每次SSH都要输入密码是不是很烦呢？要实现免密码登入，需要将生成的<code>id_rsa.pub</code>放在远程机器上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#第一种方式</span><br>ssh-copy-id user@hostname<br><span class="hljs-comment">#第二种方式</span><br>ssh-copy-id ~/.ssh/id_rsa.pub user@remote:~/.ssh/<br><span class="hljs-comment">#第三种方式：使用-p选项指定端口号，默认是目标主机的22端口</span><br>ssh -p 10022 user@hostname<br></code></pre></td></tr></table></figure><h2 id="SSH-agent"><a href="#SSH-agent" class="headerlink" title="SSH agent"></a>SSH agent</h2><p>SSH agent（SSH代理），是一个密钥管理器，用来管理一个多个密钥，并为其他需要使用<code>ssh-key</code>的程序提供代理，为了让其他程序更方便的使用这套加密技术，就有了SSH agent。</p><p>当把私钥交给SSH agent管理的好处：</p><ul><li>当其他程序需要身份验证时，可以将验证申请交给SSH agent来完成整个认证过程。使用不同的密钥连接到不同的主机时，需要手动指定对应的密钥，而ssh代理可以自动帮助我们选择对应的密钥进行认证；</li><li>避免重复输入密码：如果私钥使用密码短语来加密，则每一次使用SSH密钥登录时，都必须输入正确的密码短语。而SSH agent程序能够将已解密的私钥缓存起来，在需要时提供给SSH客户端。因此只需要在使用<code>ssh-add</code>时将私钥加入SSH agent缓存时，输入一次密码短语就可以。</li></ul><ol><li><p>检查相应的SSH密钥是否被加载：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-add -l<br></code></pre></td></tr></table></figure></li><li><p>如果没有被加载，则使用下面的命令加载私钥</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 后面可同时跟多个私钥</span><br>ssh-add ~/.ssh/&lt;private_key_file&gt;<br></code></pre></td></tr></table></figure></li></ol><p>若有其他别名的<code>id_rsa</code>都可一并加入。</p><h2 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h2><p>每次都输入<code>ssh user@remote</code>，时间久了也会觉得很麻烦，特别是当<code>user，remote和port</code>都得输入，而且还不好记忆时。配置别名可以让我们进一步偷懒，比如我想用<code>ssh master</code>来替代上面这么一长串，那么在<code>~/.ssh/config</code>里面追加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host master<br>    HostName remote<br>    User user<br>    Port port<br></code></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="SSH免密登录失效"><a href="#SSH免密登录失效" class="headerlink" title="SSH免密登录失效"></a>SSH免密登录失效</h3><p>在环境变量（<code>~/.bashrc</code>或<code>~/.zshrc</code>或<code>~/.profile</code>）中<a href="https://zhuanlan.zhihu.com/p/126117538">添加ssh-agent命令</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">eval</span> $(ssh-agent)<br>ssh-add ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure><p>设置SSH权限为<a href="https://zhuanlan.zhihu.com/p/52276792">正确状态</a>，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#本地主机和目标主机都需要设置权限</span><br><span class="hljs-built_in">chmod</span> 600 .ssh<br><span class="hljs-built_in">chmod</span> 700 autherized_key<br><span class="hljs-built_in">chmod</span> 700 id_rsa<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/SSH.html">什么是SSH？</a></p><p><a href="https://zhuanlan.zhihu.com/p/126117538">ssh agent详解</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dockerfile编写</title>
    <link href="/2023/11/28/Dockerfile%E7%BC%96%E5%86%99/"/>
    <url>/2023/11/28/Dockerfile%E7%BC%96%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Dockerfile是一种被Docker程序解释的脚本，由一条条命令组成，由Docker程序将这些Dockerfile指令翻译成真正的Linux命令。Docker程序读取Dockerfile并根据指令生成Docker镜像，相比手动制作镜像方式，Dockerfile更能直观展示镜像如何产生。当写好各种各样的Dockerfile文件，当之后某个镜像有额外需求时，只要在之前Dockerfile添加或者修改相应操作即可生成新的Docker镜像，避免重复手动制作镜像。</p><h2 id="下载镜像并初始化系统"><a href="#下载镜像并初始化系统" class="headerlink" title="下载镜像并初始化系统"></a>下载镜像并初始化系统</h2><p>使用rpm安装Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm -ivh --force --nodeps docker-engine-18.09.0-320.oe2303.riscv64.rpm<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>force：强制安装；</li><li>nodeps：忽视依赖关系；</li></ul><p>拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull riscv64/ubuntu<br></code></pre></td></tr></table></figure><p>创建ngnix目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> nginx &amp;&amp; <span class="hljs-built_in">cd</span> nginx<br></code></pre></td></tr></table></figure><h2 id="Dockerfile格式"><a href="#Dockerfile格式" class="headerlink" title="Dockerfile格式"></a>Dockerfile格式</h2><p><strong>FROM</strong>：指定基于哪个基础镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">格式  FROM &lt;image&gt; 或 FROM &lt;image&gt;:&lt;tag&gt;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">FROM centos<br>FROM centos:latest<br>FROM ubuntu<br></code></pre></td></tr></table></figure><p><strong>MAINTAINER</strong>：指定作者信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">格式  MAINTAIN &lt;name&gt;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">MAINTAINER George xxx@163.com<br></code></pre></td></tr></table></figure><p><strong>RUN</strong>：镜像操作指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">格式  RUN &lt;<span class="hljs-built_in">command</span>&gt; 或 RUN [“executable”, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">RUN yum install httpd<br>RUN yum -y install httpd<br>RUN apt-get install httpd<br>RUN [<span class="hljs-string">&quot;/bin/bash&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo hello&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>CMD</strong>：RUN和CMD看起来挺像，但CMD用来指定容器启动时用到的命令，只能有一条</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">格式  CMD [<span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>] 或 CMD [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>] 或 CMD <span class="hljs-built_in">command</span> param1 param2<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">CMD [<span class="hljs-string">&quot;/bin/bash&quot;</span>, <span class="hljs-string">&quot;/usr/local/nginx/sbin/nginx&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;/usr/local/nginx/conf/nginx.conf&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>EXPOSE</strong>：指定要映射出去的端口，如容器内部启动了sshd和nginx，需要把22和80端口暴漏出去。这个需要配合-P（大写）来工作，也就是说在启动容器时，需要加上-P，让它自动分配。如果想指定具体的端口，也可以使用-p（小写）来指定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">格式  EXPOSE &lt;port&gt; [&lt;port&gt;...]<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">EXPOSE 22 80 8443<br></code></pre></td></tr></table></figure><p><strong>ENV</strong>：为后续RUN指令提供一个环境变量，也可定义一些自定义变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">格式  ENV &lt;key&gt; &lt;value&gt; <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ENV PATH /usr/local/mysql/bin:<span class="hljs-variable">$PATH</span><br>ENV MYSQL_version 5.6<br></code></pre></td></tr></table></figure><p><strong>ADD</strong>：将本地一个文件或目录拷贝到容器的某个目录里，其中src为Dockerfile所在目录的相对路径，它也可以是一个url</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">格式  ADD &lt;src&gt; &lt;dest&gt;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ADD &lt;conf/vhosts&gt; &lt;/usr/local/nginx/conf&gt;<br></code></pre></td></tr></table></figure><p><strong>COPY</strong>：使用方法和add一样，不同的是，它不支持url</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">格式  COPY &lt;src&gt; &lt;dest&gt;<br></code></pre></td></tr></table></figure><p><strong>ENTRYPOINT</strong>：容器启动时要执行的命令，与CMD很像，也是只有一条生效，如果写多个只有最后一条有效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">格式  ENTRYPOINT [<span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>] 或 CMD [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>] 或 CMD <span class="hljs-built_in">command</span> param1 param2<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ENTRYPOINT [<span class="hljs-string">&quot;echo&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>VOLUME</strong>：创建一个可以从本地主机或其他容器挂载的挂载点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">格式  VOLUME [<span class="hljs-string">&quot;/data&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>USER</strong>：指定运行容器的用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">格式  USER daemon<br></code></pre></td></tr></table></figure><p><strong>WORKDIR</strong>：为后续RUN、CMD或者ENTRYPOINT指定工作目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">格式  WORKDIR /path/to/workdir<br></code></pre></td></tr></table></figure><h2 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi dockerfile<br></code></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment">#设置基础镜像 </span><br><span class="hljs-keyword">FROM</span> riscv64/ubuntu:latest<br><span class="hljs-comment">#作者信息</span><br><span class="hljs-keyword">MAINTAINER</span> George<br><span class="hljs-comment">#安装新的第三方yum源</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install epel-release</span><br><span class="hljs-comment">#更新</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get upgrade</span><br><span class="hljs-comment">#安装相关依赖包</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install wget net-tools</span><br><span class="hljs-comment">#安装Nginx</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get -y install nginx</span><br><span class="hljs-comment">#暴露端口80和443</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">443</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;daemon off;&quot;</span> &gt;&gt;/etc/nginx/nginx.conf</span><br><span class="hljs-comment">#切换工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /root/nginx/</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> index.html /usr/share/nginx/html/index.html</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> run.sh /run.sh</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">chmod</span> 755 /run.sh</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/run.sh&quot;</span>]</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi index.html<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><br>            My Docker instance <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>My Docker Test!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>&gt;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi run.sh<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>/usr/sbin/nginx<br></code></pre></td></tr></table></figure><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t riscv64/nginx:1.0 .<br>docker image list<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.aliyun.com/article/486362">Docker中Dockerfile的格式、Dockerfile安装nginx实例</a></p><p><a href="https://yeasy.gitbook.io/docker_practice/appendix/repo/nginx">Nginx</a></p><p><a href="https://blog.csdn.net/a772304419/article/details/133709530?spm=1001.2014.3001.5501">Dockerfile教程：制作基于centos7的Nginx Docker镜像</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACPI概述</title>
    <link href="/2023/11/23/ACPI%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/11/23/ACPI%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="ACPI历史"><a href="#ACPI历史" class="headerlink" title="ACPI历史"></a>ACPI历史</h2><p>高级配置和电源接口（Advanced Configuration and Power Interface：ACPI）是在1990年代中期通过Intel、Microsoft、Toshiba、HP和Phoenix之间的合作开发的。</p><p>ACPI为了解决以下三个问题而开发：</p><p>1.操作系统应用程序的行为可能会受到BIOS(BasicInput&#x2F;OutputSystem)配置的电源管理设置的负面影响，导致系统在演示或其他不方便的时间进入睡眠状态；</p><p>2.电源管理接口在每个系统上都是专有的。这需要开发人员学习如何为每个单独的系统配置电源管理；</p><p>3.各种设备的默认设置也可能相互冲突，导致设备崩溃、行为异常或变得无法发现。</p><h2 id="什么是ACPI？"><a href="#什么是ACPI？" class="headerlink" title="什么是ACPI？"></a>什么是ACPI？</h2><p>ACPI可理解为独立于体系结构电源管理和配置框架，它在主机操作系统中形成一个子系统。该框架建立了一个硬件寄存器集来定义电源状态（睡觉、休眠、唤醒等）。该硬件寄存器集可以使用专用硬件和通用硬件上的操作。</p><p>标准ACPI框架和硬件寄存器集的主要用途是启用电源管理和系统配置，无需直接从操作系统调用固件。ACPI充当操作系统和系统固件之间的接口层，如下图所示。</p><p><img src="/../image/ACPI_pic/ACPI%E6%A6%82%E8%A7%88.png" alt="ACPI概览"></p><p>ACPI定义了两种类型的数据结构：数据表和定义块，通过ACPI子系统在系统固件和操作系统之间共享，如下图所示。这些数据结构是固件和操作系统之间的主要通信机制。</p><p>-数据表：存储原始数据，并由设备驱动程序使用；<br>-定义块：由AML解释器执行的字节码组成。</p><p><img src="/../image/ACPI_pic/ACPI%E7%BB%93%E6%9E%84.png" alt="ACPI结构"></p><p>初始化时，AML解释器将定义块中的字节码提取为可枚举对象，这个可枚举对象的集合形成了一个称为ACPI命名空间(Namespace)的OS构造。ACPI命名空间中的对象可以具有直接定义的值，也可以由AML解释器计算。AML解释器由操作系统指导、评估对象，然后与系统硬件接口执行必要的操作。</p><p>定义块字节代码是从ACPI源语言(ACPISourceLanguage:ASL)代码编译而来，ASL是用于定义ACPI对象和编写控制方法的语言。ASL编译器将ASL转换为ACPI机器语言(AML)字节代码。AML是AML解释器处理语言。</p><p><img src="/../image/ACPI_pic/asl-and-aml.png" alt="ASL和AML"></p><p>ASL代码用于定义对象和控制方法，AML编译器将ASL转换为ACPI定义块中包含的AML字节代码，定义块由标识表头和由AML解释器执行的字节码组成。</p><p>AML解释器执行字节码并计算定义块中的对象，以允许字节码执行循环、条件评估、访问定义的地址空间以及执行应用程序所需的其他操作。AML解释器对定义的地址空间具有读&#x2F;写访问权限，包括系统内存、I&#x2F;O、PCI配置等。它通过定义称为对象的入口点来访问这些地址空间。对象可以具有直接定义的值，也可以由AML解释器进行计算和解释。</p><p>此枚举对象的集合是称为ACPI命名空间的OS构造。命名空间是系统上ACPI设备的分层表示形式，系统总线是这些ACPI设备的枚举根。在其他总线上可枚举的设备（如PCI或USB设备）通常不会在命名空间中枚举，相反，他们自己的总线会枚举设备并加载它们的驱动程序。但是，所有可枚举总线都具有一种编码技术，该技术允许ACPI对设备的总线特定地址进行编码，以便可以在ACPI中找到它们。即使ACPI通常不会加载这些设备的驱动程序。</p><p>通常，枚举具有<code>_HID</code>对象（硬件标识对象）的设备，并由ACPI加载其驱动程序。具有<code>_ADR</code>对象（物理地址对象）的设备通常不会由ACPI枚举，并且通常不会由ACPI加载其驱动程序。<code>_ADR</code>设备通常可以不涉及ACPI的情况下执行所有必要的功能，但在设备驱动程序无法执行功能的情况下，或者驱动程序需要与系统固件通信时，ACPI可以评估对象以执行所需的功能。</p><p>例如，PCI不支持本机热插拔。但是，PCI可以使用ACPI来评估对象并定义允许ACPI填充在PCI上执行热插拔所需的函数的方法。</p><p>ACPI的另一个方面是运行时模型，用于处理系统操作期间发生的任何ACPI中断事件。ACPI会根据需要继续评估对象以处理这些事件。这种基于中断的运行时模型将在下面的运行时模型部分中更详细地讨论。</p><h2 id="ACPI初始化"><a href="#ACPI初始化" class="headerlink" title="ACPI初始化"></a>ACPI初始化</h2><p>了解ACPI工作原理的最佳方式是按时间顺序排列。用户启动系统的那一刻，系统固件将完成其设置、初始化和自检。</p><p>然后，系统固件使用在固件初始化期间获得的信息，根据需要使用各种平台配置和电源接口数据更新ACPI表，然后再将控制权传递给引导加载程序。扩展根系统说明表（XSDT）是ACPI子系统使用的第一个表，包含系统上大多数其他ACPI表的地址。XSDT指向固定的ACPI说明表（FADT）以及OS在初始化期间处理的其他主要表。OS初始化后，FADT将ACPI子系统定向到差分系统说明表（DSDT），该表是命名空间的开头，因为它是第一个包含定义块的表。</p><p>然后，ACPI子系统处理DSDT，并开始从ACPI定义块生成命名空间。XSDT还指向辅助系统说明表（SSDT）并将其添加到命名空间。ACPI数据表提供有关系统硬件的OS原始数据。</p><p>OS从ACPI表生成命名空间后，它将开始遍历命名空间，并为命名空间中遇到的所有_HID设备加载设备驱动程序。</p><p><img src="/../image/ACPI_pic/ACPI%E5%88%9D%E5%A7%8B%E5%8C%96.png" alt="ACPI初始化"></p><p>在上面的ACPI初始化图中，系统固件会根据需要更新ACPI表，其中包含仅在运行时可用的信息，然后再将控制权移交给引导加载程序。XSDT是操作系统的ACPI子系统使用的第一个表，包含系统上大多数其他ACPI表的地址。XSDT指向FADT、SSDT和其他主要ACPI表。FADT将ACPI子系统定向到DSDT，DSDT是命名空间的开头，因为DSDT是第一个包含定义块的表。然后，ACPI子系统使用DSDT，并开始从定义块生成ACPI命名空间。XSDT还指向SSDT并将它们添加到命名空间中。</p><h2 id="运行时模型"><a href="#运行时模型" class="headerlink" title="运行时模型"></a>运行时模型</h2><p>系统启动并运行后，ACPI将与OS配合使用，以处理通过中断发生的任何ACPI事件。此中断以以下两种常规方式之一调用ACPI事件：固定事件（Fixed Events）和通用事件（GPE：General Purpose Events）。</p><p>固定事件是在ACPI规范中具有预定义含义的ACPI事件。这些固定事件包括按下电源按钮或ACPI计时器溢出等操作。这些事件由操作系统处理程序直接处理。</p><p>GPE是ACPI规范未预定义的ACPI事件。这些事件通常通过评估控制方法来处理，这些控制方法是命名空间中的对象，可以访问系统硬件。当ACPI子系统使用AML解释器评估控制方法时，GPE对象会根据OS的实现处理事件。通常，这可能涉及向设备发出通知，以调用设备驱动程序来执行功能。</p><h2 id="主要功能与接口"><a href="#主要功能与接口" class="headerlink" title="主要功能与接口"></a>主要功能与接口</h2><p><strong>系统电源管理</strong></p><p>System power management，系统电源管理，ACPI定义了使计算机作为一个整体进入和退出系统休眠状态的机制。它还为任何设备提供了唤醒计算机的通用机制。</p><p><strong>设备电源管理</strong></p><p>Device power management，设备电源管理ACPI表描述主板设备，它们的电源状态，设备连接的电源平面，以及将设备置于不同电源状态的控制。这使得操作系统能够根据应用的使用情况将设备设置为低功耗状态。</p><p><strong>处理器电源管理</strong></p><p>Processor power management，处理器电源管理，当操作系统处于空闲状态而不是休眠状态时，它将使用ACPI描述的命令将处理器置于低功耗状态。</p><p><strong>设备和处理器性能管理</strong></p><p>Device and processor performance management，设备和处理器性能管理，当系统处于活动状态时，OSPM将设备和处理器转换为ACPI定义的不同性能状态，以实现性能和节能目标以及其他环境要求(例如，能见度和声学)之间的理想平衡。</p><p><strong>配置&#x2F;即插即用</strong></p><p>Configuration&#x2F;Plug and Play，配置&#x2F;即插即用，ACPI指定用于枚举和配置主板设备的信息。这些信息是分层排列的，因此当发生插拔之类的事件时，操作系统可以识别哪些设备受到该事件的影响。</p><p><strong>系统事件</strong></p><p>System Event，系统事件，ACPI提供了一种通用事件机制，可用于热事件、电源管理事件、设备插入和移除等系统事件。</p><p><strong>电池管理</strong></p><p>Battery management，电池管理，电池管理策略从BIOS转移到操作系统。</p><p><strong>热管理&#x2F;温度管理</strong></p><p>Thermal management，热管理&#x2F;温度管理，由于操作系统控制设备和处理器的电源和性能状态，ACPI还解决了系统的热管理问题。它提供了一个简单的、可扩展的模型，允许OEM定义热区域、热指标和冷却热区域的方法。</p><p>OSPM使用三种冷却策略来控制硬件的散热状态，包括主动策略、被动策略和关键策略。</p><ol><li><p>主动冷却</p><p> OSPM采取直接操作，例如打开一个或多个风扇。应用主动冷却控制通常会消耗功率并产生一定数量的噪音，但能够在不限制系统性能的情况下冷却热区。主动冷却温度跳变点声明OSPM用于决定何时启动或停止不同主动冷却设备的温度阈值。</p></li><li><p>被动冷却</p><p> OSPM可降低设备的功耗，以降低热区域的温度，例如减慢（节流）处理器时钟。应用被动冷却控制通常不会产生用户注意到的噪音。被动冷却温度跳变点指定OSPM将启动或停止被动冷却的温度阈值。</p></li><li><p>关键跳变点</p><p> 这些是OSPM对设备或整个系统执行有序但关键的关机的阈值温度。_HOT对象声明OSPM可以选择将系统转换为S4休眠状态的临界温度（如果支持），_CRT对象声明OSPM必须执行临界关闭的临界温度。</p></li></ol><p><strong>嵌入式控制器</strong></p><p>Embedded Controller，嵌入式控制器。ACPI定义了OS总线和嵌入式控制器之间的标准硬件软件通信接口。这使得OS驱动程序能够与控制器通信进而使用这些资源。</p><p>ACPI标准支持系统中的多个嵌入式控制器，每个控制器都有自己的资源。每个嵌入式控制器都有一个扁平字节可寻址的I&#x2F;O空间，目前定义为256字节。在嵌入式控制器中实现的功能具有事件“查询”机制，该机制允许嵌入式控制器实现的功能硬件引起操作系统驱动程序或ASL&#x2F;AML代码处理程序的注意。</p><p>嵌入式控制器指定了两个接口：</p><ol><li><p>专用接口</p><p> 专用接口由嵌入式控制器驱动程序独占。</p></li><li><p>共享接口 </p><p> 共享接口由嵌入式控制器驱动程序和某些其他驱动程序使用。</p></li></ol><p><strong>SMBus控制器</strong></p><p>SMBus Controller，SMBus控制器，ACPI定义了操作系统总线驱动程序与SMBus Controller之间的标准软硬件通信接口。这允许任何操作系统提供一个标准的总线驱动程序，它可以直接与系统中的SMBus设备通信。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ACPI可以最好地描述为概念和接口的框架，这些概念和接口实现是为了在主机操作系统中形成一个子系统。ACPI表、处理程序、解释器、命名空间、事件和中断模型共同构成了ACPI的此实现，从而在主机操作系统中创建ACPI子系统。从这个意义上说，ACPI是系统硬件&#x2F;固件与操作系统和操作系统应用程序之间的接口，用于配置和电源管理。这为各种操作系统提供了一种标准化的方式来支持通过ACPI命名空间进行电源管理和配置。</p><p>ACPI命名空间是系统上所有ACPI设备的可枚举分层表示形式，用于查找和加载系统上ACPI设备的驱动程序。命名空间可以通过实时评估对象和发送中断来动态，而无需操作系统调用本机系统固件代码。这使设备制造商能够将自己的指令和事件编码到设备中。它还通过实现标准化的电源管理接口来减少不兼容性和不稳定性。</p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li>ACPI(Advanced Configuration and Power Interface):高级配置和电源接口</li><li>ACPI Hardware：ACPI硬件</li><li>ACPI Namespace ACPI命名空间</li><li>AML(ACPI Machine Language)：ACPI机器语言</li><li>ASL(ACPI Source Language)：ACPI源语言</li><li>GPEs(General Purpose Events)：通用事件</li><li>BIOS(Basic Input&#x2F;Output System)：基本输入&#x2F;输出系统</li><li>Boot Firmware：启动固件</li><li>Device Firmware：设备固件</li><li>DSDT(Differentiated System Description Table)：差分系统描述表</li><li>FACS(Firmware ACPI Control Structure)：固件ACPI控制结构</li><li>FADT(Fixed ACPI Description Table)：固定的ACPI描述表</li><li>MADT(Multiple APIC Description Table)：多个APIC描述表</li><li>RSDP(Root System Description Pointer)：根系统描述指针</li><li>RSDT(Root System Description Table)：根系统描述表</li><li>SSDT(Secondary System Description Table)：辅助系统描述表</li><li>XSDT(Extended Root System Description Table)：扩展根系统描述表</li><li>Embedded Controller 嵌入式控制器</li><li>Embedded Controller Interface：嵌入式控制器接口</li><li>Expansion ROM Firmware：扩展ROM固件</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/05_ACPI_Software_Programming_Model/ACPI_Software_Programming_Model.html">ACPI规范</a></p><p><a href="https://zhuanlan.zhihu.com/p/661747624">RISC-V ACPI介绍与实现指导</a></p><p><a href="https://github.com/riscv-non-isa/riscv-brs/">riscv-brs</a></p><p><a href="http://www.tup.tsinghua.edu.cn/upload/books/yz/064076-01.pdf">ACPI简述</a></p>]]></content>
    
    
    <categories>
      
      <category>ACPI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编与反汇编</title>
    <link href="/2023/09/18/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    <url>/2023/09/18/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96/</url>
    
    <content type="html"><![CDATA[<h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1 环境搭建"></a>1 环境搭建</h2><h3 id="1-1-objdump-安装"><a href="#1-1-objdump-安装" class="headerlink" title="1.1 objdump 安装"></a>1.1 objdump 安装</h3><ul><li><strong>objdump</strong> 是 <strong>binutils</strong> 下的工具，需要下载 <strong>binutils</strong> 包。<ul><li>下载<a href="http://ftp.gnu.org/gnu/binutils/">地址</a></li></ul></li></ul><p><img src="/../image/Assembly_pic/binutils%E4%B8%8B%E8%BD%BD%E7%89%88%E6%9C%AC.png"></p><ul><li>进入解压后文件所在的那个目录下，执行下列命令</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">$./configure<br>$make<br>$sudo make install<br></code></pre></td></tr></table></figure><h3 id="1-2-架构环境安装"><a href="#1-2-架构环境安装" class="headerlink" title="1.2 架构环境安装"></a>1.2 架构环境安装</h3><p><strong>bootrom &gt;&gt; toolchain &gt;&gt; bin</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 架构安装 */</span><br>$sudo apt install binutils-riscv64-unknown-elf<br>  <br><span class="hljs-comment">/* 生成反汇编文件 */</span><br>$riscv64-unknown-elf-objdump -d btr.elf &gt; test<br></code></pre></td></tr></table></figure><h2 id="2-汇编和反汇编"><a href="#2-汇编和反汇编" class="headerlink" title="2 汇编和反汇编"></a>2 汇编和反汇编</h2><h3 id="2-1-区别"><a href="#2-1-区别" class="headerlink" title="2.1 区别"></a>2.1 区别</h3><ul><li>C 程序变成可执行程序的过程。</li></ul><p><img src="/../image/Assembly_pic/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E8%BF%87%E7%A8%8B.png"></p><h3 id="2-2-汇编"><a href="#2-2-汇编" class="headerlink" title="2.2 汇编"></a>2.2 汇编</h3><ul><li>动词，指的是把 <strong>汇编语言</strong> 翻译成 <strong>机器语言</strong> 的过程。</li><li>名词，指的便是汇编语言。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 操作：寄存器BX的内容送到AX中</span><br><span class="hljs-number">1000100111011000</span>              机器指令<br>mov ax,bx                     汇编指令<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 以test.c为例 */</span><br>$gcc -O -S test.c<span class="hljs-comment">/* 生成test.s文件 */</span><br>$gcc -O -S test.c  vim test.c<span class="hljs-comment">/* 使用 vim 编辑器打开 .s 文件 */</span><br></code></pre></td></tr></table></figure><h3 id="2-3-反汇编"><a href="#2-3-反汇编" class="headerlink" title="2.3 反汇编"></a>2.3 反汇编</h3><ul><li>动词，指的是由已生成的 <strong>机器语言（二进制语言）</strong> 转化为 <strong>汇编语言</strong> 的过程，也可以说是汇编的逆向过程。</li><li>名词，指的是由 <strong>机器语言</strong> 经过 <strong>反汇编过程</strong> 生成的 <strong>汇编语言</strong>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 生成反汇编文件 */</span><br>$objdump -d test.o<br></code></pre></td></tr></table></figure><h2 id="3-汇编语言书写规则"><a href="#3-汇编语言书写规则" class="headerlink" title="3 汇编语言书写规则"></a>3 汇编语言书写规则</h2><ul><li><strong>8086</strong> 采用 <strong>intel</strong> 汇编，<strong>i386</strong> 采用 <strong>AT&amp;T</strong> 汇编，二者有显著不同，不要搞混。</li></ul><h3 id="3-1-大小写"><a href="#3-1-大小写" class="headerlink" title="3.1 大小写"></a>3.1 大小写</h3><ul><li><strong>INTEL</strong> 格式的指令使用大写字母，而 <strong>AT&amp;T</strong> 格式的使用小写字母。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* INTEL */</span><br>MOV EAX,EBX<br><br><span class="hljs-comment">/* AT&amp;T */</span><br>movl %ebx,%eax<br></code></pre></td></tr></table></figure><h3 id="3-2-操作数赋值方向"><a href="#3-2-操作数赋值方向" class="headerlink" title="3.2 操作数赋值方向"></a>3.2 操作数赋值方向</h3><ul><li><p>在 <strong>INTEL</strong> 语法中，第一个表示目的操作数，第二个表示源操作数，赋值方向从右向左。</p></li><li><p><strong>AT&amp;T</strong> 语法第一个为源操作数，第二个为目的操作数，方向从左到右，合乎自然。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* INTEL */</span><br>MOV EAX,EBX<br>    <br><span class="hljs-comment">/* AT&amp;T */</span><br>movl %ebx,%eax<br></code></pre></td></tr></table></figure><h3 id="3-3-前缀"><a href="#3-3-前缀" class="headerlink" title="3.3 前缀"></a>3.3 前缀</h3><ul><li><p><strong>INTEL</strong> 中寄存器和立即数不需要前缀</p></li><li><p><strong>AT&amp;T</strong> 中寄存器需要加前缀 <strong>%<strong>，</strong>立即数</strong> 需要加前缀 <strong>$</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* INTEL */</span><br>MOV EAX,<span class="hljs-number">1</span><br><br><span class="hljs-comment">/* AT&amp;T */</span><br>movl $<span class="hljs-number">1</span>,%eax<br></code></pre></td></tr></table></figure><ul><li>符号常数直接引用，不需要加前缀；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">movl value,%ebx    <span class="hljs-comment">/* value为常数 */</span>；<br></code></pre></td></tr></table></figure><ul><li>在符号前加前缀 <strong>$</strong> 表示引用符号地址；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">movl $value        <span class="hljs-comment">/* %ebx，是将 value 的地址放到 ebx 中 */</span><br></code></pre></td></tr></table></figure><ul><li>总线锁定前缀 <strong>lock</strong>：总线锁定操作</li><li><strong>“lock”</strong> 前缀在 <strong>Linux</strong> 核心代码中使用很多，特别是 <strong>SMP</strong> 代码中。当总线锁定后其它 <strong>CPU</strong> 不能存取锁定地址处的内存单元</li><li>远程跳转指令和子过程调用指令的操作码使用前缀 <strong>l</strong>，分别为 <strong>ljmp</strong>，<strong>lcall</strong>，与之相应的返回指令伪 <strong>lret</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* INTEL */</span><br> CALL FARSECTION:OFFSET<br> JMP FARSECTION:OFFSET<br> RET FARSATCK_ADJUST<br><br><span class="hljs-comment">/* AT&amp;T */</span><br> call secion:secion:secion:offset<br> jmp secion:secion:secion:offset<br> ret $stack_adjust<br></code></pre></td></tr></table></figure><h3 id="3-4-间接寻址语法"><a href="#3-4-间接寻址语法" class="headerlink" title="3.4 间接寻址语法"></a>3.4 间接寻址语法</h3><ul><li><strong>INTEL</strong> 中基地址使用 **[<strong>、</strong>]**，而在 <strong>AT&amp;T</strong> 中使用 **(<strong>、</strong>)**，另外处理复杂操作数的语法也不同</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* INTEL */</span> <br>Segreg:[base+indexscale+disp]，<br><br><span class="hljs-comment">/* AT&amp;T */</span>  <br>%segreg:disp(base,index,sale)，<br><br><span class="hljs-comment">/* 其中 segreg，index，scale，disp 都是可选的，在指定 index 而没有显式指定 Scale 的情况下使用默认值 1 */</span><br></code></pre></td></tr></table></figure><ul><li><strong>Scale</strong> 和 <strong>disp</strong> 不需要加前缀 <strong>“&amp;”</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* INTEL */</span><br>Instr<br>foo,segreg:[base+index*scale+disp]<br><br><span class="hljs-comment">/* AT&amp;T */</span><br>instr<br>%segreg:disp(base,index,scale),foo<br></code></pre></td></tr></table></figure><h3 id="3-5-后缀"><a href="#3-5-后缀" class="headerlink" title="3.5 后缀"></a>3.5 后缀</h3><ul><li><p><strong>AT&amp;T</strong> 语法中大部分指令操作码的最后一个字母表示操作数大小</p><ul><li><strong>b</strong> 表示 <strong>byte</strong>（一个字节）、<strong>w</strong> 表示 <strong>word</strong>（2个字节）、<strong>l</strong> 表示 <strong>long</strong>（4个字节）</li></ul></li><li><p><strong>INTEL</strong>中处理内存操作数时也有类似的语法</p><ul><li><strong>BYTE PTR</strong>、<strong>WORD PTR</strong>、<strong>DWORDPTR</strong></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* INTEL */</span><br>mov al,bl<br>movax,bx<br>mov eax,dword ptr [ebx]<br><br><span class="hljs-comment">/* AT&amp;T */</span><br>    movb %bl,%al<br>    movw %bx,%ax<br>    <span class="hljs-title function_">movl</span> <span class="hljs-params">(%ebx)</span>, %eax<br></code></pre></td></tr></table></figure><ul><li>在 <strong>AT&amp;T</strong> 汇编指令中，操作数扩展指令有两个后缀，一个指定源操作数的字长，另一个指定目标操作数的字长</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* INTEL */</span><br>movsx<span class="hljs-comment">/* 符号扩展指令 */</span><br>movzx<span class="hljs-comment">/*  零扩展指令 */</span><br><br><span class="hljs-comment">/* AT&amp;T */</span><br>movs<span class="hljs-comment">/* 符号扩展指令 */</span><br>movz<span class="hljs-comment">/* 零扩展指令 */</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">movsbl %al,%edx   <span class="hljs-comment">/* 表示对寄存器 al 中的字节数据进行字节到长字的符号扩展，计算结果存放在寄存器 edx 中 */</span><br></code></pre></td></tr></table></figure><ul><li>下面是一些允许的操作数扩展后缀</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">bl<span class="hljs-comment">/* 字节-&gt;长字 */</span><br>bw<span class="hljs-comment">/* 字节-&gt;字 */</span><br>wl<span class="hljs-comment">/* 字-&gt;长字 */</span><br></code></pre></td></tr></table></figure><ul><li>跳转指令标号后的后缀表示跳转方向，**”f”** 表示向前（<strong>forward</strong>），**’’b’’** 表示向后（<strong>back</strong>）。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">jmp1f  <span class="hljs-comment">/* 向前跳转 1 字节 */</span><br></code></pre></td></tr></table></figure><h2 id="4-常见汇编命令"><a href="#4-常见汇编命令" class="headerlink" title="4 常见汇编命令"></a>4 常见汇编命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">mov  : 将源操作数复制到目的操作数(move)<br>cmpl : 比较两个操作数大小(compare)，它有两个操作数，比如 cmp S2，S1，最终会基于 S1-S2 的值去设置条件码寄存器的值。而对于 test 来说是类似的，对于 test S2，S1 来说，它将基于 S1&amp;S2 去设置条件码寄存器的值。另外需要一提的是，两者都需要加数据格式后缀，比如 b、w、l 这些后缀。<br><br>/*<br> * CF：进位标志寄存器，它记录无符号操作的溢出，当溢出时会被设为1。<br> * ZF：零标志寄存器，当计算结果为0时将会被设为1。<br> * SF：符号标志寄存器，当计算结果为负数时会被设为1。<br> * OF：溢出标志寄存器，当计算结果导致了补码溢出时，会被设为1。<br> * ZF 和 SF 可以判断结果的符号，而CF和OF可以判断无符号和补码的溢出<br>**/<br><br>jmp  : 无条件跳转指令(jump)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Assembly</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Uart通信协议</title>
    <link href="/2023/09/06/Uart%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/09/06/Uart%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通信协议在组织设备之间的通信时扮演着重要角色，基于系统要求而以不同方式进行设计。此类协议具有特定的规则，为实现成功通信，不同设备都遵循该规则。Uart(Universel asynchous receiver&#x2F;transmitter)：通用异步接收器&#x2F;发送器，是最常用的设备间通信协议之一。在嵌入式系统、微控制器和计算机大多将 Uart 作为设备间硬件通信协议的一种形式。在可用通信协议中，Uart 的发送和接收端仅使用两条线。尽管 Uart 是一种广泛使用的硬件通信方法，但它并非在所有时候都是完全优化的，如在微控制器内部使用 Uart 模块时，通常会忽略帧协议的适当实现。</p><p>根据定义，Uart 是一种硬件通信协议，以可配置的速度使用异步串行通信。异步意味着没有时钟信号来同步从发送设备进入接收端的输出位。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><img src="/../image/Uart_pic/Uart%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3.svg" alt="图1 两个Uart彼此直接通信"></p><p>每个 Uart 设备的两个信号分别命名为：</p><ul><li>发送器（Tx）;</li><li>接收器（Rx）;</li></ul><p>每个设备的发送器和接收器的主要作用是用于串行通信的串行数据的发送和接收。</p><p><img src="/../image/Uart_pic/%E5%B8%A6%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BA%BF%E7%9A%84UART.svg" alt="图2 带数据总线的UART"></p><p>发送到 Uart 数据会先以并行形式发送到控制数据总线上，然后数据将在传输导线上一位一位的串行传输到接收 Uart 上，反过来，对于接收设备，串行数据会被转换为并行数据。</p><p>Uart 设备具有专门用于发送或接收的发送和接收引脚。Uart 线用作发送和接收数据的通信介质。</p><p>对于 Uart 和大多数串行通信，发送和接收设备需要将波特率设置为相同的值。波特率是指信息传输到信道的速率。对于串行端口，设定的波特率将用作每秒传输的最大位数。</p><table><thead><tr><th align="center">特征</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">波特率</td><td align="center">9600、19200、38400、57600、115200、230400、460800、921600、1000000、1500000</td></tr><tr><td align="center">传输方法</td><td align="center">异步</td></tr><tr><td align="center">最大主机数</td><td align="center">1</td></tr><tr><td align="center">最大从机数</td><td align="center">1</td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><p>Uart 接口不使用时钟信号来同步接收和发送设备，而是以异步方式传输数据。发送器根据其时钟信号生成的位流取代了时钟信号，接收器使用其内部时钟信号对输入数据进行采样。同步点是通过两个设备的相同波特率来管理。如果波特率不同，发送和接收数据的时序可能会受影响，导致数据处理过程出现不一致。允许的波特率差异最大值为10%，超过此值，位的时序就会脱节。</p><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>在 Uart 中，传输模式为数据包形式。连接发送器和接收器的机制包括串行数据包的创建和物理硬件线路的控制。数据包由起始位、数据帧、奇偶校验位和停止位组成。</p><p><img src="/../image/Uart_pic/UART%E6%95%B0%E6%8D%AE%E5%8C%85.svg" alt="图3 UART数据包"></p><p><strong>起始位</strong></p><p>当数据未传输时，Uart 数据总线通常保持高电平。若要开始数据传输，发送 Uart 会将数据总线从高电平拉到低电平并保持一个时钟周期。当接收 Uart 检测到由高到低电压跃迁时，便开始以波特率对应的频率读取数据帧中的位。</p><p><img src="/../image/Uart_pic/%E8%B5%B7%E5%A7%8B%E4%BD%8D.jpg" alt="图4 起始位"></p><p><strong>数据帧</strong></p><p>数据帧包含传输的实际数据。如果使用奇偶校验位，数据帧长度可以是5位到8位。如果不使用奇偶校验位，数据帧长度可以是9位。在大多数情况下，数据以最低有效位优先方式发送。</p><p><img src="/../image/Uart_pic/%E6%95%B0%E6%8D%AE%E5%B8%A7.jpg" alt="图5 数据帧"></p><p><strong>奇偶校验位</strong></p><p>奇偶性描述数字是偶数还是奇数。通过奇偶校验位，接收 Uart 判断传输期间是否有数据发生改变。电磁辐射、不一致的波特率或长距离数据传输都有可能改变数据位。</p><p>接收 Uart 读取数据帧后，将计数值为1的位，检查总数是偶数还是奇数。如果奇偶校验位为0（偶数奇偶校验），则数据帧中1或逻辑高位应为偶数。如果奇偶校验位为1（奇数奇偶校验），则数据帧中1或逻辑高位应为奇数。</p><p>当奇偶检验位与数据匹配时，Uart 认为传输未出错。但是，若奇偶校验位为0，而总和为奇数，或者奇偶校验位为1，而总和为偶数，则 Uart 认为数据帧中的位已改变。</p><p><img src="/../image/Uart_pic/%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E4%BD%8D.jpg" alt="图6 奇偶校验位"></p><p><strong>停止位</strong></p><p>为了表示数据包传输结束，发送 Uart 将数据总线从低电压拉到高电压并保持1到2位时间。</p><p><img src="/../image/Uart_pic/%E5%81%9C%E6%AD%A2%E4%BD%8D.jpg" alt="图7 停止位"></p><h2 id="Uart-传输步骤"><a href="#Uart-传输步骤" class="headerlink" title="Uart 传输步骤"></a>Uart 传输步骤</h2><p>第一步：发送 Uart 从数据总线并行接收数据。</p><p><img src="/../image/Uart_pic/%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BA%BF%E8%87%B3%E5%8F%91%E9%80%81UART.svg" alt="图8 数据总线至发送UART"></p><p>第二步：发送 Uart 将起始位、奇偶校验位和停止位添加到数据帧。</p><p><img src="/../image/Uart_pic/Tx%E4%BE%A7%E7%9A%84UART%E6%95%B0%E6%8D%AE%E5%B8%A7.svg" alt="图9 Tx侧的UART数据帧"></p><p>第三步：从起始位到结束位，整个数据包以串行方式从发送 Uart 送至接收 Uart，接收 Uart 以预配置的波特率对数据进行采样。</p><p><img src="/../image/Uart_pic/UART%E4%BC%A0%E8%BE%93.svg" alt="图10 UART传输"></p><p>第四步：接收 Uart 丢弃数据帧中的起始位、奇偶校验位和停止位。</p><p><img src="/../image/Uart_pic/Rx%E4%BE%A7%E7%9A%84UART%E6%95%B0%E6%8D%AE%E5%B8%A7.svg" alt="图11 Rx侧的UART数据帧"></p><p>第五步：接收 Uart 将串行数据转换回并行数据，并将其传输到接收端的数据总线。</p><p><img src="/../image/Uart_pic/%E6%8E%A5%E6%94%B6UART%E8%87%B3%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BA%BF.svg" alt="图12 接收UART至数据总线"></p>]]></content>
    
    
    <categories>
      
      <category>Uart</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈的拓展方向</title>
    <link href="/2023/08/29/%E6%A0%88%E7%9A%84%E6%8B%93%E5%B1%95%E6%96%B9%E5%90%91/"/>
    <url>/2023/08/29/%E6%A0%88%E7%9A%84%E6%8B%93%E5%B1%95%E6%96%B9%E5%90%91/</url>
    
    <content type="html"><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>计算机内存分了代码段（<code>.text</code>段）、初始化的数据段（<code>.data</code>段）、未初始化的数据段（<code>.bss</code>段）、堆空间（<code>heap</code>）、栈空间（<code>stack</code>）和命令行参数和环境变量区域。</p><p>​程序计数器（Program Counter，简称 PC ）的缺省指向0地址，计算机开机后从程序计数器指向的地址开始执行程序，每执行完一条指令后， 程序计数器自动加1。因此很自然的，代码段从低地址区间开始加载，向高地址区间扩展。</p><p>​heap 从低地址向高地址扩展，做内存管理相对要简单些，为了避免栈空间和代码段冲突，最大利用地址空间，很自然的，我们会选择把栈底设置在高地址区间，然后让栈向下增长。</p><p>这是来自 apue 里一张经典的 C 程序内存分布图，着重看一下 heap 和 stack 的内存分布。</p><p><img src="/../image/heap-stack.png" alt="图1"></p><h2 id="栈从高地址向低地址拓展的优点"><a href="#栈从高地址向低地址拓展的优点" class="headerlink" title="栈从高地址向低地址拓展的优点"></a>栈从高地址向低地址拓展的优点</h2><p><strong>stack</strong> 从高地址向低地址扩展，这样栈空间的起始位置就能确定下来。动态的调整栈空间大小也不需要移动栈内的数据，如果是从低地址到高地址的扩展，结尾的地址是固定的，如果要扩大或缩小，则需要移动整个栈的数据。</p><p>并且这样设计可以使得堆和栈能够充分利用空闲的地址空间。如果栈向上涨的话，我们就必须得指定栈和堆的一个严格分界线，但这个分界线怎么确定呢？平均分？但是有的程序使用的堆空间比较多，而有的程序使用的栈空间比较多。</p><p>所以就可能出现这种情况：一个程序因为栈溢出而崩溃的时候，其实它还有大量闲置的堆空间呢，但是我们却无法使用这些闲置的堆空间。所以呢，最好的办法就是让堆和栈一个向上涨，一个向下涨，这样它们就可以最大程度地共用这块剩余的地址空间，达到利用率的最大化！</p><h2 id="现在-CPU-指令集的设计"><a href="#现在-CPU-指令集的设计" class="headerlink" title="现在 CPU 指令集的设计"></a>现在 CPU 指令集的设计</h2><p>大部分 CPU 指令集设计了函数调用架构，定义了专用的调用&#x2F;返回指令，并在指令中隐含规定栈的方向。</p><ul><li>主流1：向低地址扩展：<strong>x86</strong>，<strong>MIPS</strong>；</li><li>主流2：自由选择：<strong>Arm</strong>（但个别指令仅支持向低）；</li><li>罕见：向高地址扩展：<strong>PA-RISC</strong>，操作系统<strong>Multics</strong>；</li><li>非主流：<strong>System z</strong>，栈是个链表[2]。</li></ul><p>如果 CPU 同时支持向上和向下，例如 Arm，那么编译器需要指定程序的调用方向，一般还是选择向下。比较罕见的极端的案例是 Multics 操作系统，这是 Unix 的巨无霸前身，设计者刻意选用向高地址扩展，因为该架构有助于防御缓冲区溢出攻击[3]。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>[1] What is the logical explanation for stacks typically growing downward and heaps growing upward?</p><p>[2] 列出了8种架构的栈增长方向 What is the direction of stack growth in most modern systems?</p><p>[3] 罕见的栈增长方向 Why does the stack grow downward?</p><p>[4]<a href="https://www.jianshu.com/p/54ac15839abf">https://www.jianshu.com/p/54ac15839abf</a></p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单工、半双工、全双工</title>
    <link href="/2023/08/28/%E5%8D%95%E5%B7%A5%E3%80%81%E5%8D%8A%E5%8F%8C%E5%B7%A5%E3%80%81%E5%85%A8%E5%8F%8C%E5%B7%A5/"/>
    <url>/2023/08/28/%E5%8D%95%E5%B7%A5%E3%80%81%E5%8D%8A%E5%8F%8C%E5%B7%A5%E3%80%81%E5%85%A8%E5%8F%8C%E5%B7%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>数据通信中，数据在线路上的传送方式可以分为单工通信、半双工通信、全双工通信三种。</p><h2 id="单工通信"><a href="#单工通信" class="headerlink" title="单工通信"></a>单工通信</h2><p>单工通信，是指消息只能单方面传输的工作方式，比如遥控、遥测，就是单工通信方式。</p><p>单工通信信道是单向信道，发送端和接收端的身份都是固定的，发送端只能发送消息，不能接收消息；接收端只能接收消息，不能发送消息，数据信号只能从一端传送到另一端，即信息流是单方向的。</p><h2 id="半双工通信"><a href="#半双工通信" class="headerlink" title="半双工通信"></a>半双工通信</h2><p>半双工通信，是指数据可以沿着两个方向传送，但同一时刻一个信道只允许单方向传送，因此又称为双向交替通信。若想改变传输方向，需由开关进行切换，比如无线对讲机就是一种半双工设备，同一时间内只允许一方讲话。</p><p>半双工方式要求收发双端都有发送装置和接收装置。由于半双工要频繁变换信道方向，因此效率较低，但可以节约传输线路。适用于终端与终端之间的会话式通信，方向转变通常由软件控制的电子开关来控制。</p><h2 id="全双工通信"><a href="#全双工通信" class="headerlink" title="全双工通信"></a>全双工通信</h2><p>全双工通信，是指通信的双方可以同时发送和接收信息的信息交互方式，比如电话、手机等。</p><p>全双工方式在通信系统的每一端都设置发送器和接收器，因此，能控制数据同时在两个方向上传送。全双工方式无需进行方向的切换，因此，没有切换操作所产生的时间延迟，这对那些不能有时间延误的交互式应用（例如远程监测和控制系统）十分有利。这种方式要求通讯双方均有发送器和接收器，同时，需要2根数据线传送数据信号。（可能还需要控制线和状态线，以及地线）。</p><h2 id="UART、SPI、I2C"><a href="#UART、SPI、I2C" class="headerlink" title="UART、SPI、I2C"></a>UART、SPI、I2C</h2><ul><li>UART：全双工、异步通信</li><li>USRT：全双工、同步通信</li><li>SPI：高速、全双工、同步的通信总线</li><li>I2C：半双工的通信总线</li></ul><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li>Half Duplex Communication：半双工通信</li><li>Full Duplex Communication：全双工通信</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/chaofanwei/article/details/13274815">https://blog.csdn.net/chaofanwei/article/details/13274815</a></p><p><a href="https://www.zhihu.com/question/39855658">https://www.zhihu.com/question/39855658</a></p>]]></content>
    
    
    <categories>
      
      <category>数据通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I2C通信协议</title>
    <link href="/2023/08/28/I2C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/08/28/I2C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="I2C简介"><a href="#I2C简介" class="headerlink" title="I2C简介"></a>I2C简介</h2><p>I2C(Inter-Integrated Circuit)，是一种串行通信总线，用于连接微控制器及其外围设备，实现主控制器和从器件间的主从双向通信，是一种<strong>同步半双工</strong>通信(两端时钟频率一致，双向通信，但不能同时进行数据收发)。</p><p>对于硬件设计人员，只需要两个引脚，极少的连接线和面积，就可以实现芯片间的通讯；对于软件开发者，可以使用同一个 I2C 驱动库，来实现不同器件的驱动，大大减少了软件的开发时间。</p><p><img src="/../image/I2C_pic/I2C%E6%80%BB%E7%BA%BF%E4%B8%BE%E4%BE%8B.png"></p><h2 id="I2C原理"><a href="#I2C原理" class="headerlink" title="I2C原理"></a>I2C原理</h2><p>I2C 通信属于串行通信，具有两根串行信号线：数据线（SDA），时钟线（SCL）。主控制器和从设备（一个或多个）都通过两根信号线连接，信号线上的主设备和从设备都可以扮演发送器和接收器的角色。为确保传输过程的指向准确性，每个接到I2C总线上的设备都有唯一的地址（从器件专用地址码：可分为 7 位寻址和 10 位寻址），可实现指定从机的定向传输与群发传输。</p><p><img src="/../image/I2C_pic/I2C%E6%80%BB%E7%BA%BF%E7%89%A9%E6%8B%93%E6%89%91%E5%9B%BE.png"></p><p>主设备与从设备：</p><ul><li>通信由主设备发起和主导（调度总线），从设备按照 I2C 时序协议被动的接受主设备的通信；</li><li>主从设备由通信双方来决定（I2C 协议并无规定）；</li><li>同一时刻，只能有一个从设备和主设备通信，其它从设备处于“冬眠”状态。</li></ul><h3 id="信号类型"><a href="#信号类型" class="headerlink" title="信号类型"></a>信号类型</h3><p>为确保传输稳定，所有连接在同一 I2C 总线上的设备共用一个时钟。I2C 总线在传送数据过程中共有以下几种类型信号：</p><p>（1）开始信号&#x2F;结束信号</p><ul><li>SCL 为高电平时，SDA 由高电平向低电平跳变，开始传送数据；</li><li>SCL 为高电平时，SDA 由低电平向高电平跳变，结束传送数据；</li></ul><p><img src="/../image/I2C_pic/%E5%BC%80%E5%A7%8B%E5%92%8C%E7%BB%93%E6%9D%9F%E4%BF%A1%E5%8F%B7.png"></p><p>（2）应答信号&#x2F;非应答信号</p><ul><li>I2C 总线协议规定，每传送一个字节数据后（8bit），都要有一个应答信号以确认数据传送是否被对方收到。即一个字节传输的 8 个时钟过后的第 9 个时钟期间，接收器必须回复 ACK 应答信号给发送器，这样才能完成数据传输；</li><li>应答信号由接收设备产生，在 SCL 为高电平期间，接收设备将 SDA 拉低为低电平，表示数据传输正确，产生应答（ACK），SDA 拉高则表示数据传输失败，产生非应答位（NACK）；</li></ul><blockquote><p>中断模式与非中断模式：两种模式工作时序相同，非中断模式通过检测 ACK 信号来判断从设备响应，中断模式则根据中断信号来判断响应（<a href="https://www.runoob.com/w3cnote/verilog2-fifo.html">FIFO状态</a>）。</p></blockquote><p>（3）闲置状态&#x2F;被占用状态</p><ul><li>在主机发送起始信号后，且未发送终止信号期间，总线处于被占用状态；</li><li>发送终止信号后，总线处于闲置状态，SCL 和 SDA 同时为高电平；</li></ul><h3 id="总线读写流程"><a href="#总线读写流程" class="headerlink" title="总线读写流程"></a>总线读写流程</h3><p>I2C 总线进行数据传送时，SCL 时钟信号为高电平期间，SDA 数据线上数据必须保持稳定，只要在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。当一个字节按数据位从高位到低位的顺序传输完后，紧接着从机将拉低 SDA 线，回传给主设备一个应答位 ACK，此时才认为一个字节真正的被传输完成，如果一段时间内没有收到从机的应答信号，则自动认为从机已正确接收到数据。</p><p><img src="/../image/I2C_pic/%E5%AE%8C%E6%95%B4%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png"></p><h4 id="I2C-总线写通信过程"><a href="#I2C-总线写通信过程" class="headerlink" title="I2C 总线写通信过程"></a>I2C 总线写通信过程</h4><p>（1）主机在检测到总线空闲的情况下，首先发送一个 START 信号掌管总线；</p><p>（2）发送一个地址字节（8bit），其中 bit0~6 位为从机地址（7位寻址方式），存放从机的唯一地址；bit7 位为读&#x2F;写位(R&#x2F;W)，0 表示 Write，主机-&gt;从机，1表示 Read，从机-&gt;主机；</p><p>（3）主机发送地址时，总线上每个从机都会将 7 位地址与自己的地址进行比较，若相同，则将匹配成功，发送应答信号（ACK），确认发送器和接收器；</p><p>（4）主机收到 ACK 后开始发送第一个字节（Command），对应从机中要写入的寄存器；</p><p>（5）从机接收 Command 后，从机发送 ACK；</p><p>（6）主机收到 ACK 后开始发送第一个数据字节：bit0~7（数据由高到低），从机接收数据后，发送应答 ACK；</p><p>（7）继续发送数据，n 帧；</p><p>（8）主控制器发送完全部数据后，发送一个停止位 STOP，结束整个通讯并且释放总线。</p><p><img src="/../image/I2C_pic/%E5%86%99%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BA%BF%E8%BF%87%E7%A8%8B.png"></p><blockquote><p>10 位寻址方式：I2C 总线 10bit 寻址和 7bit 寻址是兼容的，可以在同一总线上同时使用 7bit 和 10bit 地址模式的设备，在进行 10bit 地址传输时，第一字节是一个特殊的保留地址来指示当前传输的是 10bit 地址。</p></blockquote><h4 id="I2C-总线读通信过程"><a href="#I2C-总线读通信过程" class="headerlink" title="I2C 总线读通信过程"></a>I2C 总线读通信过程</h4><p>（1）主机产生 START 信号，随后发送从机地址（7bit）+0（Write）；</p><blockquote><p>方向仍然是写，待接收到从机发送的 ACK 应答后，配对成功。 </p></blockquote><p>（2）主机接收到 ACK 后，发送 8bit 内存地址（Command 对应的从机寄存器地址），从机接收到后，内部寻址并提取数据，返回 ACK；</p><p>（3）主机接收到 ACK 后，重新产生 START 信号，再一次发送从机内存地址（7bit）+1（Read），从机接收到后返回 ACK；</p><blockquote><p>方向设置为读，主机设置为接收模式。</p></blockquote><p>（4）主机接收到 ACK 后，做好接收从机信息的准备，现在即可接收 1bit 的数据。</p><blockquote><p>主机不向从机发送应答信号，接收完毕后直接发起终止信号。</p></blockquote><p>（5）主机接收全部数据后，产生 STOP 信号，终止通信，总线变为空闲状态。</p><p><img src="/../image/I2C_pic/%E8%AF%BB%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BA%BF%E8%BF%87%E7%A8%8B.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.nxp.com.cn/docs/en/user-guide/UM10204.pdf">I2C官方文档下载</a></p><p><a href="https://zhuanlan.zhihu.com/p/362287272">https://zhuanlan.zhihu.com/p/362287272</a></p>]]></content>
    
    
    <categories>
      
      <category>I2C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言内存</title>
    <link href="/2023/08/23/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98/"/>
    <url>/2023/08/23/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言内存"><a href="#C语言内存" class="headerlink" title="C语言内存"></a>C语言内存</h1><ul><li><p><strong>C</strong> 语言中使用的地址为什么是假的，计算机又是如何通过假的地址访问到真实的物理内存的？</p></li><li><p>一个 <strong>C</strong> 语言程序在内存中是如何分布的？函数放在哪里？变量放在哪里？字符串放在哪里？</p></li><li><p>为什么全局变量在整个程序中都可以使用，而局部变量只能在函数内部使用？</p></li><li><p>一个 <strong>C</strong> 语言程序可以使用多大的内存？</p></li><li><p>操作系统和用户程序之间是如何协作的？</p></li><li><p>堆和栈都是什么？它们在程序运行过程中起到什么作用？为什么栈内存的分配效率要高于堆？</p></li><li><p>栈溢出是怎么回事，如何利用栈溢出进行攻击？</p></li><li><p>内存泄漏、野指针、非法内存访问、段错误都是怎么产生的？</p></li><li><p>内存池、线程池、连接池等这些莫名其妙的“池子”是怎么回事？</p></li></ul><p>程序是保存在硬盘中的，要载入内存才能运行，<strong>CPU</strong> 也被设计为只能从内存中读取数据和指令。</p><h2 id="1-程序在内存运行"><a href="#1-程序在内存运行" class="headerlink" title="1 程序在内存运行"></a>1 程序在内存运行</h2><p>对于 <strong>CPU</strong> 来说，内存仅仅是一个存放指令和数据的地方，并不能在内存中完成计算功能，例如要计算 <code>a = b + c</code>，必须将 <code>a、b、c</code> 都读取到 <strong>CPU</strong> 内部才能进行加法运算。为了了解具体的运算过程，先来看下 <strong>CPU</strong> 的结构。</p><p><strong>CPU</strong> 是一个复杂的计算机部件，它内部又包含很多小零件，如下图所示：</p><p><img src="/../image/c_pic/%E5%9B%BE1.1.png"></p><ul><li><p>运算单元是 <strong>CPU</strong> 的大脑，负责加减乘除、比较、位移等运算工作，每种运算都有对应的电路支持，速度很快。</p></li><li><p>寄存器（<strong>Register</strong>）是 <strong>CPU</strong> 内部非常小、非常快速的存储部件，它的容量很有限，对于 <strong>32</strong> 位的 <strong>CPU</strong>，每个寄存器一般能存储 <strong>32</strong> 位（<strong>4</strong> 个字节）的数据，对于 <strong>64</strong> 位的 <strong>CPU</strong>，每个寄存器一般能存储 <strong>64</strong> 位（ <strong>8</strong> 个字节）的数据。为了完成各种复杂的功能，现代 <strong>CPU</strong> 都内置了几十个甚至上百个的寄存器，嵌入式系统功能单一，寄存器数量较少。</p><ul><li>所谓多少位的 <strong>CPU</strong>，指的就是寄存器的的位数。<strong>PC</strong> 使用的 <strong>CPU</strong> 已经进入了 <strong>64</strong> 位时代，例如 <strong>Intel</strong> 的 <strong>Core i3、i5、i7</strong> 等。</li><li>寄存器在程序的执行过程中至关重要，不可或缺，它们可以用来完成数学运算、控制循环次数、控制程序的执行流程、标记 <strong>CPU</strong> 运行状态等。<ul><li><strong>EIP（Extern Instruction Pointer）</strong> 寄存器的值是下一条指令的地址，<strong>CPU</strong> 执行完当前指令后，会根据 <strong>EIP</strong> 的值找到下一条指令，改变 <strong>EIP</strong> 的值，就会改变程序的执行流程；</li><li><strong>CR3</strong> 寄存器保存着当前进程页目录的物理地址，切换进程就会改变 <strong>CR3</strong> 的值；</li><li><strong>EBP、ESP</strong> 寄存器用来指向栈的底部和顶部，函数调用会改变 <strong>EBP</strong> 和 <strong>ESP</strong> 的值。</li></ul></li></ul></li></ul><h3 id="1-1-为何-CPU-内部为什么要设置缓存呢？"><a href="#1-1-为何-CPU-内部为什么要设置缓存呢？" class="headerlink" title="1.1 为何 CPU 内部为什么要设置缓存呢？"></a>1.1 为何 CPU 内部为什么要设置缓存呢？</h3><p>虽然内存的读取速度已经很快了，但是和 <strong>CPU</strong> 比起来，还是有很大差距的，不是一个数量级的，如果每次都从内存中读取数据，会严重拖慢 <strong>CPU</strong> 的运行速度，<strong>CPU</strong> 经常处于等待状态，无事可做。在 <strong>CPU</strong> 内部设置一个缓存，可以将使用频繁的数据暂时读取到缓存，需要同一地址上的数据时，就不用大老远地再去访问内存，直接从缓存中读取即可。</p><blockquote><p>在购买 <strong>CPU</strong> 时，也会经常关心缓存容量，例如 <strong>Intel Core i7 3770K</strong> 的三级缓存为 <strong>8MB</strong>，二级缓存为 <strong>256KB</strong>，一级缓存为 <strong>32KB</strong>。容量越大，<strong>CPU</strong> 越强悍。</p></blockquote><h3 id="1-2-CPU指令"><a href="#1-2-CPU指令" class="headerlink" title="1.2 CPU指令"></a>1.2 CPU指令</h3><p>要想让 <strong>CPU</strong> 工作，必须借助特定的指令，例如 <strong>add</strong> 用于加法运算，<strong>sub</strong> 用于除法运算，<strong>cmp</strong> 用于比较两个数的大小，这称为 <strong>CPU</strong> 的指令集<strong>（Instruction Set）</strong>。 <strong>C</strong> 语言代码最终也会编译成一条一条的 <strong>CPU</strong> 指令。不同型号的 <strong>CPU</strong> 支持的指令集会有所差异，但绝大部分是相同的。</p><p>以 <strong>C</strong> 语言中的加法为例来演示 <strong>CPU</strong> 指令的使用。假设有下面的C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">0X14</span>, b = <span class="hljs-number">0XAE</span>, c;<br>c = a + b;<br></code></pre></td></tr></table></figure><p>在 <strong>VS2010 Debug</strong> 模式下生成的 <strong>CPU</strong> 指令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov  ptr[a], 0X14<br>mov  ptr[b], 0XAE<br>mov  eax, ptr[a]<br>add  eax, ptr[b]<br>mov  ptr[c], eax<br></code></pre></td></tr></table></figure><p><strong>mov</strong> 和 <strong>add</strong> 都是 <strong>CPU</strong> 指令：</p><ul><li><p><strong>mov</strong> 用来将一个数值移动到一个存储位置。这个数值可以是一个常数，也可以在内存或者寄存器上；这个存储位置可以是寄存器或者内存。</p><ul><li>第一条指令中，<strong>ptr[a]</strong> 表示变量 <strong>a</strong> 的地址，<strong>0X14</strong> 是一个数值，<code>mov ptr[a], 0X14</code> 表示把数值 <strong>0X14</strong> 移动到 <strong>ptr[a]</strong> 指向的内存，也就是给变量 <strong>a</strong> 赋值。第二条指令与此类似。</li><li>第三条指令中，<strong>eax</strong> 是寄存器的名字，该寄存器常用在加法运算中，用来保存某个加数或运算结果，<code>mov eax, ptr[a]</code> 表示把变量 <strong>a</strong> 的值移动到寄存器 <strong>eax</strong> 中。</li><li>第五条指令表示把寄存器 <strong>eax</strong> 的值移动到变量 <strong>c</strong> 中，此时 <strong>exa</strong> 中的值为 <strong>a、b</strong> 相加的和。</li></ul></li><li><p><strong>add</strong> 用来将两个数值相加，这两个数值可以在寄存器或者内存中，<strong>add</strong> 会将相加的结果放在第一个数所在的位置。</p><ul><li>第四条指令 <code>add  eax, ptr[b]</code> 表示把 <strong>eax</strong> 和 <strong>ptr[b]</strong> 中的数值相加，并把结果放在 <strong>eax</strong> 中。</li></ul></li></ul><p>总起来讲：第一二条指令给变量 <strong>a、b</strong> 赋值，第三四条指令完成加法运算，第五条指令将运算结果赋值给变量 <strong>c</strong>。</p><h2 id="2-虚拟内存到底是什么？为什么看到的地址都是假的？"><a href="#2-虚拟内存到底是什么？为什么看到的地址都是假的？" class="headerlink" title="2 虚拟内存到底是什么？为什么看到的地址都是假的？"></a>2 虚拟内存到底是什么？为什么看到的地址都是假的？</h2><p>在 <strong>C</strong> 语言中，指针变量的值就是一个内存地址，<code>&amp; </code> 的作用也是取变量的内存地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 举个栗子 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <br>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">225</span>;<br><span class="hljs-type">int</span>* pa = &amp;a;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pa = %x, &amp;b = %x\n&quot;</span>, pa, &amp;b);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 输出结果 */</span><br>pa = <span class="hljs-number">590f</span>5c4, &amp;b = <span class="hljs-number">590f</span>5e4<br></code></pre></td></tr></table></figure><p>代码中的 <strong>a、b</strong> 是全局变量，它们的内存地址在链接时就已经决定，以后再也不能改变，该程序无论在何时运行，结果都是一样的。</p><p><strong>Q：</strong>如果物理内存中的这两个地址被其他程序占用了怎么办，此时程序是不是无法运行了？</p><p>如下图所示，这些内存地址都是假的，不是真实的物理内存地址，而是虚拟地址。虚拟地址通过 <strong>CPU</strong> 的转换才能对应到物理地址，而且每次程序运行时，操作系统都会重新安排虚拟地址和物理地址的对应关系，哪一段物理内存空闲就使用哪一段。</p><p><img src="/../image/c_pic/%E5%9B%BE2.1.png"></p><h3 id="2-1-虚拟地址"><a href="#2-1-虚拟地址" class="headerlink" title="2.1 虚拟地址"></a>2.1 虚拟地址</h3><p>把程序给出的地址看做是一种虚拟地址 <strong>（Virtual Address）</strong>，然后通过某些映射的方法，将这个虚拟地址转换成实际的物理地址。只要能够妥善地控制这个虚拟地址到物理地址的映射过程，就可以保证程序每次运行时都可以使用相同的地址。</p><p>例如，上面代码中变量 <strong>a</strong> 的地址是 <strong>590f5c4</strong>，第一次运行时它对应的物理内存地址可能是 <strong>0X12ED90AA</strong>，第二次运行时可能又对应 <strong>0XED90</strong>，而程序则不需要关心这些，这些繁杂的内存管理工作交给操作系统处理即可。</p><p>回到程序的运行本质上来看，用户程序在运行时不希望介入到这些复杂的内存管理过程中，作为普通的程序，它需要的是一个简单的执行环境，有自己的内存，有自己的 <strong>CPU</strong>，好像整个程序占有整个计算机而不用关心其他的程序。</p><p>使用虚拟地址好处：1、编程时可以使用固定的内存地址；2、能够使不同程序的地址空间相互隔离，提高内存使用效率。 </p><h4 id="2-1-1-使不同程序的地址空间相互隔离"><a href="#2-1-1-使不同程序的地址空间相互隔离" class="headerlink" title="2.1.1 使不同程序的地址空间相互隔离"></a>2.1.1 使不同程序的地址空间相互隔离</h4><p>如果所有程序都直接使用物理内存，那么程序所使用的地址空间不是相互隔离的。恶意程序可以很容易改写其他程序的内存数据，以达到破坏的目的；有些非恶意、但是有 <strong>Bug</strong> 的程序也可能会不小心修改其他程序的数据，导致其他程序崩溃。</p><p>这对于需要安全稳定的计算机环境的用户来说是不能容忍的，用户希望他在使用计算机的时候，其中一个任务失败了，至少不会影响其他任务。</p><p>使用了虚拟地址后，程序 <strong>A</strong> 和程序 <strong>B</strong> 虽然都可以访问同一个地址，但它们对应的物理地址是不同的，无论如何操作，都不会修改对方的内存。</p><h4 id="2-1-2-提高内存使用效率"><a href="#2-1-2-提高内存使用效率" class="headerlink" title="2.1.2 提高内存使用效率"></a>2.1.2 提高内存使用效率</h4><p>使用虚拟地址后，操作系统会更多地介入到内存管理工作中，这使得控制内存权限成为可能。例如，希望保存数据的内存没有执行权限，保存代码的内存没有修改权限，操作系统占用的内存普通程序没有读取权限等。</p><p>另外，当物理内存不足时，操作系统能够更加灵活地控制换入换出的粒度，磁盘 <strong>I&#x2F;O</strong> 是非常耗时的工作，这能够从很大程度上提高程序性能。</p><h3 id="2-2-中间层思想"><a href="#2-2-中间层思想" class="headerlink" title="2.2 中间层思想"></a>2.2 中间层思想</h3><p>在计算机中，为了让操作更加直观、易于理解、增强用户体验，开发者经常会使用一件法宝——增加中间层，即使用一种间接的方式来屏蔽复杂的底层细节，只给用户提供简单的接口。虚拟地址是使用中间层的一个典型例子。</p><h2 id="3-虚拟地址空间"><a href="#3-虚拟地址空间" class="headerlink" title="3 虚拟地址空间"></a>3 虚拟地址空间</h2><p>虚拟地址空间，就是程序可以使用的虚拟地址的有效范围。虚拟地址和物理地址的映射关系由操作系统决定，相应地，虚拟地址空间的大小也由操作系统决定，但还会受到编译模式的影响。</p><h3 id="3-1-CPU的数据处理能力"><a href="#3-1-CPU的数据处理能力" class="headerlink" title="3.1 CPU的数据处理能力"></a>3.1 CPU的数据处理能力</h3><p><strong>CPU</strong> 是计算机的核心，决定了计算机的数据处理能力和寻址能力，也即决定了计算机的性能。<strong>CPU</strong> 一次（一个时钟内）能处理的数据的大小由寄存器的位数和数据总线的宽度（也即有多少根数据总线）决定，通常所说的多少位的 <strong>CPU</strong>，除了可以理解为寄存器的位数，也可以理解数据总线的宽度，通常情况下它们是相等的。</p><blockquote><p>数据总线位于主板之上，不在 <strong>CPU</strong> 中，也不由 <strong>CPU</strong> 决定，严格来讲，这里应该说CPU能够支持的数据总线的最大根数，也即能够支持的最大数据处理能力。</p></blockquote><p>数据总线和主频都是 <strong>CPU</strong> 的重要指标：数据总线决定了 <strong>CPU</strong> 单次的数据处理能力，主频决定了 <strong>CPU</strong> 单位时间内的数据处理次数，它们的乘积就是 <strong>CPU</strong> 单位时间内的数据处理量。</p><blockquote><p><strong>CPU</strong> 主频在计算机的发展过程中飞速提升，从最初的几十 <strong>KHz</strong>，到后来的几百 <strong>MHz</strong>，再到现在的 <strong>4GHz</strong>，终于因为硅晶体的物理特性很难再提升，只能向多核方向发展。在这个过程中，CPU的数据总线宽度也在成倍增长，从早期的 <strong>8</strong> 位、<strong>16</strong> 位，到后来的 <strong>32</strong> 位，现在计算机大部分都在使用 <strong>64</strong> 位 <strong>CPU</strong>。</p></blockquote><p>需要注意的是，数据总线和地址总线不是一回事，数据总线用于在 <strong>CPU</strong> 和内存之间传输数据，地址总线用于在内存上定位数据，它们之间没有必然的联系，宽度并不一定相等。实际情况是，地址总线的宽度往往随着数据总线的宽度而增长，以访问更大的内存。</p><h4 id="3-1-1-16-位-CPU"><a href="#3-1-1-16-位-CPU" class="headerlink" title="3.1.1 16 位 CPU"></a>3.1.1 16 位 CPU</h4><p>早期的 <strong>CPU</strong> 是16 位的，一次能处理 <strong>16Bit</strong>（2个字节）的数据。计算机产业还处在早期，个人电脑也没有进入千家万户，也没有提出虚拟地址的概念，程序还是直接运行在物理内存上，操作系统对内存的管理非常简陋，程序员轻易就能编写一个恶意程序去修改其他程序的内存。</p><ul><li>典型的<strong>16</strong> 位处理器是 <strong>Intel 8086</strong>，它的数据总线有 <strong>16</strong> 根，地址总线有 <strong>20</strong> 根，寻址能力为 <strong>2^20 &#x3D; 1MB</strong>。</li></ul><h4 id="3-1-2-32-位-CPU"><a href="#3-1-2-32-位-CPU" class="headerlink" title="3.1.2 32 位 CPU"></a>3.1.2 32 位 CPU</h4><p>随着计算机产业的进步，出现了 <strong>32</strong> 位的 <strong>CPU</strong>，一次能处理 <strong>32Bit</strong>（<strong>4</strong> 个字节）的数据。这个时候就提出了虚拟地址的概念，并被应用到 <strong>CPU</strong> 和操作系统中，由它们共同完成虚拟地址和物理地址的映射，这使得程序编写更加容易，运行更加安全。</p><ul><li>典型的32位处理器是 <strong>Intel</strong> 的 <strong>80386</strong> 和 <strong>Intel Pentium 4（奔腾4）</strong>：<strong>80386</strong> 的数据总线和地址总线宽度都是 <strong>32</strong> 位，寻址能力达 <strong>4GB</strong>；<strong>Pentium 4</strong> 的地址总线宽度是 <strong>36</strong> 位，理论寻址能力达 <strong>64GB</strong>。</li></ul><h4 id="3-1-3-64-位-CPU"><a href="#3-1-3-64-位-CPU" class="headerlink" title="3.1.3 64 位 CPU"></a>3.1.3 64 位 CPU</h4><p>现代计算机都使用 <strong>64</strong> 位的 <strong>CPU</strong>，它们一次能处理 <strong>64Bit</strong>（<strong>8</strong> 个字节）的数据。典型的 <strong>64</strong> 位处理器是 <strong>Intel</strong> 的 <strong>Core i3、i5、i7</strong> 等，它们的地址总线宽度为 <strong>40~50</strong> 位左右。<strong>64</strong> 位 <strong>CPU</strong> 的出现使个人电脑再次发生了质的飞跃。</p><h3 id="3-2-实际支持的物理内存"><a href="#3-2-实际支持的物理内存" class="headerlink" title="3.2 实际支持的物理内存"></a>3.2 实际支持的物理内存</h3><p><strong>CPU</strong> 支持的物理内存只是理论上的数据，实际应用中还会受到操作系统的限制，例如，<strong>Win7  64</strong> 位家庭版最大仅支持 <strong>8GB</strong> 或 <strong>16GB</strong> 的物理内存，<strong>Win7 64</strong> 位专业版或企业版能够支持到 <strong>192GB</strong> 的物理内存。</p><p><strong>Windows Server 2003</strong> 数据中心版专为大型企业或国家机构而设计，可以处理海量数据，分为 <strong>32</strong> 位版和 <strong>64</strong> 位版，<strong>32</strong> 位版最高支持 <strong>512GB</strong> 的物理内存，这显然超出了 <strong>32</strong> 位 <strong>CPU</strong> 的寻址能力，可以通过两次寻址来实现。</p><h3 id="3-3-编译模式"><a href="#3-3-编译模式" class="headerlink" title="3.3 编译模式"></a>3.3 编译模式</h3><p>为兼容不同的平台，现代编译器大都提供两种编译模式：<strong>32</strong> 位模式和 <strong>64</strong> 位模式。</p><h4 id="3-3-1-32-位编译模式"><a href="#3-3-1-32-位编译模式" class="headerlink" title="3.3.1 32 位编译模式"></a>3.3.1 32 位编译模式</h4><p>在 <strong>32</strong> 位模式下，一个指针或地址占用 <strong>4</strong> 个字节的内存，共有 <strong>32</strong> 位，理论上能够访问的虚拟内存空间大小为 <strong>2^32 &#x3D; 0X100000000 Bytes</strong>，即 <strong>4GB</strong>，有效虚拟地址范围是 <strong>0 ~ 0XFFFFFFFF</strong>。 </p><p>对于 <strong>32</strong> 位的编译模式，不管实际物理内存有多大，程序能够访问的有效虚拟地址空间的范围就是 <strong>0 ~ 0XFFFFFFFF</strong>，也即虚拟地址空间的大小是 <strong>4GB</strong>。程序能够使用的最大内存为 <strong>4GB</strong>，跟物理内存没有关系。</p><ul><li><p>如果程序需要的内存大于物理内存，或者内存中剩余的空间不足以容纳当前程序，那么操作系统会将内存中暂时用不到的一部分数据写入到磁盘，等需要的时候再读取回来。而程序只管使用 <strong>4GB</strong> 的内存，不用关心硬件资源够不够。</p></li><li><p>如果物理内存大于 <strong>4GB</strong>，例如目前很多 <strong>PC</strong> 机都配备了 <strong>8GB</strong> 的内存，那么程序也无能为力，它只能够使用其中的 <strong>4GB</strong>。</p></li></ul><h4 id="3-3-2-64-位编译模式"><a href="#3-3-2-64-位编译模式" class="headerlink" title="3.3.2 64 位编译模式"></a>3.3.2 64 位编译模式</h4><p>在 <strong>64</strong> 位编译模式下，一个指针或地址占用 <strong>8</strong> 个字节的内存，共有 <strong>64</strong> 位，理论上能够访问的虚拟内存空间大小为 <strong>2^64</strong>。这是一个很大的值，几乎是无限的，就目前的技术来讲，不但物理内存不可能达到这么大，<strong>CPU</strong> 的寻址能力也没有这么大，实现 <strong>64</strong> 位长的虚拟地址只会增加系统的复杂度和地址转换的成本，带不来任何好处，所以 <strong>Windows</strong> 和 <strong>Linux</strong> 都对虚拟地址进行了限制，仅使用虚拟地址的低 <strong>48</strong> 位（<strong>6</strong> 个字节），总的虚拟地址空间大小为 <strong>2^48 &#x3D; 256TB</strong>。</p><blockquote><p><strong>32</strong> 位的操作系统只能运行 <strong>32</strong> 位的程序（也即以 <strong>32</strong> 位模式编译的程序），<strong>64</strong> 位操作系统可以同时运行 <strong>32</strong> 位的程序（为了向前兼容，保留已有的大量的 <strong>32</strong> 位应用程序）和 <strong>64</strong> 位的程序（也即以 <strong>64</strong> 位模式编译的程序）。<br><strong>64</strong> 位的 <strong>CPU</strong> 运行 <strong>64</strong> 位的程序才能发挥它的最大性能，运行 <strong>32</strong> 位的程序会白白浪费一部分资源。</p></blockquote><p>目前计算机可以说已经进入了 <strong>64</strong> 位的时代，之所以还要提供 <strong>32</strong> 位编译模式，是为了兼容一些老的硬件平台和操作系统，或者某些场合下 <strong>32</strong> 位的环境已经足够，使用 <strong>64</strong> 位环境会增大成本，例如嵌入式系统、单片机、工控等。</p><p>这里所说的 <strong>32</strong> 位环境是指：<strong>32</strong> 位的 <strong>CPU + 32</strong> 位的操作系统 + <strong>32</strong> 位的程序。<br>另外需要说明的是，<strong>32</strong> 位环境拥有非常经典的设计，易于理解，适合教学，现有的很多资料都是以 <strong>32</strong> 位环境为基础进行讲解的。除非特别指明，否则都是针对 <strong>32</strong> 位环境。相比于 <strong>32</strong> 位环境，<strong>64</strong> 位环境的设计思路并没有发生质的变化，理解了 <strong>32</strong> 环境很容易向 <strong>64</strong> 位环境迁移。</p><h2 id="4-内存分页机制"><a href="#4-内存分页机制" class="headerlink" title="4 内存分页机制"></a>4 内存分页机制</h2><p>关于虚拟地址和物理地址的映射有很多思路，假设以程序为单位，把一段与程序运行所需要的同等大小的虚拟空间映射到某段物理空间。</p><p>例如程序 <strong>A</strong> 需要 <strong>10MB</strong> 内存，虚拟地址的范围是从 <strong>0X00000000</strong> 到 <strong>0X00A00000</strong>，假设它被映射到一段同等大小的物理内存，地址范围从 <strong>0X00100000</strong> 到 <strong>0X00B00000</strong>，即虚拟空间中的每一个字节对应于物理空间中的每一个字节。</p><p>程序运行时，它们的对应关系如下图所示：</p><p><img src="/../image/c_pic/%E5%9B%BE4.1.png"></p><p>当程序 <strong>A</strong> 需要访问 <strong>0X00001000</strong> 时，系统会将这个虚拟地址转换成实际的物理地址 <strong>0X00101000</strong>，访问 <strong>0X002E0000</strong> 时，转换成 <strong>0X003E0000</strong>，以此类推。</p><p>这种以整个程序为单位的方法很好地解决了不同程序地址不隔离的问题，同时也能够在程序中使用固定的地址。</p><ul><li>地址隔离</li></ul><p>如上图所示，程序 <strong>A</strong> 和程序 <strong>B</strong> 分别被映射到了两块不同的物理内存，它们之间没有任何重叠，如果程序 <strong>A</strong> 访问的虚拟地址超出了 <strong>0X00A00000</strong> 这个范围，系统就会判断这是一个非法的访问，拒绝这个请求，并将这个错误报告给用户，通常的做法就是强制关闭程序。</p><ul><li>程序可以使用固定的内存地址</li></ul><p>虚拟内存无论被映射到物理内存的哪一个区域，对于程序员来说都是透明的，不需要关心物理地址的变化，只需要按照从地址 <strong>0X00000000</strong> 到 <strong>0X00A00000</strong> 来编写程序、放置变量即可，程序不再需要重定位。</p><ul><li>内存使用效率问题</li></ul><p>以程序为单位对虚拟内存进行映射时，如果物理内存不足，被换入换出到磁盘的是整个程序，这样势必会导致大量的磁盘读写操作，严重影响运行速度，所以这种方法还是显得粗糙，粒度比较大。</p><h3 id="4-1-内存分页机制"><a href="#4-1-内存分页机制" class="headerlink" title="4.1 内存分页机制"></a>4.1 内存分页机制</h3><p>当一个程序运行时，在某个时间段内，它只是频繁地用到了一小部分数据，也就是说，程序的很多数据其实在一个时间段内都不会被用到。</p><p>以整个程序为单位进行映射，不仅会将暂时用不到的数据从磁盘中读取到内存，也会将过多的数据一次性写入磁盘，这会严重降低程序的运行效率。</p><p>现代计算机都使用分页（<strong>Paging</strong>）的方式对虚拟地址空间和物理地址空间进行分割和映射，以减小换入换出的粒度，提高程序运行效率。</p><p>分页（<strong>Paging</strong>）的思想是指把地址空间人为地分成大小相等（并且固定）的若干份，这样的一份称为一页，就像一本书由很多页面组成，每个页面的大小相等。如此，就能够以页为单位对内存进行换入换出：</p><ul><li><p>当程序运行时，只需要将必要的数据从磁盘读取到内存，暂时用不到的数据先留在磁盘中，什么时候用到什么时候读取。</p></li><li><p>当物理内存不足时，只需要将原来程序的部分数据写入磁盘，腾出足够的空间即可，不用把整个程序都写入磁盘。</p></li></ul><h4 id="4-1-1-关于页的大小"><a href="#4-1-1-关于页的大小" class="headerlink" title="4.1.1 关于页的大小"></a>4.1.1 关于页的大小</h4><p>页的大小是固定的，由硬件决定，或硬件支持多种大小的页，由操作系统选择决定页的大小。比如 <strong>Intel Pentium</strong> 系列处理器支持 <strong>4KB</strong> 或 <strong>4MB</strong> 的页大小，那么操作系统可以选择每页大小为 <strong>4KB</strong>，也可以选择每页大小为 <strong>4MB</strong>，但是在同一时刻只能选择一种大小，所以对整个系统来说，也就是固定大小。</p><p>目前几乎所有 <strong>PC</strong> 上的操作系统都是用 <strong>4KB</strong> 大小的页。假设使用的 <strong>PC</strong> 机是 <strong>32</strong> 位的，那么虚拟地址空间总共有 <strong>4GB</strong>，按照 <strong>4KB</strong> 每页分的话，总共有 <strong>2^32 &#x2F; 2^12 &#x3D; 2^20 &#x3D; 1M &#x3D; 1048576</strong> 个页；物理内存也是同样的分法。</p><h3 id="4-2-根据页进行映射"><a href="#4-2-根据页进行映射" class="headerlink" title="4.2 根据页进行映射"></a>4.2 根据页进行映射</h3><p>下面通过一个简单的例子来说明虚拟地址是如何根据页来映射到物理地址的，(虚拟空间、物理空间和磁盘之间的页映射关系)</p><p><img src="/../image/c_pic/%E5%9B%BE4.2.png"></p><p>程序1和程序2的虚拟空间都有 <strong>8</strong> 个页，为了方便说明问题，假设每页大小为 <strong>1KB</strong>，那么虚拟地址空间就是 <strong>8KB</strong>。假设计算机有 <strong>13</strong> 条地址线，即拥有 <strong>2^13</strong> 的物理寻址能力，那么理论上物理空间可以多达 <strong>8KB</strong>。但是出于种种原因，购买内存的资金不够，只买得起 <strong>6KB</strong> 的内存，所以物理空间真正有效的只是前 <strong>6KB</strong>。</p><p>当把程序的虚拟空间按页分隔后，把常用的数据和代码页加载到内存中，把不常用的暂时留在磁盘中，当需要用到的时候再从磁盘中读取。上图中，假设有两个程序 <strong>Program 1</strong> 和 <strong>Program 2</strong>，它们的部分虚拟页面被映射到物理页面，比如 <strong>Program 1</strong> 的 <strong>VP0</strong>、<strong>VP1</strong> 和 <strong>VP7</strong> 分别被映射到 <strong>PP0</strong>、<strong>PP2</strong> 和 <strong>PP3</strong>；而有部分却留在磁盘中，比如 <strong>VP2</strong>、<strong>VP3</strong> 分别位于磁盘的 <strong>DP0</strong>、<strong>DP1</strong>中；另外还有一些页面如 <strong>VP4</strong>、<strong>VP5</strong>、<strong>VP6</strong> 可能尚未被用到或者访问到，它们暂时处于未使用状态。</p><blockquote><p>这里，把虚拟空间的页叫做虚拟页（<strong>VP，Virtual Page</strong>），把物理内存中的页叫做物理页（<strong>PP，Physical Page</strong>），把磁盘中的页叫做磁盘页（<strong>DP，Disk Page</strong>）。<br>图中的线表示映射关系，可以看到，<strong>Program 1</strong> 和 <strong>Program 2</strong> 中的有些虚拟页被映射到同一个物理页，这样可以实现内存共享。</p></blockquote><p><strong>Program 1</strong> 的 <strong>VP2</strong>、<strong>VP3</strong> 不在内存中，但是当进程需要用到这两个页的时候，硬件会捕获到这个消息，就是所谓的页错误（<strong>Page Fault</strong>），然后操作系统接管进程，负责将 <strong>VP2</strong> 和 <strong>PV3</strong> 从磁盘中读取出来并且装入内存，然后将内存中的这两个页与 <strong>VP2</strong>、<strong>VP3</strong> 之间建立映射关系。</p><h2 id="5-分页机制实现"><a href="#5-分页机制实现" class="headerlink" title="5 分页机制实现"></a>5 分页机制实现</h2><p>现代操作系统都使用分页机制来管理内存，这使得每个程序都拥有自己的地址空间。每当程序使用虚拟地址进行读写时，都必须转换为实际的物理地址，才能真正在内存条上定位数据。如下图所示：</p><p><img src="/../image/c_pic/%E5%9B%BE13.1.png"></p><p>内存地址的转换是通过一种叫做页表（<strong>Page Table</strong>）的机制来完成的，即：</p><ul><li>页表是什么？为什么要采用页表机制，而不采用其他机制？</li><li>虚拟地址如何通过页表转换为物理地址？</li></ul><h3 id="5-1-直接使用数组转换"><a href="#5-1-直接使用数组转换" class="headerlink" title="5.1 直接使用数组转换"></a>5.1 直接使用数组转换</h3><p>最容易想到的映射方案是使用数组：每个数组元素保存一个物理地址，而把虚拟地址作为数组下标，这样就能够很容易地完成映射，并且效率不低。如下图所示：</p><p><img src="/../image/c_pic/%E5%9B%BE13.2.png"></p><p>但是这样的数组有 <strong>2^32</strong> 个元素，每个元素大小为 <strong>4</strong> 个字节，总共占用 <strong>16GB</strong> 的内存，显现是不现实的！ </p><h3 id="5-2-使用一级页表"><a href="#5-2-使用一级页表" class="headerlink" title="5.2 使用一级页表"></a>5.2 使用一级页表</h3><p>既然内存是分页的，能够定位到数据所在的页，以及它在页内的偏移（也就是距离页开头的字节数），就能够转换为物理地址。例如，一个 <strong>int</strong> 类型的值保存在第 <strong>12</strong> 页，页内偏移为 <strong>240</strong>，那么对应的物理地址就是 <code>2^12 * 12 + 240 = 49392</code>。</p><blockquote><p><strong>2^12</strong> 为一个页的大小，也就是 <strong>4K</strong>。</p></blockquote><p>虚拟地址空间大小为 <strong>4GB</strong>，总共包含 <code>2^32/2^12 = 2^20 = 1K*1K = 1M = 1048576</code> 个页面，可以定义一个这样的数组：它包含 <strong>2^20 &#x3D; 1M</strong> 个元素，每个元素的值为页面编号（也就是位于第几个页面），长度为 <strong>4</strong> 字节，整个数组共占用 <strong>4MB</strong> 的内存空间。这样的数组就称为页表（<strong>Page Table</strong>），它记录了地址空间中所有页的编号。</p><p>虚拟地址长度为 <strong>32</strong> 位，不妨进行一下切割，将高 <strong>20</strong> 位作为页表数组的下标，低 <strong>12</strong> 位作为页内偏移。如下图所示：</p><p><img src="/../image/c_pic/%E5%9B%BE13.3.png"></p><p>为什么要这样切割呢？因为页表数组共有 <code>2^20 = 1M</code> 个元素，使用虚拟地址的高 <strong>20</strong> 位作为下标，正好能够访问数组中的所有元素；并且，一个页面的大小为 <code>2^12 = 4KB</code>，使用虚拟地址的低 <strong>12</strong> 位恰好能够表示所有偏移。</p><p>注意，表示页面编号只需要 <strong>20</strong> 位，而页表数组的每个元素的长度却为 <strong>4</strong> 字节，即 <strong>32</strong> 位，多出 <code>32 - 20 = 12</code> 位。这 <strong>12</strong> 位也有很大的用处，可以用来表示当前页的相关属性，例如是否有读写权限、是否已经分配物理内存、是否被换出到硬盘等。</p><p>例如一个虚拟地址 <strong>0XA010BA01</strong>，它的高 <strong>20</strong> 位是 <strong>0XA010B</strong>，所以需要访问页表数组的第 <strong>0XA010B</strong> 个元素，才能找到数据所在的物理页面。假设页表数组第 <strong>0XA010B</strong> 个元素的值为 <strong>0X0F70AAA0</strong>，它的高 <strong>20</strong> 位为 <strong>0X0F70A</strong>，那么就可以确定数据位于第 <strong>0X0F70A</strong> 个物理页面。再来看虚拟地址，它的低 <strong>12</strong> 位是 0XA01，所以页内偏移也是 <strong>0XA01</strong>。有了页面索引和页内偏移，就可以算出物理地址了。经过计算，最终的物理地址为 <code>0X0F70A * 2^12 + 0XA01 = 0X0F70A000 + 0XA01 = 0X0F70AA01</code>。</p><p>这种思路所形成的映射关系如下图所示：</p><p><img src="/../image/c_pic/%E5%9B%BE13.4.png"></p><p>可以发现，有的页被映射到物理内存，有的被映射到硬盘，不同的映射方式可以由页表数组元素的低 <strong>12</strong> 位来控制。</p><p>使用这种方案，不管程序占用多大的内存，都要为页表数组分配 <strong>4M</strong> 的内存空间（页表数组也必须放在物理内存中），因为虚拟地址空间中的高 <strong>1G</strong> 或 <strong>2G</strong> 是被系统占用的，必须保证较大的数组下标有效。</p><p>现在硬件很便宜了，内存容量大了，很多电脑都配备 <strong>4G</strong> 或 <strong>8G</strong> 的内存，页表数组占用 <strong>4M</strong> 内存或许不觉得多，但在 <strong>32</strong> 位系统刚刚发布的时候，内存还是很紧缺的资源，很多电脑才配备 <strong>100M</strong> 甚至几十兆的内存，<strong>4M</strong> 内存就显得有点大了，所以还得对上面的方案进行改进，压缩页表数组所占用的内存。</p><h3 id="5-3-使用两级页表"><a href="#5-3-使用两级页表" class="headerlink" title="5.3 使用两级页表"></a>5.3 使用两级页表</h3><p>上面的页表共有 <strong>2^20 &#x3D; 2^10 * 2^10</strong> 个元素，为了压缩页表的存储空间，可以将上面的页表分拆成 <strong>2^10 &#x3D; 1K &#x3D; 1024</strong> 个小的页表，这样每个页表只包含 <strong>2^10 &#x3D; 1K &#x3D; 1024</strong> 个元素，占用 <strong>2^10 * 4 &#x3D; 4KB</strong> 的内存，也即一个页面的大小。这 <strong>1024</strong> 个小的页表，可以存储在不同的物理页，它们之间可以是不连续的。</p><p>那么问题来了，既然这些小的页表分散存储，位于不同的物理页，该如何定位它们呢？也就是如何记录它们的编号（也即在物理内存中位于第几个页面）。</p><p><strong>1024</strong> 个页表有 <strong>1024</strong> 个索引，所以不能用一个指针指向它们，必须将这些索引再保存到一个额外的数组中。这个额外的数组有 <strong>1024</strong> 个元素，每个元素记录一个页表所在物理页的编号，长度为 <strong>4</strong> 个字节，总共占用 <strong>4KB</strong> 的内存。将这个额外的数组称为页目录（<strong>Page Directory</strong>），因为它的每一个元素对应一个页表。</p><p>如此，只要使用一个指针来记住页目录的地址即可，等到进行地址转换时，可以根据这个指针找到页目录，再根据页目录找到页表，最后找到物理地址，前后共经过 <strong>3</strong> 次间接转换。</p><p>那么，如何根据虚拟地址找到页目录和页表中相应的元素呢？不妨将虚拟地址分割为三分部，高 <strong>10</strong> 位作为页目录中元素的下标，中间 <strong>10</strong> 位作为页表中元素的下标，最后 <strong>12</strong> 位作为页内偏移，如下图所示：</p><p><img src="/../image/c_pic/%E5%9B%BE13.5.png"></p><p>知道了物理页的索引和页内偏移就可以转换为物理地址了，在这种方案中，页内偏移可以从虚拟地址的低 <strong>12</strong> 位得到，但是物理页索引却保存在 <strong>1024</strong> 个分散的小页表中，所以就必须先根据页目录找到对应的页表，再根据页表找到物理页索引。</p><p>例如一个虚拟地址 <strong>0011000101  1010001100  111100001010</strong>，它的高10位为 <strong>0011000101</strong>，对应页目录中的第 <strong>0011000101</strong> 个元素，假设该元素的高 <strong>20</strong> 位为 <strong>0XF012A</strong>，也即对应的页表在物理内存中的编号为 <strong>0XF012A</strong>，这样就找到了页表。虚拟地址中间 <strong>10</strong> 位为 <strong>1010001100</strong>，它对应页表中的第 <strong>1010001100</strong> 个元素，假设该元素的高 <strong>20</strong> 位为 <strong>0X00D20</strong>，也即物理页的索引为 <strong>0X00D20</strong>。通过计算，最终的物理地址为 <code>0X00D20 * 2^12 + 111100001010 = 0X00D20F0A</code>。</p><p>这种思路所形成的映射关系如下图所示：</p><p><img src="/../image/c_pic/%E5%9B%BE13.6.png"></p><blockquote><p>图中的点状虚线说明了最终的映射关系。图中没有考虑映射到硬盘的情况。</p></blockquote><p>采用这样的两级页表的一个明显优点是，如果程序占用的内存较少，分散的小页表的个数就会远远少于 <strong>1024</strong> 个，只会占用很少的一部分存储空间（远远小于<strong>4M</strong>）。</p><p>在极少数的情况下，程序占用的内存非常大，布满了 <strong>4G</strong> 的虚拟地址空间，这样小页表的数量可能接近甚至等于 <strong>1024</strong>，再加上页目录占用的存储空间，总共是 <strong>4MB+4KB</strong>，比上面使用一级页表的方案仅仅多出 <strong>4KB</strong> 的内存。这是可以容忍的，因为很少出现如此极端的情况。</p><p>也就是说，使用两级页表后，页表占用的内存空间不固定，它和程序本身占用的内存空间成正比，从整体上来看，会比使用一级页表占用的内存少得多。</p><h3 id="5-4使用多级页表"><a href="#5-4使用多级页表" class="headerlink" title="5.4使用多级页表"></a>5.4使用多级页表</h3><p>对于 <strong>64</strong> 位环境，虚拟地址空间达到 <strong>256TB</strong>，使用二级页表占用的存储空间依然不小，所以会更加细化，从而使用三级页表甚至多级页表，这样就会有多个页目录，虚拟地址也会被分割成多个部分，思路和上面是一样。</p><h2 id="6-内存对齐"><a href="#6-内存对齐" class="headerlink" title="6 内存对齐"></a>6 内存对齐</h2><p>计算机内存是以字节（<strong>Byte</strong>）为单位划分的，理论上 <strong>CPU</strong> 可以访问任意编号的字节，但实际情况并非如此。</p><p><strong>CPU</strong> 通过地址总线来访问内存，一次能处理几个字节的数据，就命令地址总线读取几个字节的数据。<strong>32</strong> 位的 <strong>CPU</strong> 一次可以处理 <strong>4</strong> 个字节的数据，那么每次就从内存读取 <strong>4</strong> 个字节的数据；少了浪费主频，多了没有用。<strong>64</strong> 位的处理器也是这个道理，每次读取8个字节。</p><p>以 <strong>32</strong> 位的 <strong>CPU</strong> 为例，实际寻址的步长为 <strong>4</strong> 个字节，也就是只对编号为 <strong>4</strong> 的倍数的内存寻址，例如 <strong>0、4、8、12、1000</strong> 等，而不会对编号为 <strong>1、3、11、1001</strong> 的内存寻址。</p><p><img src="/../image/c_pic/%E5%9B%BE5.1.png"></p><p>这样做可以以最快的速度寻址：不遗漏一个字节，也不重复对一个字节寻址。</p><p>对程序来说，一个变量最好位于一个寻址步长的范围内，这样一次就可以读取到变量的值；如果跨步长存储，就需要读取两次，然后再拼接数据，效率显然降低。</p><p>例如一个 <strong>int</strong> 类型的数据，如果地址为 <strong>8</strong>，那么很好办，对编号为 <strong>8</strong> 的内存寻址一次就可以。如果编号为 <strong>10</strong>，就比较麻烦，<strong>CPU</strong> 需要先对编号为 <strong>8</strong> 的内存寻址，读取 <strong>4</strong> 个字节，得到该数据的前半部分，然后再对编号为 <strong>12</strong> 的内存寻址，读取 <strong>4</strong> 个字节，得到该数据的后半部分，再将这两部分拼接起来，才能取得数据的值。</p><p>将一个数据尽量放在一个步长之内，避免跨步长存储，这称为内存对齐。在 <strong>32</strong> 位编译模式下，默认以 <strong>4</strong> 字节对齐；在 <strong>64</strong> 位编译模式下，默认以 <strong>8</strong> 字节对齐。</p><p>为了提高存取效率，编译器会自动进行内存对齐，请看下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> a;<br><span class="hljs-type">char</span> b;<br><span class="hljs-type">int</span> c;<br>&#125;t = &#123;<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-number">20</span>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;length:%d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(t));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;a: %x\n&amp;b:%x\n&amp;c:%x\n&quot;</span>, &amp;t.a, &amp;t.b, &amp;t.c);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 输出结果 */</span><br>length:<span class="hljs-number">12</span><br>&amp;a:<span class="hljs-number">847</span>dc050<br>&amp;b:<span class="hljs-number">847</span>dc054<br>&amp;c:<span class="hljs-number">847</span>dc058<br></code></pre></td></tr></table></figure><p>如果不考虑内存对齐，结构体变量 t 所占内存应该为 <code>4+1+4=9</code> 个字节。考虑到内存对齐，虽然成员 <strong>b</strong> 只占用1个字节，但它所在的寻址步长内还剩下 <strong>3</strong> 个字节的空间，放不下一个 <strong>int</strong> 型的变量了，所以要把成员 <strong>c</strong> 放到下一个寻址步长。剩下的这 <strong>3</strong> 个字节，作为内存填充浪费掉了。</p><img src="../image/c_pic/图5.2.png" alt="图3.2" style="zoom: 50%;" /><ul><li>编译器之所以要内存对齐，是为了更加高效的存取成员 <strong>c</strong>，而代价就是浪费了 3 个字节的空间。</li></ul><p>除了结构体，变量也会进行内存对齐。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> m;<br><span class="hljs-type">char</span> c;<br><span class="hljs-type">int</span> n;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;m:%x\n&amp;c:%x\n&amp;n:%x\n&quot;</span>, &amp;m, &amp;c, &amp;n);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 输出结果 */</span><br>&amp;m:cc35f9b4<br>&amp;c:cc35f9d4<br>&amp;n:cc35f9f4<br></code></pre></td></tr></table></figure><ul><li>地址都是 <strong>4</strong> 的整数倍，并相互挨着。</li></ul><h3 id="6-1-改变对齐方式"><a href="#6-1-改变对齐方式" class="headerlink" title="6.1 改变对齐方式"></a>6.1 改变对齐方式</h3><p>对齐方式可以通过编译器参数修改。</p><ul><li>内存对齐虽然和硬件有关，但是决定对齐方式的是编译器，如果硬件是 <strong>64</strong> 位的，却以 <strong>32</strong> 位的方式编译，那么还是会按照 <strong>4</strong> 个字节对齐。</li></ul><h2 id="7-栈的定义和栈溢出"><a href="#7-栈的定义和栈溢出" class="headerlink" title="7 栈的定义和栈溢出"></a>7 栈的定义和栈溢出</h2><p>程序的虚拟地址空间分为多个区域，栈（<strong>Stack</strong>）是其中地址较高的一个区域。栈（<strong>Stack</strong>）可以存放函数参数、局部变量、局部数组等作用范围在函数内部的数据，它的用途就是完成函数的调用。</p><p>栈内存由系统自动分配和释放：发生函数调用时就为函数运行时用到的数据分配内存，函数调用结束后就将之前分配的内存全部销毁。所以局部变量、参数只在当前函数中有效，不能传递到函数外部。</p><h3 id="7-1-栈的概念"><a href="#7-1-栈的概念" class="headerlink" title="7.1 栈的概念"></a>7.1 栈的概念</h3><p>在计算机中，栈可以理解为一个特殊的容器，用户可以将数据依次放入栈中，然后再将数据按照相反的顺序从栈中取出。也就是说，先放入的数据最后才能取出，而最后放入的数据必须先取出。这称为先进后出（<strong>First In Last Out</strong>）原则。</p><p>放入数据常称为入栈或压栈（<strong>Push</strong>），取出数据常称为出栈或弹出（<strong>Pop</strong>）。如下图所示：</p><p><img src="/../image/c_pic/%E5%9B%BE6.1.png"></p><p>可以发现，栈底始终不动，出栈入栈只是在移动栈顶，当栈中没有数据时，栈顶和栈底重合。</p><blockquote><p>从本质上来讲，栈是一段连续的内存，需要同时记录栈底和栈顶，才能对当前的栈进行定位。在现代计算机中，通常使用 <strong>ebp</strong> 寄存器指向栈底，而使用 <strong>esp</strong> 寄存器指向栈顶。随着数据的进栈出栈，<strong>esp</strong> 的值会不断变化，进栈时 <strong>esp</strong> 的值减小，出栈时 <strong>esp</strong> 的值增大。</p></blockquote><p><strong>ebp</strong> 和 <strong>esp</strong> 都是 <strong>CPU</strong> 中的寄存器：<strong>ebp</strong> 是 <strong>Extend Base Pointer</strong> 的缩写，通常用来指向栈底；<strong>esp</strong> 是 <strong>Extend Stack Pointer</strong> 的缩写，通常用来指向栈顶。<br>如下图所示是一个栈的实例：</p><p><img src="/../image/c_pic/%E5%9B%BE6.2.png"></p><h3 id="7-2-栈的大小以及栈溢出"><a href="#7-2-栈的大小以及栈溢出" class="headerlink" title="7.2 栈的大小以及栈溢出"></a>7.2 栈的大小以及栈溢出</h3><p>对每个程序来说，栈能使用的内存是有限的，一般是 <strong>1M~8M</strong>，这在编译时就已经决定了，程序运行期间不能再改变。如果程序使用的栈内存超出最大值，就会发生栈溢出（<strong>Stack Overflow</strong>）错误。</p><blockquote><p>一个程序可以包含多个线程，每个线程都有自己的栈，严格来说，栈的最大值是针对线程来说的，而不是针对程序。</p></blockquote><p>栈内存的大小和编译器有关，编译器会为栈内存指定一个最大值，在 <strong>VC&#x2F;VS</strong> 下，默认是 <strong>1M</strong>，在 <strong>C-Free</strong> 下，默认是 <strong>2M</strong>，在 <strong>Linux GCC</strong> 下，默认是 <strong>8M</strong>。</p><p>当程序使用的栈内存大于默认值（或者修改后的值）时，就会发生栈溢出（<strong>Stack Overflow</strong>）错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> str[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-栈溢出攻击的原理"><a href="#8-栈溢出攻击的原理" class="headerlink" title="8 栈溢出攻击的原理"></a>8 栈溢出攻击的原理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">char</span> str[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    gets(str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str:%s\n&quot;</span>, str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>main()</code> 函数内部定义一个字符数组，并通过 <code>gets()</code> 为它赋值。</p><p>在 <strong>VS2010 Debug</strong> 模式下运行程序，当输入的字符不超过 <strong>10</strong> 个时，可以正确输出，但是当输入的字符过多时，就会出现运行时错误。例如输入 <code>&quot;12345678901234567890&quot;</code>，就会出现下面的错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">❌Time check failure.Stack around the variable <span class="hljs-string">&#x27;str&#x27;</span> was corrupted.<br></code></pre></td></tr></table></figure><ul><li><code>main()</code> 函数的栈:</li></ul><p><img src="/../image/c_pic/%E5%9B%BE7.2.png"></p><p>局部数组也是在栈上分配内存，当输入 <code>&quot;12345678901234567890&quot;</code>  时，会发生数组溢出，占用 <code>“4 字节空白内存”</code>、<code>“old ebp”</code> 和 <code>“返回地址”</code> 所在的内存，并将原有的数据覆盖掉，这样当 <code>main()</code> 函数执行完成后，会取得一个错误的返回地址，该地址上的指令是不确定的，或者根本就没有指令，所以程序在返回时出错。</p><p><strong>C</strong> 语言不会对数组溢出做检测，这是一个典型的由于数组溢出导致覆盖了函数返回地址的例子，将这样的错误称为 <code>“栈溢出错误”</code>。</p><blockquote><p>注意：这里所说的 <code>“栈溢出”</code> 是指栈上的某个数据过大，覆盖了其他的数据<br>局部数组在栈上分配内存，并且不对数组溢出做检测，这是导致栈溢出的根源。除了上面讲到的 <code>gets()</code> 函数，<code>strcpy()</code>、<code>scanf()</code> 等能够向数组写入数据的函数都有导致栈溢出的风险。</p></blockquote><p>下面是使用 <code>strcpy()</code> 函数导致栈溢出的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> *str1 = <span class="hljs-string">&quot;梓语慕晓梓语慕晓&quot;</span>;<br>    <span class="hljs-type">char</span> str2[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">strcpy</span>(str2, str1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str:%s\n&quot;</span>, str2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将 <strong>str1</strong> 复制到 <strong>str2</strong>，显然超出了 <strong>str2</strong> 的接受范围，会发生溢出，覆盖返回地址，导致 <code>main()</code> 函数返回时出错。</p><p>栈溢出一般不会产生严重的后果，但是如果有用户精心构造栈溢出，让返回地址指向恶意代码，那就比较危险了，这就是常说的栈溢出攻击。</p><h2 id="9-动态内存分配"><a href="#9-动态内存分配" class="headerlink" title="9 动态内存分配"></a>9 动态内存分配</h2><p>在进程的地址空间中，代码区、常量区、全局数据区的内存在程序启动时就已经分配好了，它们大小固定，不能由程序员分配和释放，只能等到程序运行结束由操作系统回收。这称为<strong>静态内存分配</strong>。</p><p>栈区和堆区的内存在程序运行期间可以根据实际需求来分配和释放，不用在程序刚启动时就备足所有内存。这称为<strong>动态内存分配</strong>。</p><p>使用静态内存的优点是速度快，省去了向操作系统申请内存的时间，缺点就是不灵活，缺乏表现力，例如不能控制数据的作用范围，不能使用较大的内存。而使用动态内存可以让程序对内存的管理更加灵活和高效，需要内存就立即分配，而且需要多少就分配多少，从几个字节到几个 <strong>GB</strong> 不等；不需要时就立即回收，再分配给其他程序使用。</p><h3 id="9-1-栈和堆的区别"><a href="#9-1-栈和堆的区别" class="headerlink" title="9.1 栈和堆的区别"></a>9.1 栈和堆的区别</h3><p>栈区和堆区的管理模式有所不同：栈区内存由系统分配和释放，不受程序员控制；堆区内存完全由程序员掌控，想分配多少就分配多少，想什么时候释放就什么时候释放，非常灵活。</p><p>程序启动时会为栈区分配一块大小适当的内存，对于一般的函数调用这已经足够了，函数进栈出栈只是 <strong>ebp</strong>、<strong>esp</strong> 寄存器指向的变换，或者是向已有的内存中写入数据，不涉及内存的分配和释放。当函数中有较大的局部数组时，比如 <code>1024*10</code> 个元素，编译器就会在函数代码中插入针对栈的动态内存分配函数，这样函数被调用时才分配内存，不调用就不分配。</p><p>经常听说 <code>“栈内存的分配效率要高于堆”</code> 就是这个道理，因为大部分情况下并没有真的分配栈内存，仅仅是对已有内存的操作。</p><h3 id="9-2-动态内存分配函数"><a href="#9-2-动态内存分配函数" class="headerlink" title="9.2 动态内存分配函数"></a>9.2 动态内存分配函数</h3><p>堆（<strong>Heap</strong>）是唯一由程序员控制的内存区域，常说的动态内存分配也是在这个区域。在堆上分配和释放内存需要用到C语言标准库中的几个函数：<code>void指针</code>、<code>malloc()</code>、<code>free()</code>、<code>calloc()</code>、<code>realloc()</code>、<code>restrict 说明符</code>、<code>memcpy()</code>、<code>memmove()</code>、<code>memcmp()</code>。</p><h4 id="9-2-1-void-指针"><a href="#9-2-1-void-指针" class="headerlink" title="9.2.1 void 指针"></a>9.2.1 void 指针</h4><p>C语言提供了一种不定类型的指针：void 指针。它只有内存块的地址信息，没有类型信息，等到使用该块内存时，再向编译器补充说明其数据类型。</p><p>另一方面，void 指针等同于无类型指针，可以指向任意类型的数据，但不能解读数据。void 指针与其他所有类型指针之间都是互相转换关系，任一类型指针都可以转为 void 指针，void 指针也可以转为任一类型指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br><br><span class="hljs-type">void</span>* p = &amp;x;<span class="hljs-comment">// 整数指针转为 void 指针</span><br><span class="hljs-type">int</span>* q = p;<span class="hljs-comment">// void 指针转为整数指针</span><br></code></pre></td></tr></table></figure><p>上面示例演示了，整数指针和 void 指针互相转换过程。 <code>&amp;x</code> 是一个整数指针，<code>p</code>是 void 指针，赋值时 <code>&amp;x</code> 的地址会自动改解释为 void 类型。同样 <code>p</code> 再赋值给整数指针 <code>q</code> 时，<code>p</code> 的地址会自动解释为整数指针。</p><p>注意，由于不知道 void 指针指向什么类型的值，所以不能用 <code>*</code> 运算符取出它指向的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> a = <span class="hljs-string">&#x27;X&#x27;</span>;<br><span class="hljs-type">void</span>* p = &amp;a;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, *p);<span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><p>上面示例中，<code>p</code> 是一个 void 指针，所以这时无法用 <code>*p</code> 取出指针指向的值。</p><p>void 指针的重要之处在于，很多内存相关函数的返回值就是 void 指针，只给出内存块的地址信息。</p><h4 id="9-2-2-malloc"><a href="#9-2-2-malloc" class="headerlink" title="9.2.2 malloc()"></a>9.2.2 malloc()</h4><p><code>malloc()</code> 函数用于分配内存，该函数向系统要求一段内存，系统就在“堆”里面分配一段连续的内存块给它，它的原型定义在头文件 <code>stdlib.h</code>。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在堆区分配 size 字节的内存空间。</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">malloc</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><p>它接受一个非负整数作为参数，表示所要分配的内存字节数，返回一个 void 指针，指向分配好的内存块。因为 <code>malloc()</code> 函数不知道，将要存储在该块内存的数据是什么类型，所以只能返回一个无类型的 void 指针。</p><p>可以使用 <code>malloc()</code> 为任意类型的数据分配内存，常见做法是先使用 <code>sizeof()</code> 函数，算出某种数据类型所需的字节长度，然后再讲这个长度传给 <code>malloc()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><br>*p = <span class="hljs-number">12</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, *p);<span class="hljs-comment">// 12</span><br></code></pre></td></tr></table></figure><p>上述示例中，先为整数类型分配一段内存，然后将整数 <code>12</code> 放入这段内存里面。这个例子其实不需要使用 <code>malloc()</code>，因为 C 语言会自动为整数提供内存。</p><p>有时为了增加代码的可读性，可以对 <code>malloc()</code> 返回的指针进行一次强制类型转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br></code></pre></td></tr></table></figure><p>上述代码将 <code>malloc()</code> 返回的 void 指针，强制转换成了整数指针。由于 <code>sizeof()</code> 的参数可以是变量，所以上面的例子也可以写成下面这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*p))<br></code></pre></td></tr></table></figure><p><code>malloc()</code> 分配内存有可能失败，这是返回常量 <code>NULL</code>。<code>NULL</code> 的值为0，是一个无法读写的内存地址，可以理解成一个不指向任何地方的指针。它在包括 <code>stdlib.h</code> 等多个头文件里面都有定义，所以只要可以使用 <code>malloc()</code>，就可以使用 <code>NULL</code>。由于存在分配失败的可能，所以最好在使用 <code>malloc()</code> 之后检查下，是否分配成功。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><br><span class="hljs-keyword">if</span>(p == Null)&#123;<br><span class="hljs-comment">// 内存分配失败</span><br>&#125;<br><br><span class="hljs-comment">// or</span><br><span class="hljs-keyword">if</span>(!p)&#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面示例中，通过判断返回的指针 <code>p</code> 是否为 <code>Null</code>，确认 <code>malloc()</code> 是否分配成功。</p><p><code>malloc()</code> 最常见的场合，就是为数组和自定义数据结构分配内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>p[i] = i * <span class="hljs-number">5</span>;<br>&#125;<br>````<br><br>上面示例中，`p` 是一个整数指针，指向一段可以放置<span class="hljs-number">10</span>个整数的内存，所以可以用作数组。<br><br>`<span class="hljs-built_in">malloc</span>()` 用来创建数组，有一个好处，就是可以创建动态数组，即根据成员数量的不同，而创建长度不同的数组。<br><br>```c<br><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br></code></pre></td></tr></table></figure><p>上面示例中，<code>malloc()</code> 可以根据变量 <code>n</code> 的不同，动态为数组分配不同的大小。</p><p>注意，<code>malloc()</code> 不会对所分配的内存进行初始化，里面还保存着原来的值。如果没有初始化，就是用这段内存，可能从里面读到以前的值。程序员要自己负责初始化。比如，字符串初始化可以使用 <code>strcpy()</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">4</span>);<br><span class="hljs-built_in">strcpy</span>(p, <span class="hljs-string">&quot;abc&quot;</span>);<br></code></pre></td></tr></table></figure><p>上面示例中，字符指针 <code>p</code> 指向一段4个字节的内存，<code>strcpy()</code> 将字符串 <code>&quot;abc&quot;</code> 拷贝放入这段内存，完成了这段内存的初始化。</p><h4 id="9-2-3-free"><a href="#9-2-3-free" class="headerlink" title="9.2.3 free()"></a>9.2.3 <code>free()</code></h4><p><code>free()</code> 用于释放 <code>malloc()</code> 函数分配的内存，将这块内存还给系统以便重新使用，否则这个内存块会一直占用到程序运行结束。该函数的原型定义在头文件 <code>stdlib.h</code> 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span>;<br></code></pre></td></tr></table></figure><p>功能：释放由 <code>malloc()、calloc()、realloc()</code> 申请的内存空间。</p><ul><li>几点注意：<ul><li>每个内存分配函数必须有相应的 <strong>free</strong> 函数，释放后不能再次使用被释放的内存。</li><li>在分配内存时最好不要直接用数字指定内存空间的大小，这样不利于程序的移植。因为在不同的操作系统中，同一数据类型的长度可能不一样。为了解决这个问题，<strong>C</strong> 语言提供了一个判断数据类型长度的操作符，就是 <strong>sizeof</strong>。</li><li><code>free(p)</code> 并不能改变指针 <strong>p</strong> 的值，<strong>p</strong> 依然指向以前的内存，为了防止再次使用该内存，建议将 <strong>p</strong> 的值手动置为 <strong>NULL</strong>。</li></ul></li></ul><p>上述代码中，<code>free()</code> 的参数是 <code>malloc()</code> 返回的内存地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><br>*p = <span class="hljs-number">12</span>;<br><span class="hljs-built_in">free</span>(p);<br></code></pre></td></tr></table></figure><p>注意，分配的内存块一旦释放，就不应该再次操作已经释放的地址，也不应该再次使用 <code>free()</code> 对该地址释放第二次。</p><p>一个很常见的错误是，在函数内部分配了内存，但是函数调用结束时，没有使用 <code>free()</code> 释放内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">gobble</span><span class="hljs-params">(<span class="hljs-type">double</span> arr[], <span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-type">double</span>* temp = (<span class="hljs-type">double</span>*)<span class="hljs-built_in">malloc</span>(n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>));<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面示例中，函数 <code>gobble()</code> 内部分配了内存，但是没有写 <code>free(temp)</code>。这会造成函数运行结束后，占用的内存块依然保留，如果多次调用 <code>gobble()</code>，就会留下多个内存块。并且，由于指针 <code>temp</code> 已经消失了，也无法访问这些内存块，再次使用。</p><p><strong>sizeof</strong> 是一个单目操作符，不是函数，用以获取数据类型的长度时必须加括号，例如 <code>sizeof(int)、sizeof(char)</code> 等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N  5</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N1 7</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N2 3 </span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> *ip;<br>    <span class="hljs-type">int</span> *large_ip;<br>    <span class="hljs-type">int</span> *small_ip<span class="hljs-number">&#x27;</span><br>    <span class="hljs-keyword">if</span>((ip = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(N * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))) == <span class="hljs-literal">NULL</span>)    <span class="hljs-comment">//if-else</span><br>    &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;memory allocated failed!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;  <br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    &#123;<br>ip[i] = i;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ip[%d] = %d\t&quot;</span>, i, ip[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span>((large_ip = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">realloc</span>(ip, N1 * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))) == <span class="hljs-literal">NULL</span>)<br>    &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;memory allocated failed!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i = N; i &lt; N1; i++)<br>    large_ip[i] = <span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N1; i++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;large_ip[%d] = %d\t&quot;</span>, i, large_ip[i]);<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);   <br>    <br>    <span class="hljs-keyword">if</span>((small_ip = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">realloc</span>(large_ip, N2 * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))) == <span class="hljs-literal">NULL</span>)<br>    &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;memory allocated failed!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; N2; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;small_ip[%d] = %d\t&quot;</span>, i, small_ip[i]);<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);   <br><span class="hljs-built_in">free</span>(small_ip);<br>    small_ip = <span class="hljs-literal">NULL</span>;<br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 输出结果 */</span><br>ip[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>    ip[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>    ip[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>    ip[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>    ip[<span class="hljs-number">4</span>] = <span class="hljs-number">4</span><br>large_ip[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>    large_ip[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>    large_ip[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>    large_ip[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>    large_ip[<span class="hljs-number">4</span>] = <span class="hljs-number">4</span>    large_ip[<span class="hljs-number">5</span>] = <span class="hljs-number">9</span>    large_ip[<span class="hljs-number">6</span>] = <span class="hljs-number">9</span><br>small_ip[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>    small_ip[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>    small_ip[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><ul><li>首先分配一个包含 <strong>5</strong> 个整型的内存区域，分别赋值 <strong>0</strong> 到 <strong>4</strong>；再用 <strong>realloc</strong> 函数扩大内存区域以容纳 <strong>7</strong> 个整型数，对额外的两个整数赋值为 <strong>9</strong>；最后再用 **realloc **函数缩小内存区域，直接输出结果（因为 <strong>realloc</strong> 函数会自动复制数据）。</li><li>这次把分配函数与验证返回值验证写在了一起，为的是书写方便，考虑到优先级问题添加了适当的括号，这种写法较为常用，注意学习使用。</li><li>本例 <strong>free</strong> 函数只用释放 <strong>small_ip</strong> 指针即可，如函数介绍中注意里提到的，另外两个指针已被系统回收，不能再次使用。</li></ul><h4 id="9-2-4-calloc"><a href="#9-2-4-calloc" class="headerlink" title="9.2.4 calloc()"></a>9.2.4 <code>calloc()</code></h4><p><code>calloc()</code> 函数作用与 <code>malloc()</code> 相似，也是分配内存块。该函数原型定义在头文件 <code>stdlib.h</code>。<code>calloc()</code> 函数是对 <code>malloc()</code> 函数的简单封装，参数不同，使用时务必小心，第一参数是第二参数的单元个数，第二参数是单位的字节数。</p><p>两者的区别主要有两点：</p><p>（1）<code>calloc()</code> 接受两个参数，第一个参数是某种数据类型的值的数量，第二个参数是该数据类型的单位字节长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">calloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><p>功能：在堆区分配 <code>n*size</code> 字节的连续空间。</p><p>返回值：成功返回分配的内存地址 void 指针，失败则返回 <strong>NULL</strong>。</p><p>（2）<code>calloc()</code> 会将所分配的内存全部初始化为 <code>0</code>。<code>malloc()</code> 不会对内存进行初始化，如果想要初始化为 <code>0</code>，还要额外调用 <code>memset()</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">10</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">10</span>);<br><span class="hljs-built_in">memset</span>(p, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>上面示例中，<code>calloc()</code> 相当于 <code>malloc() + memset()</code>。<code>calloc()</code> 分配的内存块，也要使用 <code>free()</code> 释放。</p><h4 id="9-2-5-realloc"><a href="#9-2-5-realloc" class="headerlink" title="9.2.5 realloc()"></a>9.2.5 <code>realloc()</code></h4><p><code>realloc()</code> 函数用于修改已经分配的内存块的大小，可以放大也可以缩小，返回一个指向新的内存块的指针。如果分配不成功，返回 <code>NULL</code>，该函数原型定义在头文件 <code>stdlib.h</code> 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> *block, <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><p>它接受两个参数。</p><ul><li><code>block</code>：已经分配好的内存块指针（由 <code>malloc()</code> 或 <code>calloc()</code> 或 <code>realloc()</code> 产生）。</li><li><code>size</code>：该内存块的新大小，单位为字节。</li></ul><p><code>realloc()</code> 可能返回一个全新的地址（数据也会自动复制过去），也可能返回跟原来一样的地址。<code>realloc()</code> 优先在原有内存块上进行缩减，尽量不移动数据，所以通常是返回原先的地址。如果新内存块小于原来的大小，则丢弃超出的部分；如果大于原来的大小，则不对新增的部分进行初始化（程序员可以自动调用 <code>memset()</code>）。</p><p>下面示例中，<code>b</code> 是数组指针，<code>realloc()</code> 动态调整它的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* b;<br>b = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">100</span>);<br>b = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">realloc</span>(b, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>上面示例中，指针 <code>b</code> 原来指向100个成员的整数数组，使用 <code>realloc()</code> 调整为2000个成员的数组，这就是手动分配数组内存的好处，就可以在运行时随时调整数组的长度。</p><p><code>realloc()</code> 第一个参数可以是 <code>NULL</code>，这时相当于新建一个指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* p = <span class="hljs-built_in">realloc</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">3490</span>);<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-type">char</span>* p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">3490</span>);<br></code></pre></td></tr></table></figure><p>如果 <code>realloc()</code> 第二个参数是 <code>0</code>，就会释放掉内存块。由于有分配失败的可能，所以调用 <code>realloc()</code> 以后，最好检查返回值是否为 <code>NULL</code>。分配失败时，原有内存块中的数据不会发生变化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span>* new_p = <span class="hljs-built_in">realloc</span>(p, <span class="hljs-keyword">sizeof</span>(*p * <span class="hljs-number">40</span>));<br><br><span class="hljs-keyword">if</span>(new_p == <span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：<code>realloc()</code> 不会对内存进行初始化。</p><h4 id="9-2-6-restrict-说明符"><a href="#9-2-6-restrict-说明符" class="headerlink" title="9.2.6 restrict 说明符"></a>9.2.6 restrict 说明符</h4><p>声明指针变量时。可以使用 <code>restrict</code> 说明符，告诉编译器，该块内存区域只有当前指针一种访问方式，其他指针不能读写该块内存。这种指针称为“受限指针”（restrict pointer）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* <span class="hljs-keyword">restrict</span> p;<br>p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br></code></pre></td></tr></table></figure><p>上面示例中，声明指针变量 <code>p</code> 时，加入了 <code>restrict</code> 说明符，使得 <code>p</code> 变成了受限指针。后面，当 <code>p</code> 指向 <code>malloc()</code> 函数返回的一块内存区域，就意味着，该区域只有通过 <code>p</code> 来访问，不存在其他访问方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* <span class="hljs-keyword">restrict</span> p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-type">int</span>* q = p;<br>*p = <span class="hljs-number">0</span>;<span class="hljs-comment">// 未定义行为</span><br></code></pre></td></tr></table></figure><p>上面示例中，另一个指针 <code>q</code> 与受限指针 <code>p</code> 指向同一块内存，现在该内存有 <code>p</code> 和 <code>q</code> 两种访问方式。这就违反了对编译器的承诺，后面通过 <code>*q</code> 对该内存区域赋值，会导致未定义行为。</p><h4 id="9-2-7-memcpy"><a href="#9-2-7-memcpy" class="headerlink" title="9.2.7 memcpy()"></a>9.2.7 <code>memcpy()</code></h4><p><code>memcpy()</code> 用于将一块内存拷贝到另一块内存，该函数的原型定义在头文件 <code>string.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">memcpy</span><span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-type">void</span>* <span class="hljs-keyword">restrict</span> dest,</span><br><span class="hljs-params"><span class="hljs-type">void</span>* <span class="hljs-keyword">restrict</span> source,</span><br><span class="hljs-params"><span class="hljs-type">size_t</span> n</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>上面代码中，<code>dest</code> 是目标地址，<code>source</code> 是源地址，第三个参数 <code>n</code> 是要拷贝的字节数 <code>n</code>。如果要拷贝10个 double 类型的数组成员，<code>n</code> 就等于 <code>10 * sizeof(double)</code>，而不是 <code>10</code>。该函数会将从 <code>source</code> 开始的 <code>n</code> 个字节，拷贝到 <code>dest</code>。</p><p><code>dest</code> 和 <code>source</code> 都是 void 指针，表示这里不限制指针类型，各种类型的内存数据都可以拷贝。两者都有 restrict 关键字，表示这两个内存块不应该有互相重叠的区域。</p><p><code>memcpy()</code> 返回值是第一个参数，即目标地址的指针。</p><p>因为 <code>memcpy()</code> 只是将一段内存的值，复制到另一段内存，所以不需要知道内存里面的数据是什么类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br><span class="hljs-type">char</span> s[] = <span class="hljs-string">&quot;happy&quot;</span>;<br><span class="hljs-type">char</span> t[<span class="hljs-number">100</span>];<br><br><span class="hljs-built_in">memcpy</span>(t, s, <span class="hljs-keyword">sizeof</span>(s)); <span class="hljs-comment">// 拷贝6个字节，包括string终止符</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, t);<span class="hljs-comment">// happy</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面示例中，字符串 <code>s</code> 所在的内存，被拷贝到字符数组 <code>t</code> 所在的内存。</p><p><code>memcpy()</code> 可以取代 <code>strcpy()</code> 进行字符串拷贝，而且是更好的办法，不仅更安全，速度也更快，不检查字符串尾部的 <code>\0</code> 字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* s = <span class="hljs-string">&quot;hello world&quot;</span>;<br><br><span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(s) + <span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> *c = <span class="hljs-built_in">malloc</span>(len);<br><br><span class="hljs-keyword">if</span>(c) &#123;<br><span class="hljs-comment">// strcpy() 的写法</span><br><span class="hljs-built_in">strcpy</span>(c, s);<br><br><span class="hljs-comment">// memcpy() 的写法</span><br><span class="hljs-built_in">memcpy</span>(c, s, len);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面示例中，两种写法效果完全一样，但是 <code>memcpy()</code> 写法要好于 <code>strcpy()</code>。</p><p>使用 void 指针，也可以自定义一个复制内存的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">my_memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span>* dest, <span class="hljs-type">void</span>* src, <span class="hljs-type">int</span> byte_count)</span> &#123;<br><span class="hljs-type">char</span>* s = src;<br><span class="hljs-type">char</span>* d = dest;<br><br><span class="hljs-keyword">while</span>(byte_count--) &#123;<br>*d++ = *s++;<br>&#125;<br><span class="hljs-keyword">return</span> dest;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面示例中，不管传入的 <code>dest</code> 和 <code>src</code> 是什么类型的指针，将它们重新定义成一字节的 Char 指针，就可以逐字节进行复制。<code>*d++ = *s++</code> 语句相当于先执行 <code>*d = *s</code>（源字节的值复制给目标字节），然后各自移动到下一个字节。最后返回复制后的 <code>dest</code> 指针，便于后续使用。</p><h4 id="9-2-8-memmove"><a href="#9-2-8-memmove" class="headerlink" title="9.2.8 memmove()"></a>9.2.8 <code>memmove()</code></h4><p><code>memmove()</code> 函数用于将一段内存数据复制到另一段内存。它跟 <code>memcpy</code> 的主要区别是，它允许目标区域与源区域有重叠。如果发生重叠，源区域的内容会被更改；如果没有重叠，与 <code>memcpy</code> 行为相同。该函数原型定义在 <code>string.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">memmove</span> <span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-type">void</span>* dest,</span><br><span class="hljs-params"><span class="hljs-type">void</span>* source,</span><br><span class="hljs-params"><span class="hljs-type">size_t</span> n</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>上述代码中，<code>dest</code> 是目标地址，<code>source</code> 是源地址，<code>n</code> 是要移动的字节数。<code>dest</code> 和 <code>source</code> 都是 void 指针，表示可以移动任何类型的内存数据，两个内存区域可以有重叠。<code>memmove</code> 返回值是第一个参数，即目标地址的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>];<br><br>memmove(&amp;a[<span class="hljs-number">0</span>], &amp;a[<span class="hljs-number">1</span>], <span class="hljs-number">99</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br></code></pre></td></tr></table></figure><p>上述示例中，从数组成员 a[1] 开始的99个成员，都要向前移动一个位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> x[] = <span class="hljs-string">&quot;Home Sweet Home&quot;</span>;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, memmove(x, &amp;x[<span class="hljs-number">5</span>], <span class="hljs-number">10</span>));<span class="hljs-comment">// 输出 Sweet Home Home</span><br></code></pre></td></tr></table></figure><p>上述示例中，从字符串 <code>x</code> 的5号位置开始的10个字节，就是 <code>&quot;Sweet Home&quot;</code>，<code>memmove()</code> 将其前移到0号位置，所以输出为 <code>&quot;Sweet Home Home&quot;</code>。</p><h4 id="9-2-9-memcmp"><a href="#9-2-9-memcmp" class="headerlink" title="9.2.9 memcmp()"></a>9.2.9 <code>memcmp()</code></h4><p><code>memcmp()</code> 函数用来比较两个内存区域，函数原型定义在 <code>string.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">memcmp</span><span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">void</span>* s1;</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">void</span>* s2;</span><br><span class="hljs-params"><span class="hljs-type">size_t</span> n</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p><code>memcmp()</code> 有三个参数，前两个参数是用来比较的指针，第三个参数指定比较的字节数。其返回值是一个整数。</p><p>两块内存区域的每个字节以字符形式解读，按照字典顺序进行比较，如果两者相同，返回 <code>0</code>；如果 <code>s1</code> 大于 <code>s2</code>，返回大于0的整数；如果 <code>s1</code> 小于 <code>s2</code>，返回小于0的整数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* s1 = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">char</span>* s2 = <span class="hljs-string">&quot;acd&quot;</span>;<br><span class="hljs-type">int</span> r = <span class="hljs-built_in">memcmp</span>(s1, s2, <span class="hljs-number">3</span>);<span class="hljs-comment">// 小于 0</span><br></code></pre></td></tr></table></figure><p>上述示例中，比较 <code>s1</code> 和 <code>s2</code> 的前三个字节，由于 <code>s1</code> 小于 <code>s2</code>，所以 <code>r</code> 是一个小于0的整数，一般为-1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> s1[] = &#123;<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>&#125;;<br><span class="hljs-type">char</span> s2[] = &#123;<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>&#125;;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">memcmp</span>(s1, s2, <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>)<span class="hljs-comment">// true</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">memcmp</span>(s1, s2, <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>)<span class="hljs-comment">// true</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">memcmp</span>(s1, s2, <span class="hljs-number">7</span>) == <span class="hljs-number">0</span>)<span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><code>memcmp()</code> 可以比较内部带有字符串终止符 <code>\0</code> 的内存区域。</p><h2 id="10-malloc-函数背后的实现原理——内存池"><a href="#10-malloc-函数背后的实现原理——内存池" class="headerlink" title="10 malloc 函数背后的实现原理——内存池"></a>10 malloc 函数背后的实现原理——内存池</h2><p>相对于栈而言，堆这片内存面临着一个稍微复杂的行为模式：在任意时刻，程序可能发出请求，要么申请一段内存，要么释放一段已经申请过的内存，而且申请的大小从几个字节到几个 <strong>GB</strong> 都有可能，不能假设程序一次申请多少堆空间，因此，堆的管理显得较为复杂。</p><p>那么，使用 <code>malloc()</code> 在堆上分配内存到底是如何实现的呢？</p><p>一种做法是把 <code>malloc()</code> 的内存管理交给系统内核去做，既然内核管理着进程的地址空间，那么如果它提供一个系统调用，可以让 <code>malloc()</code> 使用这个系统调用去申请内存，不就可以了吗？当然这是一种理论上的做法，但实际上这样做的性能比较差，因为每次程序申请或者释放堆空间都要进行系统调用。知道系统调用的性能开销是比较大的，当程序对堆的操作比较频繁时，这样做的结果会严重影响程序的性能。</p><p>比较好的做法就是 <code>malloc()</code> 向操作系统申请一块适当大小的堆空间，然后由 <code>malloc()</code> 自己管理这块空间。</p><p><code>malloc()</code> 相当于向操作系统“批发”了一块较大的内存空间，然后 “零售” 给程序用。当全部 <code>“售完”</code> 或程序有大量的内存需求时，再根据实际需求向操作系统 <code>“进货”</code>。当然 <code>malloc()</code> 在向程序零售堆空间时，必须管理它批发来的堆空间，不能把同一块地址出售两次，导致地址的冲突。于是 <code>malloc()</code> 需要一个算法来管理堆空间，这个算法就是堆的分配算法。</p><p><code>malloc()</code> 和 <code>free()</code> 的分配算法<br>在程序运行过程中，堆内存从低地址向高地址连续分配，随着内存的释放，会出现不连续的空闲区域，如下图所示：</p><ul><li>已分配内存和空闲内存相间出现</li></ul><p><img src="/../image/c_pic/%E5%9B%BE9.1.png"></p><blockquote><p>带阴影的方框是已被分配的内存，白色方框是空闲内存或已被释放的内存。程序需要内存时，<code>malloc()</code> 首先遍历空闲区域，看是否有大小合适的内存块，如果有，就分配，如果没有，就向操作系统申请（发生系统调用）。为了保证分配给程序的内存的连续性，<code>malloc()</code> 只会在一个空闲区域中分配，而不能将多个空闲区域联合起来。</p></blockquote><p>内存块（包括已分配和空闲的）的结构类似于链表，它们之间通过指针连接在一起。在实际应用中，一个内存块的结构如下图所示：</p><p><img src="/../image/c_pic/%E5%9B%BE9.2.png"></p><p><strong>next</strong> 是指针，指向下一个内存块，<strong>used</strong> 用来表示当前内存块是否已被使用。这样，整个堆区就会形成如下图所示的链表：</p><ul><li>类似链表的内存管理方式</li></ul><p><img src="/../image/c_pic/%E5%9B%BE9.3.png"></p><p>现在假设需要为程序分配 <strong>100</strong> 个字节的内存，当搜索到图中第一个空闲区域（大小为 <strong>200</strong> 个字节）时，发现满足条件，那么就在这里分配。这时候 <code>malloc()</code> 会把第一个空闲区域拆分成两部分，一部分交给程序使用，剩下的部分任然空闲，如下图所示：</p><ul><li>为程序分配 <strong>100</strong> 个字节的内存</li></ul><p><img src="/../image/c_pic/%E5%9B%BE9.4.png"></p><p>仍然以图 3 为例，当程序释放掉第三个内存块时，就会形成新的空闲区域，<code>free()</code> 会将第二、三、四个连续的空闲区域合并为一个，如下图所示：</p><ul><li>释放第三个内存块</li></ul><p><img src="/../image/c_pic/%E5%9B%BE9.5.png"></p><p>可以看到，<code>malloc()</code> 和 <code>free()</code> 所做的工作主要是对已有内存块的分拆和合并，并没有频繁地向操作系统申请内存，这大大提高了内存分配的效率。</p><p>另外，由于单向链表只能向一个方向搜索，在合并或拆分内存块时不方便，所以大部分 <code>malloc()</code> 实现都会在内存块中增加一个 <strong>pre</strong> 指针指向上一个内存块，构成双向链表，如下图所示：</p><p><img src="/../image/c_pic/%E5%9B%BE9.6.png"></p><p>链表是一种经典的堆内存管理方式，经常被用在教学中，很多 <strong>C</strong> 语言教程都会提到“栈内存的分配类似于数据结构中的栈，而堆内存的分配却类似于数据结构中的链表”就是源于此。</p><p>链表式内存管理虽然思路简单，容易理解，但存在很多问题，例如：</p><ul><li><p>一旦链表中的 <strong>pre</strong> 或 <strong>next</strong> 指针被破坏，整个堆就无法工作，而这些数据恰恰很容易被越界读写所接触到。</p></li><li><p>小的空闲区域往往不容易再次分配，形成很多内存碎片。</p></li><li><p>经常分配和释放内存会造成链表过长，增加遍历的时间。</p></li></ul><p>针对链表的缺点，后来人们提出了位图和对象池的管理方式，而现在的 <code>malloc()</code> 往往采用多种方式复合而成，不同大小的内存块往往采用不同的措施，以保证内存分配的安全和效率。</p><h3 id="10-1-内存池"><a href="#10-1-内存池" class="headerlink" title="10.1 内存池"></a>10.1 内存池</h3><p>不管具体的分配算法是怎样的，为了减少系统调用，减少物理内存碎片，<code>malloc()</code> 的整体思想是先向操作系统申请一块大小适当的内存，然后自己管理，这就是内存池<strong>（Memory Pool）</strong>。</p><p>内存池的研究重点不是向操作系统申请内存，而是对已申请到的内存的管理，这涉及到非常复杂的算法，是一个永远也研究不完的课题，除了C标准库自带的 **malloc()**，还有一些第三方的实现，比如 <strong>Goolge</strong> 的 <strong>tcmalloc</strong> 和 <strong>jemalloc</strong>。</p><p><strong>C&#x2F;C++</strong> 是编译型语言，没有内存回收机制，程序员需要自己释放不需要的内存，这在给程序带来了很大灵活性的同时，也带来了不少风险，例如<strong>C&#x2F;C++</strong> 程序经常会发生内存泄露，程序刚开始运行时占用内存很少，随着时间的推移，内存使用不断增加，导致整个计算机运行缓慢。</p><p>内存泄露的问题往往难于调试和发现，或者只有在特定条件下才会复现，这给代码修改带来了不少障碍。为了提高程序的稳定性和健壮性，后来的 <strong>Java、Python、C#、JavaScript、PHP</strong> 等使用了虚拟机机制的非编译型语言都加入了垃圾内存自动回收机制，这样程序员就不需要管理内存了，系统会自动识别不再使用的内存并把它们释放掉，避免内存泄露。可以说，这些高级语言在底层都实现了自己的内存池，也即有自己的内存管理机制</p><h3 id="10-2-池化技术"><a href="#10-2-池化技术" class="headerlink" title="10.2 池化技术"></a>10.2 池化技术</h3><p>在计算机中，有很多使用 <code>“池”</code> 这种技术的地方，除了内存池，还有连接池、线程池、对象池等。以服务器上的线程池为例，它的主要思想是：先启动若干数量的线程，让它们处于睡眠状态，当接收到客户端的请求时，唤醒池中某个睡眠的线程，让它来处理客户端的请求，当处理完这个请求，线程又进入睡眠状态。</p><p>所谓 <code>“池化技术”</code>，就是程序先向系统申请过量的资源，然后自己管理，以备不时之需。之所以要申请过量的资源，是因为每次申请该资源都有较大的开销，不如提前申请好了，这样使用时就会变得非常快捷，大大提高程序运行效率。</p><h2 id="11-野指针和非法内存操作"><a href="#11-野指针和非法内存操作" class="headerlink" title="11 野指针和非法内存操作"></a>11 野指针和非法内存操作</h2><p>如果一个指针指向的内存没有访问权限，或者指向一块已经释放掉的内存，那么就无法对该指针进行操作，这样的指针称为野指针（<strong>Wild Pointer</strong>）。</p><h3 id="11-1-指向没有访问权限的内存"><a href="#11-1-指向没有访问权限的内存" class="headerlink" title="11.1 指向没有访问权限的内存"></a>11.1 指向没有访问权限的内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> *str;<br>fgets(str, <span class="hljs-number">10</span>, <span class="hljs-built_in">stdin</span>);<br><span class="hljs-built_in">puts</span>(str);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 输出结果 */</span><br>ptr:&lt;error:cannot access memory at address <span class="hljs-number">0x1</span>&gt;    <br></code></pre></td></tr></table></figure><ul><li><strong>str</strong> 是局部变量，它的值是不确定的，是随机的，不知道指向哪块内存。一般情况下，这块内存要么没有访问权限，要么还没有分配，当 <code>fgets()</code> 函数试图将读取到的字符串写入这块内存时，必然会发生错误。<ul><li>当然，如果足够幸运的话，<strong>str</strong> 也可能恰好指向一段分配好的、并且有读写权限的内存，程序就运行成功，但这是小概率事件，一般不会发生。</li></ul></li></ul><h3 id="11-2-指向释放掉的内存"><a href="#11-2-指向释放掉的内存" class="headerlink" title="11.2 指向释放掉的内存"></a>11.2 指向释放掉的内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> *str = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));<br><span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;梓语慕晓&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(str);<br>    <span class="hljs-built_in">free</span>(str);<br>    <span class="hljs-keyword">if</span>(str)&#123;<br><span class="hljs-built_in">puts</span>(str);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 输出结果 */</span><br>梓语慕晓<br>ptr:&lt;error:cannot access memory at address <span class="hljs-number">0x1</span>&gt; <br></code></pre></td></tr></table></figure><p>运行程序，第一次输出 <code>梓语慕晓</code>，第二次输出的是乱码或者什么也不输出。这是因为，<code>freed()</code> 只是释放掉了动态分配的内存，但并未改变 <strong>str</strong> 的值，<strong>str</strong> 的值不是 <strong>NULL</strong>，它仍然指向被释放掉的内存，所以会执行 <strong>if</strong> 语句里面的 <code>puts()</code> 函数。但由于此时的内存已经被释放掉了，原来的字符串已经不在了，所以输出的数据是未知的。</p><ul><li>使用 <code>free()</code> 释放内存的同时要将指针置为 <strong>NULL</strong>，否则下次就无法判断指向的内存是否有效。</li></ul><p>还有一种情况是函数外部指针指向函数内部的变量、数组等，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">char</span> **pp)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> *pstr;<br>func(&amp;pstr);<br><span class="hljs-built_in">puts</span>(pstr);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">char</span> **pp)</span><br>&#123;<br><span class="hljs-type">char</span> arr[] = <span class="hljs-string">&quot;梓语慕晓&quot;</span>;<br>*pp = arr;<br>&#125;<br><span class="hljs-comment">/* 输出结果 */</span><br>未知<br></code></pre></td></tr></table></figure><p><strong>arr</strong> 数组在栈上分配内存，字符串 <code>&quot;梓语慕晓&quot;</code> 就存储在这里，<code>func()</code> 函数运行结束后，这块内存被释放掉，但是函数外部的 <strong>pstr</strong> 仍然指向这里，所以执行<code>puts(pstr); </code>时，输出结果是未知的。</p><h3 id="11-3-规避野指针"><a href="#11-3-规避野指针" class="headerlink" title="11.3 规避野指针"></a>11.3 规避野指针</h3><p>要想规避野指针，就要养成良好的编程习惯：</p><ul><li>指针变量如果暂时不需要赋值，一定要初始化为 <strong>NULL</strong>，因为任何指针变量刚被创建时不会自动成为 <strong>NULL</strong> 指针，它的缺省值是随机的。</li><li>当指针指向的内存被释放掉时，要将指针的值设置为 <strong>NULL</strong>，因为 <code>free()</code> 只是释放掉了内存，并为改变指针的值。</li></ul><h2 id="12-内存泄漏（内存丢失）"><a href="#12-内存泄漏（内存丢失）" class="headerlink" title="12 内存泄漏（内存丢失）"></a>12 内存泄漏（内存丢失）</h2><p>使用 <code>malloc()、calloc()、realloc()</code> 动态分配的内存，如果没有指针指向它，就无法进行任何操作，这段内存会一直被程序占用，直到程序运行结束由操作系统回收。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> *p = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));<br>    p = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">50</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));<br>    <span class="hljs-built_in">free</span>(p);<br>    p = <span class="hljs-literal">NULL</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该程序中，第一次分配 <strong>100</strong> 字节的内存，并将 p 指向它；第二次分配 <strong>50</strong> 字节的内存，依然使用 <strong>p</strong> 指向它。这就导致了一个问题，第一次分配的 <strong>100</strong> 字节的内存没有指针指向它了，而且也不知道这块内存的地址，所以就再也无法找回，也没法释放，这块内存就成了垃圾内存，虽然毫无用处，但依然占用资源，唯一的办法就是等程序运行结束后由操作系统回收。</p><p>这就是内存泄露（<strong>Memory Leak</strong>），可以理解为程序和内存失去了联系，再也无法对它进行任何操作。</p><p>内存泄漏形象的比喻是“操作系统可提供给所有程序使用的内存空间正在被某个程序榨干”，最终结果是程序运行时间越长，占用内存空间越来越多，最终用尽全部内存空间，整个系统崩溃。</p><p>再来看一种内存泄露的情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *pOld = (<span class="hljs-type">int</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) ); <br><span class="hljs-type">int</span> *pNew = (<span class="hljs-type">int</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) );<br></code></pre></td></tr></table></figure><p>这两段代码分别创建了一块内存，并且将内存的地址传给了指针 <strong>pOld</strong> 和 <strong>pNew</strong>。此时指针 <strong>pOld</strong> 和 <strong>pNew</strong> 分别指向两块内存。</p><p>如果接下来进行这样的操作：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">pOld</span><span class="hljs-operator">=</span>pNew<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>pOld</strong> 指针就指向了 <strong>pNew</strong> 指向的内存地址，这时候再进行释放内存操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">free</span>(pOld);<br></code></pre></td></tr></table></figure><p>此时释放的 <strong>pOld</strong> 所指向的内存空间就是原来 <strong>pNew</strong> 指向的，于是这块空间被释放掉了。但是 <strong>pOld</strong> 原来指向的那块内存空间还没有被释放，不过因为没有指针指向这块内存，所以这块内存就造成了丢失。</p><p>另外，你不应该进行类似这面这样的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) );<br></code></pre></td></tr></table></figure><p>这样的操作没有意义，因为没有指针指向分配的内存，无法使用，而且无法通过 <code>free()</code> 释放掉，造成了内存泄露。</p><h3 id="12-1-总结"><a href="#12-1-总结" class="headerlink" title="12.1 总结"></a>12.1 总结</h3><p><code>free()</code> 函数的用处在于实时地回收内存，如果程序很简单，程序结束之前也不会使用过多的内存，不会降低系统的性能，那么也可以不用写 <code>free()</code> 函数。当程序结束后，操作系统会释放内存。</p><p>但是如果在开发大型程序时不写 <code>free()</code> 函数，后果是很严重的。这是因为很可能在程序中要重复一万次分配 <strong>10MB</strong> 的内存，如果每次进行分配内存后都使用 <code>free()</code> 函数去释放用完的内存空间， 那么这个程序只需要使用 <strong>10MB</strong> 内存就可以运行。但是如果不使用 <code>free()</code> 函数，那么程序就要使用 <strong>100GB</strong> 的内存！这其中包括绝大部分的虚拟内存，而由于虚拟内存的操作需要读写磁盘，因此，这样会极大地影响到系统的性能，系统因此可能崩溃。</p><p>因此，在程序中使用 <code>malloc()</code> 分配内存时都对应地写出一个 <code>free()</code> 函数是一个良好的编程习惯。这不但体现在处理大型程序时的必要性，并能在一定程度上体现程序优美的风格和健壮性。</p><h2 id="13-变量的存储类别和生存期"><a href="#13-变量的存储类别和生存期" class="headerlink" title="13 变量的存储类别和生存期"></a>13 变量的存储类别和生存期</h2><p>变量是有数据类型的，用以说明它占用多大的内存空间，可以进行什么样的操作。</p><p>除了数据类型，变量还有一个属性，称为“存储类别”。存储类别就是变量在内存中的存放区域。在进程的地址空间中，常量区、全局数据区和栈区可以用来存放变量的值。</p><p>常量区和全局数据区的内存在程序启动时就已经由操作系统分配好，占用的空间固定，程序运行期间不再改变，程序运行结束后才由操作系统释放；它可以存放全局变量、静态变量、一般常量和字符串常量。</p><p>栈区的内存在程序运行期间由系统根据需要来分配（使用到变量才分配内存；如果定义了变量但没有执行到该代码，也不会分配内存），占用的空间实时改变，使用完毕后立即释放，不必等到程序运行结束；它可以存放局部变量、函数参数等。</p><p>可以通过 <strong>C</strong> 语言中的关键字来控制变量的存放区域。<strong>C</strong> 语言共有 4 个关键字用来指明变量的存储类别：<strong>auto</strong>（自动的）、<strong>static</strong>（静态的）、<strong>register</strong>（寄存器的）、<strong>extern</strong>（外部的）。</p><p>知道了变量的存储类别，就可以知道变量的生存期。通俗地讲，生存期指的是在程序运行过程中，变量从创建到销毁的一段时间，生存期的长短取决于变量的存储类别，也就是它所在的内存区域。</p><h3 id="13-1-auto-变量"><a href="#13-1-auto-变量" class="headerlink" title="13.1 auto 变量"></a>13.1 auto 变量</h3><p><strong>auto 是自动或默认的意思，很少用到，因为所有的变量默认就是 auto 的。</strong>也就是说，定义变量时加不加 auto 都一样，所以一般把它省略，不必多次一举。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span> <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br><span class="hljs-comment">/* 两者效果完全一样 */</span><br></code></pre></td></tr></table></figure><h3 id="13-2-static-变量"><a href="#13-2-static-变量" class="headerlink" title="13.2 static 变量"></a>13.2 static 变量</h3><p><strong>static</strong> 声明的变量称为静态变量，不管它是全局的还是局部的，都存储在静态数据区（全局变量本来就存储在静态数据区，即使不加 <strong>static</strong>）。</p><p>静态数据区的数据在程序启动时就会初始化，直到程序运行结束；对于代码块中的静态局部变量，即使代码块执行结束，也不会销毁。</p><p>注意：静态数据区的变量只能初始化（定义）一次，以后只能改变它的值，不能再被初始化，即使有这样的语句，也无效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> result, i;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>, i &lt; <span class="hljs-number">100</span>, i++)&#123;<br>result = sum(i);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1+2+3...+99+100 = %d\n&quot;</span>, result);<br>system(<span class="hljs-string">&quot;puase&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>result += n;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-comment">/* 运行结果 */</span><br><span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span>+...+<span class="hljs-number">99</span>+<span class="hljs-number">100</span> = <span class="hljs-number">5050</span><br></code></pre></td></tr></table></figure><p>在 <code>sum()</code> 中定义了一个静态局部变量 <strong>result</strong>，它存储在静态数据区，<code>sum()</code> 函数执行结束也不会销毁，下次调用继续有效。静态数据区的变量只能初始化一次，第一次调用 <code>sum()</code> 时已经对 <strong>result</strong> 进行了初始化，所以再次调用时就不会初始化了，也就是说 <code>static int result = 0;</code> 语句无效。</p><p>静态局部变量虽然存储在静态数据区，但是它的作用域仅限于定义它的代码块，<code>sum()</code> 中的 <strong>result</strong> 在函数外无效，与 <code>main()</code> 中的 <strong>result</strong> 不冲突，除了变量名一样，没有任何关系。</p><h3 id="13-3-register-变量"><a href="#13-3-register-变量" class="headerlink" title="13.3 register 变量"></a>13.3 register 变量</h3><p>一般情况下，变量的值是存储在内存中的，<strong>CPU</strong> 每次使用数据都要从内存中读取。如果有一些变量使用非常频繁，从内存中读取就会消耗很多时间，例如 <strong>for</strong> 循环中的增量控制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>&#123;<br><span class="hljs-comment">//some code </span><br>&#125;<br></code></pre></td></tr></table></figure><p>执行这段代码，<strong>CPU</strong> 为了获得 <strong>i</strong>，会读取 <strong>1000</strong> 次内存。</p><p>为了解决这个问题，可以将使用频繁的变量放在 <strong>CPU</strong> 的通用寄存器中，这样使用该变量时就不必访问内存，直接从寄存器中读取，大大提高程序的运行效率。</p><p>不过寄存器的数量是有限的，通常是把使用最频繁的变量定义为 register 的。</p><p>来看一个计算 <strong>π</strong> 的近似值的例子，求解的一个近似公式如下：</p><p><img src="/../image/c_pic/%E5%9B%BE11.1.gif"></p><p>为了提高精度，循环的次数越多越好，可以将循环的增量控制定义为寄存器变量，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;conio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> sign = <span class="hljs-number">1.0</span>, res = <span class="hljs-number">0</span>, ad = <span class="hljs-number">1.0</span>;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100000000</span>; i++)&#123;<br>res += ad;<br>sign =- sign;<br>ad = sign/(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>);<br>&#125;<br>res *= <span class="hljs-number">4</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pi is %f&quot;</span>, res);<br>getch();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 输出结果 */</span><br>pi is <span class="hljs-number">3.141593</span><br></code></pre></td></tr></table></figure><p>关于寄存器变量有以下事项需要注意：</p><ul><li><p>为寄存器变量分配寄存器是动态完成的，因此，只有局部变量和形式参数才能定义为寄存器变量。</p></li><li><p>局部静态变量不能定义为寄存器变量，因为一个变量只能声明为一种存储类别。</p></li><li><p>寄存器的长度一般和机器的字长一致，只有较短的类型如 <strong>int、char、short</strong> 等才适合定义为寄存器变量，诸如 <strong>double</strong> 等较大的类型，不推荐将其定义为寄存器类型。</p></li><li><p><strong>CPU</strong> 的寄存器数目有限，即使定义了寄存器变量，编译器可能并不真正为其分配寄存器，而是将其当做普通的 <strong>auto</strong> 变量来对待，为其分配栈内存。当然，有些优秀的编译器，能自动识别使用频繁的变量，如循环控制变量等，在有可用的寄存器时，即使没有使用 <strong>register</strong> 关键字，也自动为其分配寄存器，无须由程序员来指定。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SRAM、DRAM、PSRAM简介.md</title>
    <link href="/2023/08/22/SRAM%E3%80%81DRAM%E3%80%81PSRAM%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/08/22/SRAM%E3%80%81DRAM%E3%80%81PSRAM%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>计算机中一般包含 ROM、RAM、硬盘、光盘以及附带驱动器等。</p><h2 id="常用存储器分类"><a href="#常用存储器分类" class="headerlink" title="常用存储器分类"></a>常用存储器分类</h2><h3 id="数据易失性存储器"><a href="#数据易失性存储器" class="headerlink" title="数据易失性存储器"></a>数据易失性存储器</h3><p>数据易失性存储器，如 DRAM（Dynamic RAM：动态 RAM）、SRAM（Static RAM：静态 RAM），这类存储器读写速度较快，但掉电后数据会丢失，在 SoC 设计中通常被用作数据缓存、程序缓存；</p><h3 id="数据非易失性存储器"><a href="#数据非易失性存储器" class="headerlink" title="数据非易失性存储器"></a>数据非易失性存储器</h3><p>数据非易失性存储器，如 NAND、NOR Flash，这类存储器读写速度比较慢，但掉电后数据不会丢失，因此在 SoC 设计中可用作大数据的存储或程序的存储；</p><h3 id="新出现存储器"><a href="#新出现存储器" class="headerlink" title="新出现存储器"></a>新出现存储器</h3><p>新出现存储器，如 PSRAM（Pseudo SRAM）：伪静态随机存取器。具有 SRAM 的接口协议：给出地址、读写指令，就可实现数据存取；相比于 DRAM 的实现，不需要复杂的 Memory Controller 来控制内存单元去定期刷新数据，但它的内核架构确实 DRAM 架构；传统 SRAM 是由 6 个晶体管构成一个存储 Cell，而 PSRAM 是由 1 个晶体管 + 1 个电容构成一个存储 Cell，因此 SPRAM 可以实现较大的存储容量。</p><p>基于上述分析，PSRAM 相比传统存储器具有如下有点：</p><ol><li>更大的带宽：串行 PSRAM 通过八路串行接口对外互联，最高在 200MHz DDR（Double Date Rate）速率下，可实现超 3Gbps 的带宽传输；</li><li>更高的容量：目前可实现存储容量有：32M、64M、256M，这比市面上其他串行接口 RAM 容量大很多；</li><li>更低的成本：串行 PSRAM 采用 DRAM 架构，可有效压缩芯片体积，估串行 PSRAM 生成成本接近 DRM 成本；</li><li>更小的尺寸：串行 PSRAM 的低引脚数封装比传统的 RAM 存储相比，具有尺寸更小、成本更低等优势；</li><li>更广的应用：PSRAM 采用的是自行刷新的（Self-Refresh），不需要刷新电路即能保存内部存储的数据；DRAM 每隔一段时间，要刷新充电一次，否则内部的数据即会消失，因此 PSRAM 相比传统 RAM 会有更广的应用。</li></ol><h2 id="SRAM-和-DRAM-区别"><a href="#SRAM-和-DRAM-区别" class="headerlink" title="SRAM 和 DRAM 区别"></a>SRAM 和 DRAM 区别</h2><p>SRAM（静态 RAM）：静态随机存取存储器，不需要刷新。速度快、面积大。</p><p>DRAM（动态 RAM）：动态随机存取存储器，需要实时刷新保持数据，价格便宜，一般用于大容量产品。</p><p><img src="/../image/SRAM%E5%92%8CDRAM.png" alt="SRAM和DRAM电路图"></p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>SRAM 存储单元是交叉耦合的两个反相器（T1-T3和T2-T4），靠双稳态实现数据锁存，不需要刷新。</p><p>DRAM 存储单元是一个晶体管 + 一个电容，数据以电平为载体保存在电容上，因为电容会漏电，因此需要实时刷新。</p><h3 id="面积"><a href="#面积" class="headerlink" title="面积"></a>面积</h3><p>存储 1Bit 数据，SRAM 需要 6 个晶体管，DRAM 只需要 1 个晶体管 + 1 个电容。相同容量，SRAM 需要更多晶体管，SRAM 面积是 DRAM 的 4~5 倍，发热量也非常大，难以做成大容量的主存储器。</p><h3 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h3><p>芯片面积决定价格，同容量 SRAM 价格更贵。</p><h3 id="行列地址复用"><a href="#行列地址复用" class="headerlink" title="行列地址复用"></a>行列地址复用</h3><p>实际存储芯片内部是一个二维矩阵，按照行地址和列地址来定位访问的存储单元。</p><p>对于容量小的 SRAM，地址位宽不大，行地址、列地址同时输入。</p><p>对于容量大的 DRAM，地址位宽大，芯片引脚不够，需要行地址、列地址依次输入。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>SRAM 一般用于片内，作为 CPU、GPU 的 Cache，容量只有几十 K 到几十 M。DRAM 一般用于片外，作为系统 Memory。SRAM 速度比 DRAM 快。Cache 追求速度快所以选择用 SRAM，而内存追求容量所以选择能够在相同空间中存放更多内容并且造价相对低廉的 DRAM。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SRAM 优点：速度快，缺点难以做成大容量存储器。</p><p>DRAM 优点：用作大容量存储器，缺点没有 SRAM 速度快，且需要不断刷新电路来保存数据，否则内部数据将会消失，功耗相较于 SRAM 也更大一些。</p><h2 id="SDRAM-和-DDR、LPDDR"><a href="#SDRAM-和-DDR、LPDDR" class="headerlink" title="SDRAM 和 DDR、LPDDR"></a>SDRAM 和 DDR、LPDDR</h2><h3 id="SDRAM"><a href="#SDRAM" class="headerlink" title="SDRAM"></a>SDRAM</h3><p>SDRAM(Synchronous Dynamic RAM)：同步 DRAM，内核都是 1T + 1C 的存储单元，，因为其同步接口的特点，方便数据读取，广泛应用于内存场景。</p><blockquote><p>ASDRAM(Asynchronous Dynamic RAM)：异步 DRAM 不多见。</p></blockquote><p>通常 DRAM 为异步接口，可以随时响应控制输入的变化，而 SDRAM 为同步接口，与系统总时钟严格同步，其本质是为了提高读写速度。</p><p>SDRAM 是多 Bank 结构，而 DRAM 不分 Bank，这是两者结构上最大的不同点。</p><p>分 Bank 好处为：SDRAM 内部分成两个以上的 Bank，选中的 Bank 在进行读写时，没有被选中的 Bank 便可以预充电，做必要的准备工作。当下一个时钟周期选中它时，就无需等待而即可直接读取，大大提高了存储器的访问速度。</p><h3 id="DDR-系列"><a href="#DDR-系列" class="headerlink" title="DDR 系列"></a>DDR 系列</h3><p>DDR&#x2F;DDR2&#x2F;DDR3其全称应该是 DDR&#x2F;DDR2&#x2F;DDR3 SDRAM，说明它们都是在 SDRAM 下面分类，2&#x2F;3 代表了第几代，一般是频率提升、数据吞吐率提升的版本，应用于电脑内存条等场景。</p><p>DDR 的常见分类：</p><p><img src="/../image/DDR%E5%88%86%E7%B1%BB.png"></p><p>DDR2&#x2F;DDR3 接口示意图：</p><p><img src="/../image/DDR%E6%8E%A5%E5%8F%A3.png"></p><h3 id="LPDDR-系列"><a href="#LPDDR-系列" class="headerlink" title="LPDDR 系列"></a>LPDDR 系列</h3><p>LPDDR&#x2F;LPDDR2&#x2F;LPDDR3其全称应该是 LPDDR&#x2F;DDR2&#x2F;DDR3 SDRAM，也是 SDRAM 下面分类，LP(Lower Power)关注低功耗场景，一般应用于移动设备，如手机、Pad 等场景，这种设备上往往空间受限，因而接口 Pin 脚数量有限，接口较 DDR 有所简化。</p><p>LPDDR2 接口示意图：</p><p><img src="/../image/LPDDR%E6%8E%A5%E5%8F%A3.png"></p><h2 id="PSRAM-和-SPI-x2F-QPI-x2F-OPI-PSRAM"><a href="#PSRAM-和-SPI-x2F-QPI-x2F-OPI-PSRAM" class="headerlink" title="PSRAM 和 SPI&#x2F;QPI&#x2F;OPI PSRAM"></a>PSRAM 和 SPI&#x2F;QPI&#x2F;OPI PSRAM</h2><p>PSRAM(伪 SRAM) 其实也是 DRAM 一种，只不过是接口上伪装成了 SRAM 样子：给出地址、读、写命令，就可以实现存取，不需要 SDRAM 复杂的控制器和刷新机制，不需要地址拆分成行列地址。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://rohm.eefocus.com/article/id-2771">https://rohm.eefocus.com/article/id-2771</a></p>]]></content>
    
    
    <categories>
      
      <category>存储器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Ubuntu部署多节点k8s集群</title>
    <link href="/2023/08/11/%E5%9F%BA%E4%BA%8EUbuntu%E9%83%A8%E7%BD%B2%E5%A4%9A%E8%8A%82%E7%82%B9k8s%E9%9B%86%E7%BE%A4/"/>
    <url>/2023/08/11/%E5%9F%BA%E4%BA%8EUbuntu%E9%83%A8%E7%BD%B2%E5%A4%9A%E8%8A%82%E7%82%B9k8s%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<p>基于<strong>VirtualBox</strong>安装三台<strong>Ubuntu</strong>虚拟机，一台作为主节点，两台作为工作节点，创建K8s主机集群。</p><h2 id="1基础系统"><a href="#1基础系统" class="headerlink" title="1基础系统"></a>1基础系统</h2><ul><li>虚拟机系统：VirtualBox</li><li>虚拟机网卡：桥接模式</li><li>系统版本：Ubuntu 20.04.3 LTS，4核CPU+8G内存+100G磁盘</li></ul><h2 id="2拓扑结构"><a href="#2拓扑结构" class="headerlink" title="2拓扑结构"></a>2拓扑结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Bash">----------+------------------------------+------------------------------+----------<br>          |                              |                              | <br>   192.168.43.19                  192.168.43.98                  192.168.43.14<br>+---------+----------+         +---------+----------+        +---------+----------+          <br>|  [ k8s-master01 ]  |         |  [  k8s-node01  ]  |        |  [  k8s-node02  ]  |  <br>|    Master Node     |         |    Worker Node     |        |    Worker Node     |<br>+---------+----------+         +---------+----------+        +---------+----------+<br></code></pre></td></tr></table></figure><h2 id="3-ubuntu-换源"><a href="#3-ubuntu-换源" class="headerlink" title="3. ubuntu 换源"></a>3. ubuntu 换源</h2><blockquote><p>所有节点下均执行</p></blockquote><h3 id="3-1-更换-pip-源"><a href="#3-1-更换-pip-源" class="headerlink" title="3.1 更换 pip 源"></a>3.1 更换 pip 源</h3><p>在用户根目录创建文件夹 <code>.pip</code> ，添加配置文件 <code>pip.conf</code>。</p><p>创建文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> &amp;&amp; <span class="hljs-built_in">mkdir</span> .pip &amp;&amp; <span class="hljs-built_in">cd</span> .pip<br></code></pre></td></tr></table></figure><p>创建并编辑配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo vim pip.conf<br></code></pre></td></tr></table></figure><p><code>pip</code> 源配置如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[global]<br><span class="hljs-built_in">timeout</span> = 6000<br>index-url = http://mirrors.aliyun.com/pypi/simple/<br>trusted-host = mirrors.aliyun.com<br></code></pre></td></tr></table></figure><h3 id="3-2-更换-Ubuntu-源"><a href="#3-2-更换-Ubuntu-源" class="headerlink" title="3.2 更换 Ubuntu 源"></a>3.2 更换 Ubuntu 源</h3><p>备份源文件，再替换成阿里云的镜像源。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo <span class="hljs-built_in">mv</span> /etc/apt/sources.list /etc/apt/sources.list.bk<br></code></pre></td></tr></table></figure><p>设置镜像源。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Http">sudo vim /etc/apt/sources.list<br></code></pre></td></tr></table></figure><p>镜像源设置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Bash">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse<br><span class="hljs-comment"># deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="hljs-comment"># deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br>deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse<br></code></pre></td></tr></table></figure><p>更新镜像源。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt update<br></code></pre></td></tr></table></figure><h2 id="4基本环境配置"><a href="#4基本环境配置" class="headerlink" title="4基本环境配置"></a>4基本环境配置</h2><blockquote><p>所有节点下均执行</p></blockquote><h3 id="4-1设置主机名"><a href="#4-1设置主机名" class="headerlink" title="4.1设置主机名"></a>4.1设置主机名</h3><p>以<code>Master Node</code>节点为例，将<code>hostname</code>修改为<code>k8s-master01</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo hostnamectl set-hostname k8s-master01<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s<span class="hljs-comment"># cat /etc/hostname </span><br>k8s-master01<br></code></pre></td></tr></table></figure><p>添加所有节点网段配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s<span class="hljs-comment"># cat /etc/hosts</span><br>127.0.0.1  localhost<br>127.0.1.1  master01<br><br><span class="hljs-comment"># The following lines are desirable for IPv6 capable hosts</span><br>::1     ip6-localhost ip6-loopback<br>fe00::0 ip6-localnet<br>ff00::0 ip6-mcastprefix<br>ff02::1 ip6-allnodes<br>ff02::2 ip6-allrouters<br><br>192.168.43.19 k8s-master01<br>192.168.43.87 k8s-noed01<br>192.168.43.14 k8s-node02<br></code></pre></td></tr></table></figure><p>以下命令方便复制。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo hostnamectl set-hostname k8s-master01<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo hostnamectl set-hostname k8s-node01<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo hostnamectl set-hostname k8s-node02<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">192.168.43.19 k8s-master01<br>192.168.43.98  k8s-noed01<br>192.168.43.14 k8s-node02<br></code></pre></td></tr></table></figure><h3 id="4-2节点免密登录"><a href="#4-2节点免密登录" class="headerlink" title="4.2节点免密登录"></a>4.2节点免密登录</h3><p>安装<code>ssh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt-get -y install openssh-server<br></code></pre></td></tr></table></figure><p>启用<code>ssh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo systemctl <span class="hljs-built_in">enable</span> sshd<br>sudo systemctl restart sshd<br></code></pre></td></tr></table></figure><p>创建秘钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ssh-keygen -t rsa<br></code></pre></td></tr></table></figure><p>配置三节点互相登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo vi ~/.ssh/authorized_keys<br></code></pre></td></tr></table></figure><p>复制秘钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><p>master01</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCqcazSEZ8ttSzkq5A3otBUsorHtXmpz+e1bkulBWtQx5SNXmgVaEqMPchA1hSyLCE72mxfH+MtaNVmnnroVZm+k16X//Mx+JY6xOgLP+2L1SRjAEbZAOURybPkq/RzF6DBmPeY+dMwPuyK99ap5MjdOI3l4VpHrz76B1izCQVqcQh9fH69PSseuAA+eFIs+9FmdTp7e1qtsvdyuENOwpMPMM4P12vpy0+JMLs4KsAKZhpdz0N7UcnV5WBa6oQB+xFrHlWrmj1zRk5n7vuDOayiDEjfSqxE5PeGMt38l5Jj3VYpPPwWrSTBXF+UynjxBb5K4gY3Ic7gJyq+4/uhmCX69vpDCIjoF0Vp5allyYEEMjQ4RwNZK8H2K2kU3gG+lBmBuR/o+urS0hIY+ycNb8kys2MK5Sde/M7D/TwuoTTko8GmDic41NWoGQHINXixJEs/z0+LnEVf/IknShWw/zZdmEfDduoY4WPIr5RF9Afal718mvVFqMOIUMpzW/+eAHU= master01@k8s-master01<br></code></pre></td></tr></table></figure><p>node01</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDB1c+UOmoCQDAY1tUJovvsqLst9JN4KKuT1mQtrl2Yj8KXMwGmJCzwGvp9RggfQmd4vPr8KXX8/7c5Zz8qkh7+Yb/fEVSJdKfbUaGx5faFK9nbOpUCSLTI+eD5suOXFsKHhoY0jdW+M4GF1bF50QGOX1mwW/iOKH5aMI5sTb73Bgp78TwKy4Sr8e6O49jbL64B5yXK9tGD8W2Yomypy2tJVwzjLJA0tnGIpC+1oDR+jdxmP2jY9GiQ1eHt/x48xWxghQtv8bzZVURNqRICddc+iZnPV54x1aAzn/ey6tLx/paahuaBPOE6ADkmYvKcn9+oUaCt/ScM2YG5GuSp8TKhpjNYOgBhdtXVu6DFun5BsIr70LboCNtsBtGyn7gh88UskIT94cMXJZalfv20qSA0/mUIo378S6ARrdeHtjQ3zszvDDWQLL+q2usNcHiH8hzkImGt8p6/YQPIG0l41j7y5zzRcIgxwzvfg3/7Gj+Brmyn8wBUwF5QTpB2HPZCxqE= node01@k8s-node01<br></code></pre></td></tr></table></figure><p>node02</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCpEBky50rK4+ZDcM2zUA8SZ+zCUWeFrdnFAKnrIRiLwmDYsOXAuBBBWptNyTC/64bhjjdNkhnV683EB6MYJZxfHDe6FWHEkiQ6MOYCk/7tJkPvah7YWuDHvMgcW3wJzEEPPulrFtTxO7qyB9M/4+XfaAO5NC8eAZE/tnwM4xListB4D9aVRlCSRLagl5eJi+7gT4z+JuCSXj6/qDATwDGKbjUJvl0XP509N8wkvrQX+2qiokvwh8OJEbj2SZDGNp+B3dn6psT4i82qWAzAVhzaTmwyplIYC/Qvk5zABT/485YxN9hz+Wo3wI2xgPjdFIcyQG/ZVI3YzDyA+gXEHpScpVS1te1N1jq6QidbvwHjw8uKRXg08wPhJhP1F6QC9Ik89e2BsNpX9XCE5U/lL5NjtPjQ5PuaCYHdIYfbaypQOJxpD76BGhn6fSqjF/rJ5xXbWrIITwnRBYwovN+2q3ibtbNsM3G5Nx+9GRNenk9dwY1Vh5B/gwFUl61vROEkwEc= node02@k8s-node02<br></code></pre></td></tr></table></figure><h3 id="4-3-网络设置"><a href="#4-3-网络设置" class="headerlink" title="4.3 网络设置"></a>4.3 网络设置</h3><p>以<code>Master Node</code>节点为例，备份原有网络配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> /etc/netplan/<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo <span class="hljs-built_in">cp</span> 01-network-manager-all.yaml 01-network-manager-all.yaml.bk<br></code></pre></td></tr></table></figure><p>编辑网络配置文件<code>01-network-manager-all.yaml</code>，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo vi 01-network-manager-all.yaml<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:/etc/netplan<span class="hljs-comment"># cat 01-network-manager-all.yaml</span><br><span class="hljs-comment"># Let NetworkManager manage all devices on this system</span><br>network:<br>  version: 2<br>  renderer: NetworkManager<br>  ethernets:<br>    enp3s0:                           <span class="hljs-comment"># 配置的网卡名称,使用 ifconfig -a 查看得到</span><br>      dhcp4: no                       <span class="hljs-comment"># dhcp4 关闭</span><br>      addresses: [192.168.43.19/24]   <span class="hljs-comment"># 设置本机 IP 及掩码</span><br>      gateway4: 192.168.43.1          <span class="hljs-comment"># 设置网关</span><br>      nameservers:<br>        addresses: [114.114.114.114]  <span class="hljs-comment"># 设置DNS</span><br></code></pre></td></tr></table></figure><p>重启网卡。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo netplan apply<br></code></pre></td></tr></table></figure><h2 id="5安装步骤"><a href="#5安装步骤" class="headerlink" title="5安装步骤"></a>5安装步骤</h2><blockquote><p>所有节点下均执行</p></blockquote><p>更新系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt update &amp;&amp; sudo apt -y upgrade &amp;&amp; sudo systemctl reboot<br></code></pre></td></tr></table></figure><h3 id="5-1-关闭交换区"><a href="#5-1-关闭交换区" class="headerlink" title="5.1 关闭交换区"></a>5.1 关闭交换区</h3><p>安装 k8s 的必须环节，为什么要关？简单的说就是为了性能。</p><p>暂时关闭</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo swapoff -a<br>sudo sed -i <span class="hljs-string">&#x27;/ swap / s/^\(.*\)$/#\1/g&#x27;</span> /etc/fstab<br></code></pre></td></tr></table></figure><p>永久关闭</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo vi /etc/fstab<br><span class="hljs-comment">#注释掉 swap 一行</span><br><span class="hljs-comment">#/swap.img      none    swap    sw      0       0</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:/etc/netplan<span class="hljs-comment"># cat /etc/fstab </span><br><span class="hljs-comment"># /etc/fstab: static file system information.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Use &#x27;blkid&#x27; to print the universally unique identifier for a</span><br><span class="hljs-comment"># device; this may be used with UUID= as a more robust way to name devices</span><br><span class="hljs-comment"># that works even if disks are added and removed. See fstab(5).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span><br><span class="hljs-comment"># / was on /dev/sda5 during installation</span><br>UUID=b8643425-4b11-47ec-b18a-2330825b439c /               ext4    errors=remount-ro 0       1<br><span class="hljs-comment"># /boot/efi was on /dev/sda1 during installation</span><br>UUID=272D-DA69  /boot/efi       vfat    <span class="hljs-built_in">umask</span>=0077      0       1<br><span class="hljs-comment">#/swapfile                                 none            swap    sw              0       0</span><br></code></pre></td></tr></table></figure><p>查看是否关闭成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">free -hm<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:/etc/netplan<span class="hljs-comment"># free -hm</span><br>              total        used        free      shared  buff/cache   available<br>Mem:          7.8Gi       2.5Gi       1.3Gi        53Mi       4.0Gi       4.9Gi<br>Swap:            0B          0B          0B<br></code></pre></td></tr></table></figure><h3 id="5-2确保时区和时间正确"><a href="#5-2确保时区和时间正确" class="headerlink" title="5.2确保时区和时间正确"></a>5.2确保时区和时间正确</h3><p>设置时区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo timedatectl set-timezone Asia/Shanghai<br><br></code></pre></td></tr></table></figure><p>设置系统日志时间戳生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo systemctl restart rsyslog<br></code></pre></td></tr></table></figure><h3 id="5-3-关闭防火墙"><a href="#5-3-关闭防火墙" class="headerlink" title="5.3 关闭防火墙"></a>5.3 关闭防火墙</h3><p>关闭防火墙</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo ufw <span class="hljs-built_in">disable</span><br></code></pre></td></tr></table></figure><p>查看防火墙状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo ufw status<br></code></pre></td></tr></table></figure><p>或者按照下面方式关闭防火墙</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo systemctl stop ufw.service<br>sudo systemctl <span class="hljs-built_in">disable</span> ufw.service<br>sudo systemctl status ufw.service<br></code></pre></td></tr></table></figure><h3 id="5-4安装selinux"><a href="#5-4安装selinux" class="headerlink" title="5.4安装selinux"></a>5.4安装selinux</h3><p>安全增强式Linux是一个Linux内核的安全模块，其提供了访问控制安全策略机制，包括了强制访问控制。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt-get -y install policycoreutils<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt-get -y install selinux-utils<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt-get -y install selinux-basics<br></code></pre></td></tr></table></figure><p>初次启动配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo selinux-activate<br>reboot<br><br></code></pre></td></tr></table></figure><p>查看selinux状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sestatus<br></code></pre></td></tr></table></figure><p>修改selinux配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo setenforce 0<br>sudo sed -i <span class="hljs-string">&#x27;s#SELINUX=enforcing#SELINUX=disabled#g&#x27;</span> /etc/selinux/config<br>sudo sed -i <span class="hljs-string">&#x27;s#SELINUX=permissive#SELINUX=disabled#g&#x27;</span> /etc/selinux/config<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:/etc/netplan<span class="hljs-comment"># cat /etc/fstab </span><br><span class="hljs-comment"># /etc/fstab: static file system information.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Use &#x27;blkid&#x27; to print the universally unique identifier for a</span><br><span class="hljs-comment"># device; this may be used with UUID= as a more robust way to name devices</span><br><span class="hljs-comment"># that works even if disks are added and removed. See fstab(5).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span><br><span class="hljs-comment"># / was on /dev/sda5 during installation</span><br>UUID=b8643425-4b11-47ec-b18a-2330825b439c /               ext4    errors=remount-ro 0       1<br><span class="hljs-comment"># /boot/efi was on /dev/sda1 during installation</span><br>UUID=272D-DA69  /boot/efi       vfat    <span class="hljs-built_in">umask</span>=0077      0       1<br><span class="hljs-comment">#/swapfile                                 none            swap    sw              0       0</span><br>root@k8s-master01:/etc/netplan<span class="hljs-comment"># cat /etc/selinux/config </span><br><span class="hljs-comment"># This file controls the state of SELinux on the system.</span><br><span class="hljs-comment"># SELINUX= can take one of these three values:</span><br><span class="hljs-comment"># enforcing - SELinux security policy is enforced.</span><br><span class="hljs-comment"># permissive - SELinux prints warnings instead of enforcing.</span><br><span class="hljs-comment"># disabled - No SELinux policy is loaded.</span><br>SELINUX=disabled<br><span class="hljs-comment"># SELINUXTYPE= can take one of these two values:</span><br><span class="hljs-comment"># default - equivalent to the old strict and targeted policies</span><br><span class="hljs-comment"># mls     - Multi-Level Security (for military and educational use)</span><br><span class="hljs-comment"># src     - Custom policy built from source</span><br>SELINUXTYPE=default<br><br><span class="hljs-comment"># SETLOCALDEFS= Check local definition changes</span><br>SETLOCALDEFS=0<br></code></pre></td></tr></table></figure><p>重启系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">reboot<br></code></pre></td></tr></table></figure><h3 id="5-5设置内核参数"><a href="#5-5设置内核参数" class="headerlink" title="5.5设置内核参数"></a>5.5设置内核参数</h3><p>查看内核参数，确保 sysctl 配置中 net.bridge.bridge-nf-call-iptables 的值设置为了 1。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">lsmod | grep br_netfilter<br></code></pre></td></tr></table></figure><p>如果参数不一致，执行如下命令修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo modprobe overlay<br>sudo modprobe br_netfilter<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo <span class="hljs-built_in">tee</span> /etc/sysctl.d/kubernetes.conf&lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="hljs-string">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="hljs-string">net.ipv4.ip_forward = 1</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo sysctl --system<br></code></pre></td></tr></table></figure><h3 id="5-6安装ipvsadm"><a href="#5-6安装ipvsadm" class="headerlink" title="5.6安装ipvsadm"></a>5.6安装ipvsadm</h3><p>ipvsadm是LVS在应用层的管理命令，通过命令管理LVS的相关配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt install -y ipvsadm<br></code></pre></td></tr></table></figure><p>将相关的配置添加到配置文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo <span class="hljs-built_in">cat</span> &gt; /etc/modules-load.d/ipvs.conf &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">ip_vs_dh</span><br><span class="hljs-string">ip_vs_fo</span><br><span class="hljs-string">ip_vs_ftp</span><br><span class="hljs-string">ip_vs</span><br><span class="hljs-string">ip_vs_lblc</span><br><span class="hljs-string">ip_vs_lblcr</span><br><span class="hljs-string">ip_vs_lc</span><br><span class="hljs-string">ip_vs_mh</span><br><span class="hljs-string">ip_vs_nq</span><br><span class="hljs-string">ip_vs_ovf</span><br><span class="hljs-string">ip_vs_pe_sip</span><br><span class="hljs-string">ip_vs_rr</span><br><span class="hljs-string">ip_vs_sed</span><br><span class="hljs-string">ip_vs_sh</span><br><span class="hljs-string">ip_vs_wlc</span><br><span class="hljs-string">ip_vs_wrr</span><br><span class="hljs-string">nf_conntrack</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo systemctl <span class="hljs-built_in">enable</span> --now systemd-modules-load.service<br></code></pre></td></tr></table></figure><p>查看内核配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">lsmod | grep ip_vs<br></code></pre></td></tr></table></figure><h3 id="5-7重启系统"><a href="#5-7重启系统" class="headerlink" title="5.7重启系统"></a>5.7重启系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">reboot<br></code></pre></td></tr></table></figure><h3 id="5-8-docker安装"><a href="#5-8-docker安装" class="headerlink" title="5.8 docker安装"></a>5.8 docker安装</h3><p>配置Docker源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt-get update<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt-get install \<br>    apt-transport-https \<br>    ca-certificates \<br>    curl \<br>    gnupg \<br>    lsb-release<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<br></code></pre></td></tr></table></figure><p>向source.list 中添加Docker软件源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null<br></code></pre></td></tr></table></figure><p>安装Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt-get update<br>sudo apt-get install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><p>启动Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo systemctl <span class="hljs-built_in">enable</span> docker<br>sudo systemctl start docker.service<br></code></pre></td></tr></table></figure><p>验证Docker是否启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo docker image <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>配置Docker的daemon配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo <span class="hljs-built_in">tee</span> /etc/docker/daemon.json &lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="hljs-string">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="hljs-string">  &quot;log-opts&quot;: &#123;</span><br><span class="hljs-string">    &quot;max-size&quot;: &quot;100m&quot;</span><br><span class="hljs-string">  &#125;,</span><br><span class="hljs-string">  &quot;storage-driver&quot;: &quot;overlay2&quot;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><p>启动和使能Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo systemctl daemon-reload <br>sudo systemctl <span class="hljs-built_in">enable</span> docker.service --now<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><p>查看Docker状态和版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo systemctl status docker<br>docker --version<br></code></pre></td></tr></table></figure><h3 id="5-9-安装必要包"><a href="#5-9-安装必要包" class="headerlink" title="5.9 安装必要包"></a>5.9 安装必要包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt update<br>sudo apt install -y apt-transport-https curl gnupg2 software-properties-common ca-certificates net-tools<br></code></pre></td></tr></table></figure><h2 id="6安装Kubernetes-repository"><a href="#6安装Kubernetes-repository" class="headerlink" title="6安装Kubernetes repository"></a>6安装Kubernetes repository</h2><h3 id="6-1配置kubeadm-apt源"><a href="#6-1配置kubeadm-apt源" class="headerlink" title="6.1配置kubeadm apt源"></a>6.1配置kubeadm apt源</h3><blockquote><p>所有节点下均执行</p></blockquote><p>使用阿里云镜像源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">curl -s https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add - <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/kubernetes.list &lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><h3 id="6-2安装-kubelet-kubeadm-kubectl"><a href="#6-2安装-kubelet-kubeadm-kubectl" class="headerlink" title="6.2安装 kubelet kubeadm kubectl"></a>6.2安装 kubelet kubeadm kubectl</h3><blockquote><p>所有节点下均执行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get -y install kubelet=1.23.8-00<br>sudo apt-get -y install kubeadm=1.23.8-00<br>sudo apt-get -y install kubectl=1.23.8-00<br></code></pre></td></tr></table></figure><p>确保kubelet正常工作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo systemctl <span class="hljs-built_in">enable</span> kubelet.service<br>sudo systemctl status kubelet.service<br></code></pre></td></tr></table></figure><h3 id="6-3查看版本"><a href="#6-3查看版本" class="headerlink" title="6.3查看版本"></a>6.3查看版本</h3><blockquote><p>所有节点下均可执行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl version --client &amp;&amp; kubeadm version<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash">$ kubectl version --client &amp;&amp; kubeadm version<br>Client Version: version.Info&#123;Major:<span class="hljs-string">&quot;1&quot;</span>, Minor:<span class="hljs-string">&quot;22&quot;</span>, GitVersion:<span class="hljs-string">&quot;v1.22.1&quot;</span>, GitCommit:<span class="hljs-string">&quot;632ed300f2c34f6d6d15ca4cef3d3c7073412212&quot;</span>, GitTreeState:<span class="hljs-string">&quot;clean&quot;</span>, BuildDate:<span class="hljs-string">&quot;2021-08-19T15:45:37Z&quot;</span>, GoVersion:<span class="hljs-string">&quot;go1.16.7&quot;</span>, Compiler:<span class="hljs-string">&quot;gc&quot;</span>, Platform:<span class="hljs-string">&quot;linux/amd64&quot;</span>&#125;<br>kubeadm version: &amp;version.Info&#123;Major:<span class="hljs-string">&quot;1&quot;</span>, Minor:<span class="hljs-string">&quot;22&quot;</span>, GitVersion:<span class="hljs-string">&quot;v1.22.1&quot;</span>, GitCommit:<span class="hljs-string">&quot;632ed300f2c34f6d6d15ca4cef3d3c7073412212&quot;</span>, GitTreeState:<span class="hljs-string">&quot;clean&quot;</span>, BuildDate:<span class="hljs-string">&quot;2021-08-19T15:44:22Z&quot;</span>, GoVersion:<span class="hljs-string">&quot;go1.16.7&quot;</span>, Compiler:<span class="hljs-string">&quot;gc&quot;</span>, Platform:<span class="hljs-string">&quot;linux/amd64&quot;</span>&#125;<br><br>WARNING: This version information is deprecated and will be replaced with the output from kubectl version --short.  Use --output=yaml|json to get the full version.<br>Client Version: version.Info&#123;Major:<span class="hljs-string">&quot;1&quot;</span>, Minor:<span class="hljs-string">&quot;27&quot;</span>, GitVersion:<span class="hljs-string">&quot;v1.27.3&quot;</span>, GitCommit:<span class="hljs-string">&quot;25b4e43193bcda6c7328a6d147b1fb73a33f1598&quot;</span>, GitTreeState:<span class="hljs-string">&quot;clean&quot;</span>, BuildDate:<span class="hljs-string">&quot;2023-06-14T09:53:42Z&quot;</span>, GoVersion:<span class="hljs-string">&quot;go1.20.5&quot;</span>, Compiler:<span class="hljs-string">&quot;gc&quot;</span>, Platform:<span class="hljs-string">&quot;linux/amd64&quot;</span>&#125;<br>Kustomize Version: v5.0.1<br>kubeadm version: &amp;version.Info&#123;Major:<span class="hljs-string">&quot;1&quot;</span>, Minor:<span class="hljs-string">&quot;27&quot;</span>, GitVersion:<span class="hljs-string">&quot;v1.27.3&quot;</span>, GitCommit:<span class="hljs-string">&quot;25b4e43193bcda6c7328a6d147b1fb73a33f1598&quot;</span>, GitTreeState:<span class="hljs-string">&quot;clean&quot;</span>, BuildDate:<span class="hljs-string">&quot;2023-06-14T09:52:26Z&quot;</span>, GoVersion:<span class="hljs-string">&quot;go1.20.5&quot;</span>, Compiler:<span class="hljs-string">&quot;gc&quot;</span>, Platform:<span class="hljs-string">&quot;linux/amd64&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-4集群初始化"><a href="#6-4集群初始化" class="headerlink" title="6.4集群初始化"></a>6.4集群初始化</h3><blockquote><p>Master节点执行</p></blockquote><p><code>Master node root</code>下执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubeadm init \<br>--apiserver-advertise-address=192.168.43.19 \<br>--image-repository registry.aliyuncs.com/google_containers \<br>--kubernetes-version v1.23.8 \<br>--service-cidr=10.96.0.0/12 \<br>--pod-network-cidr=10.244.0.0/16 \<br>--ignore-preflight-errors=all<br></code></pre></td></tr></table></figure><p>指定apiserver的地址，指定master节点地址即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">--apiserver-advertise-address=192.168.43.19<br></code></pre></td></tr></table></figure><p>如果需要指定版本可以加入下面参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">--kubernetes-version v1.23.8<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:/home/master01/Desktop<span class="hljs-comment"># cd ~</span><br>root@k8s-master01:~<span class="hljs-comment"># kubeadm init \</span><br>&gt; --apiserver-advertise-address=192.168.43.19 \<br>&gt; --image-repository registry.aliyuncs.com/google_containers \<br>&gt; --kubernetes-version v1.23.8 \<br>&gt; --service-cidr=10.96.0.0/12 \<br>&gt; --pod-network-cidr=10.244.0.0/16 \<br>&gt; --ignore-preflight-errors=all<br>[init] Using Kubernetes version: v1.23.8<br>[preflight] Running pre-flight checks<br>  [WARNING SystemVerification]: this Docker version is not on the list of validated versions: 24.0.4. Latest validated version: 20.10<br>[preflight] Pulling images required <span class="hljs-keyword">for</span> setting up a Kubernetes cluster<br>[preflight] This might take a minute or two, depending on the speed of your internet connection<br>[preflight] You can also perform this action <span class="hljs-keyword">in</span> beforehand using <span class="hljs-string">&#x27;kubeadm config images pull&#x27;</span><br>[certs] Using certificateDir folder <span class="hljs-string">&quot;/etc/kubernetes/pki&quot;</span><br>[certs] Generating <span class="hljs-string">&quot;ca&quot;</span> certificate and key<br>[certs] Generating <span class="hljs-string">&quot;apiserver&quot;</span> certificate and key<br>[certs] apiserver serving cert is signed <span class="hljs-keyword">for</span> DNS names [k8s-master01 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 192.168.43.19]<br>[certs] Generating <span class="hljs-string">&quot;apiserver-kubelet-client&quot;</span> certificate and key<br>[certs] Generating <span class="hljs-string">&quot;front-proxy-ca&quot;</span> certificate and key<br>[certs] Generating <span class="hljs-string">&quot;front-proxy-client&quot;</span> certificate and key<br>[certs] Generating <span class="hljs-string">&quot;etcd/ca&quot;</span> certificate and key<br>[certs] Generating <span class="hljs-string">&quot;etcd/server&quot;</span> certificate and key<br>[certs] etcd/server serving cert is signed <span class="hljs-keyword">for</span> DNS names [k8s-master01 localhost] and IPs [192.168.43.19 127.0.0.1 ::1]<br>[certs] Generating <span class="hljs-string">&quot;etcd/peer&quot;</span> certificate and key<br>[certs] etcd/peer serving cert is signed <span class="hljs-keyword">for</span> DNS names [k8s-master01 localhost] and IPs [192.168.43.19 127.0.0.1 ::1]<br>[certs] Generating <span class="hljs-string">&quot;etcd/healthcheck-client&quot;</span> certificate and key<br>[certs] Generating <span class="hljs-string">&quot;apiserver-etcd-client&quot;</span> certificate and key<br>[certs] Generating <span class="hljs-string">&quot;sa&quot;</span> key and public key<br>[kubeconfig] Using kubeconfig folder <span class="hljs-string">&quot;/etc/kubernetes&quot;</span><br>[kubeconfig] Writing <span class="hljs-string">&quot;admin.conf&quot;</span> kubeconfig file<br>[kubeconfig] Writing <span class="hljs-string">&quot;kubelet.conf&quot;</span> kubeconfig file<br>[kubeconfig] Writing <span class="hljs-string">&quot;controller-manager.conf&quot;</span> kubeconfig file<br>[kubeconfig] Writing <span class="hljs-string">&quot;scheduler.conf&quot;</span> kubeconfig file<br>[kubelet-start] Writing kubelet environment file with flags to file <span class="hljs-string">&quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br>[kubelet-start] Writing kubelet configuration to file <span class="hljs-string">&quot;/var/lib/kubelet/config.yaml&quot;</span><br>[kubelet-start] Starting the kubelet<br>[control-plane] Using manifest folder <span class="hljs-string">&quot;/etc/kubernetes/manifests&quot;</span><br>[control-plane] Creating static Pod manifest <span class="hljs-keyword">for</span> <span class="hljs-string">&quot;kube-apiserver&quot;</span><br>[control-plane] Creating static Pod manifest <span class="hljs-keyword">for</span> <span class="hljs-string">&quot;kube-controller-manager&quot;</span><br>[control-plane] Creating static Pod manifest <span class="hljs-keyword">for</span> <span class="hljs-string">&quot;kube-scheduler&quot;</span><br>[etcd] Creating static Pod manifest <span class="hljs-keyword">for</span> <span class="hljs-built_in">local</span> etcd <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;/etc/kubernetes/manifests&quot;</span><br>[wait-control-plane] Waiting <span class="hljs-keyword">for</span> the kubelet to boot up the control plane as static Pods from directory <span class="hljs-string">&quot;/etc/kubernetes/manifests&quot;</span>. This can take up to 4m0s<br>[apiclient] All control plane components are healthy after 8.008385 seconds<br>[upload-config] Storing the configuration used <span class="hljs-keyword">in</span> ConfigMap <span class="hljs-string">&quot;kubeadm-config&quot;</span> <span class="hljs-keyword">in</span> the <span class="hljs-string">&quot;kube-system&quot;</span> Namespace<br>[kubelet] Creating a ConfigMap <span class="hljs-string">&quot;kubelet-config-1.23&quot;</span> <span class="hljs-keyword">in</span> namespace kube-system with the configuration <span class="hljs-keyword">for</span> the kubelets <span class="hljs-keyword">in</span> the cluster<br>NOTE: The <span class="hljs-string">&quot;kubelet-config-1.23&quot;</span> naming of the kubelet ConfigMap is deprecated. Once the UnversionedKubeletConfigMap feature gate graduates to Beta the default name will become just <span class="hljs-string">&quot;kubelet-config&quot;</span>. Kubeadm upgrade will handle this transition transparently.<br>[upload-certs] Skipping phase. Please see --upload-certs<br>[mark-control-plane] Marking the node k8s-master01 as control-plane by adding the labels: [node-role.kubernetes.io/master(deprecated) node-role.kubernetes.io/control-plane node.kubernetes.io/exclude-from-external-load-balancers]<br>[mark-control-plane] Marking the node k8s-master01 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]<br>[bootstrap-token] Using token: 5wad4u.6a8e0kvfx3flk44d<br>[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles<br>[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to get nodes<br>[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs <span class="hljs-keyword">in</span> order <span class="hljs-keyword">for</span> nodes to get long term certificate credentials<br>[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token<br>[bootstrap-token] configured RBAC rules to allow certificate rotation <span class="hljs-keyword">for</span> all node client certificates <span class="hljs-keyword">in</span> the cluster<br>[bootstrap-token] Creating the <span class="hljs-string">&quot;cluster-info&quot;</span> ConfigMap <span class="hljs-keyword">in</span> the <span class="hljs-string">&quot;kube-public&quot;</span> namespace<br>[kubelet-finalize] Updating <span class="hljs-string">&quot;/etc/kubernetes/kubelet.conf&quot;</span> to point to a rotatable kubelet client certificate and key<br>[addons] Applied essential addon: CoreDNS<br>[addons] Applied essential addon: kube-proxy<br><br>Your Kubernetes control-plane has initialized successfully!<br><br>To start using your cluster, you need to run the following as a regular user:<br><br>  <span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$HOME</span>/.kube<br>  sudo <span class="hljs-built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/config<br>  sudo <span class="hljs-built_in">chown</span> $(<span class="hljs-built_in">id</span> -u):$(<span class="hljs-built_in">id</span> -g) <span class="hljs-variable">$HOME</span>/.kube/config<br><br>Alternatively, <span class="hljs-keyword">if</span> you are the root user, you can run:<br><br>  <span class="hljs-built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf<br><br>You should now deploy a pod network to the cluster.<br>Run <span class="hljs-string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:<br>  https://kubernetes.io/docs/concepts/cluster-administration/addons/<br><br>Then you can <span class="hljs-built_in">join</span> any number of worker nodes by running the following on each as root:<br><br>kubeadm <span class="hljs-built_in">join</span> 192.168.43.19:6443 --token 5wad4u.6a8e0kvfx3flk44d \<br>  --discovery-token-ca-cert-hash sha256:a5f0a39a26cd9c2492b969a2d62cd013f1733110f72ffbc47b67806a1b0646b2 <br></code></pre></td></tr></table></figure><p>按照提示添加配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$HOME</span>/.kube<br>sudo <span class="hljs-built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/config<br>sudo <span class="hljs-built_in">chown</span> $(<span class="hljs-built_in">id</span> -u):$(<span class="hljs-built_in">id</span> -g) <span class="hljs-variable">$HOME</span>/.kube/config<br><span class="hljs-built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf<br></code></pre></td></tr></table></figure><p>查看所有Pod</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl get node,pod -A<br></code></pre></td></tr></table></figure><h3 id="6-5安装Flannel网络组件"><a href="#6-5安装Flannel网络组件" class="headerlink" title="6.5安装Flannel网络组件"></a>6.5安装Flannel网络组件</h3><blockquote><p>Master节点执行</p></blockquote><p>创建文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">mkdir</span> k8s &amp;&amp; <span class="hljs-built_in">cd</span> k8s<br></code></pre></td></tr></table></figure><p>下载组件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git <span class="hljs-built_in">clone</span> --depth 1 https://github.com/flannel-io/flannel.git<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git <span class="hljs-built_in">clone</span> https://github.com/flannel-io/flannel.git<br></code></pre></td></tr></table></figure><p>安装组件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl apply -f flannel/Documentation/kube-flannel.yml <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s<span class="hljs-comment"># kubectl apply -f flannel/Documentation/kube-flannel.yml </span><br>namespace/kube-flannel created<br>clusterrole.rbac.authorization.k8s.io/flannel created<br>clusterrolebinding.rbac.authorization.k8s.io/flannel created<br>serviceaccount/flannel created<br>configmap/kube-flannel-cfg created<br>daemonset.apps/kube-flannel-ds created<br></code></pre></td></tr></table></figure><p>再次查看pod</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl get pod -A<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s<span class="hljs-comment"># kubectl get pod -A</span><br>NAMESPACE      NAME                                   READY   STATUS    RESTARTS   AGE<br>kube-flannel   kube-flannel-ds-7t6w6                  1/1     Running   0          95s<br>kube-system    coredns-6d8c4cb4d-59tfm                1/1     Running   0          80m<br>kube-system    coredns-6d8c4cb4d-l7p2z                1/1     Running   0          80m<br>kube-system    etcd-k8s-master01                      1/1     Running   0          80m<br>kube-system    kube-apiserver-k8s-master01            1/1     Running   0          80m<br>kube-system    kube-controller-manager-k8s-master01   1/1     Running   0          80m<br>kube-system    **kube-proxy-dxghv**                       1/1     Running   0          80m<br>kube-system    kube-scheduler-k8s-master01            1/1     Running   0          80m<br></code></pre></td></tr></table></figure><p>或者使用下面命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl get pod -A -w<br></code></pre></td></tr></table></figure><p>配置<code>kube-proxy</code>开启IPVS模式，其中mode原来的值是空，默认为<code>iptables</code>模式，将其改为<code>ipvs</code>scheduler默认为空，默认负载均衡算法为轮训（Round Robin）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl edit configmap kube-proxy -n kube-system<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">42     kind: KubeProxyConfiguration<br>43     metricsBindAddress: <span class="hljs-string">&quot;&quot;</span><br>44     mode: <span class="hljs-string">&quot;ipvs&quot;</span><br>45     nodePortAddresses: null<br></code></pre></td></tr></table></figure><p>删除之前生成节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl delete pod -n kube-system kube-proxy-dxghv<br></code></pre></td></tr></table></figure><p>查看是否删除成功，删除后会自动重新生成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl get pod -A<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s<span class="hljs-comment"># kubectl get pod -A</span><br>NAMESPACE      NAME                                   READY   STATUS    RESTARTS   AGE<br>kube-flannel   kube-flannel-ds-7t6w6                  1/1     Running   0          18m<br>kube-system    coredns-6d8c4cb4d-59tfm                1/1     Running   0          97m<br>kube-system    coredns-6d8c4cb4d-l7p2z                1/1     Running   0          97m<br>kube-system    etcd-k8s-master01                      1/1     Running   0          98m<br>kube-system    kube-apiserver-k8s-master01            1/1     Running   0          98m<br>kube-system    kube-controller-manager-k8s-master01   1/1     Running   0          98m<br>kube-system    kube-proxy-dxghv                       1/1     Running   0          97m<br>kube-system    kube-scheduler-k8s-master01            1/1     Running   0          98m<br>root@k8s-master01:~/k8s<span class="hljs-comment"># kubectl get pod -A</span><br>NAMESPACE      NAME                                   READY   STATUS    RESTARTS   AGE<br>kube-flannel   kube-flannel-ds-7t6w6                  1/1     Running   0          20m<br>kube-system    coredns-6d8c4cb4d-59tfm                1/1     Running   0          99m<br>kube-system    coredns-6d8c4cb4d-l7p2z                1/1     Running   0          99m<br>kube-system    etcd-k8s-master01                      1/1     Running   0          99m<br>kube-system    kube-apiserver-k8s-master01            1/1     Running   0          99m<br>kube-system    kube-controller-manager-k8s-master01   1/1     Running   0          99m<br>kube-system    **kube-proxy-skhsx**                       1/1     Running   0          3s<br>kube-system    kube-scheduler-k8s-master01            1/1     Running   0          99m<br></code></pre></td></tr></table></figure><p>验证ipvs</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ipvsadm -Ln<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s<span class="hljs-comment"># ipvsadm -Ln</span><br>IP Virtual Server version 1.2.1 (size=4096)<br>Prot LocalAddress:Port Scheduler Flags<br>  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn<br>TCP  10.96.0.1:443 rr<br>  -&gt; 192.168.43.19:6443           Masq    1      0          1         <br>TCP  10.96.0.10:53 rr<br>  -&gt; 10.244.0.2:53                Masq    1      0          0         <br>  -&gt; 10.244.0.3:53                Masq    1      0          0         <br>TCP  10.96.0.10:9153 rr<br>  -&gt; 10.244.0.2:9153              Masq    1      0          0         <br>  -&gt; 10.244.0.3:9153              Masq    1      0          0         <br>UDP  10.96.0.10:53 rr<br>  -&gt; 10.244.0.2:53                Masq    1      0          0         <br>  -&gt; 10.244.0.3:53                Masq    1      0          0   <br></code></pre></td></tr></table></figure><p>查看logs</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl logs -n kube-system <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s<span class="hljs-comment"># kubectl logs -n kube-system kube-proxy-skhsx | grep ipvs</span><br>I0714 09:27:29.664158       1 server_others.go:269] <span class="hljs-string">&quot;Using ipvs Proxier&quot;</span><br>I0714 09:27:29.664174       1 server_others.go:271] <span class="hljs-string">&quot;Creating dualStackProxier for ipvs&quot;</span><br></code></pre></td></tr></table></figure><h3 id="6-6加入Worker节点"><a href="#6-6加入Worker节点" class="headerlink" title="6.6加入Worker节点"></a>6.6加入Worker节点</h3><blockquote><p>master节点执行</p></blockquote><p>查询<code>Worker node join</code>语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubeadm token create --print-join-command<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s<span class="hljs-comment"># kubeadm token create --print-join-command</span><br>kubeadm <span class="hljs-built_in">join</span> 192.168.43.19:6443 --token 0wh1qi.sw99kwy2agken4xe --discovery-token-ca-cert-hash sha256:a5f0a39a26cd9c2492b969a2d62cd013f1733110f72ffbc47b67806a1b0646b2 <br></code></pre></td></tr></table></figure><blockquote><p>Worker节点执行</p></blockquote><p>复制上面生成的命令，将Worker节点加入集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubeadm <span class="hljs-built_in">join</span> 192.168.43.19:6443 --token 0wh1qi.sw99kwy2agken4xe --discovery-token-ca-cert-hash sha256:a5f0a39a26cd9c2492b969a2d62cd013f1733110f72ffbc47b67806a1b0646b2 <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-node01:~<span class="hljs-comment"># kubeadm token create --print-join-command</span><br>failed to load admin kubeconfig: open /root/.kube/config: no such file or directory<br>To see the stack trace of this error execute with --v=5 or higher<br>root@k8s-node01:~<span class="hljs-comment"># kubeadm join 192.168.43.19:6443 --token 0wh1qi.sw99kwy2agken4xe --discovery-token-ca-cert-hash sha256:a5f0a39a26cd9c2492b969a2d62cd013f1733110f72ffbc47b67806a1b0646b2 </span><br>[preflight] Running pre-flight checks<br>  [WARNING SystemVerification]: this Docker version is not on the list of validated versions: 24.0.4. Latest validated version: 20.10<br>[preflight] Reading configuration from the cluster...<br>[preflight] FYI: You can look at this config file with <span class="hljs-string">&#x27;kubectl -n kube-system get cm kubeadm-config -o yaml&#x27;</span><br>W0717 10:01:58.970964    3137 utils.go:69] The recommended value <span class="hljs-keyword">for</span> <span class="hljs-string">&quot;resolvConf&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;KubeletConfiguration&quot;</span> is: /run/systemd/resolve/resolv.conf; the provided value is: /run/systemd/resolve/resolv.conf<br>[kubelet-start] Writing kubelet configuration to file <span class="hljs-string">&quot;/var/lib/kubelet/config.yaml&quot;</span><br>[kubelet-start] Writing kubelet environment file with flags to file <span class="hljs-string">&quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br>[kubelet-start] Starting the kubelet<br>[kubelet-start] Waiting <span class="hljs-keyword">for</span> the kubelet to perform the TLS Bootstrap...<br><br>This node has joined the cluster:<br>* Certificate signing request was sent to apiserver and a response was received.<br>* The Kubelet was informed of the new secure connection details.<br><br>Run <span class="hljs-string">&#x27;kubectl get nodes&#x27;</span> on the control-plane to see this node <span class="hljs-built_in">join</span> the cluster.<br></code></pre></td></tr></table></figure><blockquote><p>master节点执行</p></blockquote><p>查看Worker节点是否加入成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl get nodes<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s<span class="hljs-comment"># kubectl get nodes</span><br>NAME           STATUS     ROLES                  AGE     VERSION<br>k8s-master01   Ready      control-plane,master   2d18h   v1.23.8<br>k8s-node01     Ready      &lt;none&gt;                 10m     v1.23.8<br>k8s-node02     NotReady   &lt;none&gt;                 27s     v1.23.8<br>root@k8s-master01:~/k8s<span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><blockquote><p>若上述token和CA公钥的哈希值过期，可以在Master节点下重新生成</p></blockquote><p>  获取token</p><pre><code class="hljs"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubeadm token create<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s<span class="hljs-comment"># kubeadm token create</span><br>klj4mo.mkbgoe365gq4ifez<br></code></pre></td></tr></table></figure></code></pre><p>  获取CA公钥的哈希值</p><pre><code class="hljs"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openssl x509 -pubkey -<span class="hljs-keyword">in</span> /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed <span class="hljs-string">&#x27;s/^.* //&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s<span class="hljs-comment"># openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed &#x27;s/^.* //&#x27;</span><br>a5f0a39a26cd9c2492b969a2d62cd013f1733110f72ffbc47b67806a1b0646b2<br></code></pre></td></tr></table></figure></code></pre><h2 id="7创建deployment"><a href="#7创建deployment" class="headerlink" title="7创建deployment"></a>7创建deployment</h2><p>创建<code>yaml</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vi demo-app-deployment.yaml<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># demo-app-deployment.yaml</span><br>apiVersion: apps/v1<br>kind: Deployment<br>metadata:<br>  name: demo-app<br>  namespace: default<br>  labels:<br>    app: demo-app<br>spec:<br>  replicas: 1<br>  selector:<br>    matchLabels:<br>      app: demo-app<br>  template:<br>    metadata:<br>      labels:<br>        app: demo-app<br>    spec:<br>      containers:<br>      - name: demo-app<br>        imagePullPolicy: IfNotPresent<br>        image: docker.io/nginx:1.14.2<br>        ports:<br>        - protocol: TCP<br>          containerPort: 80<br>        lifecycle:<br>          postStart:<br>            <span class="hljs-built_in">exec</span>:<br>              <span class="hljs-built_in">command</span>: [<span class="hljs-string">&quot;/bin/bash&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;echo Demo Application&quot;</span>, $(<span class="hljs-built_in">date</span> +%Y-%m-%d_%H:%M:%S) &gt; /usr/share/nginx/html/index.html<span class="hljs-string">&quot;]</span><br></code></pre></td></tr></table></figure><p>加载<code>yaml</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl apply -f demo-app-deployment.yaml<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~<span class="hljs-comment"># kubectl apply -f demo-app-deployment.yaml</span><br>deployment.apps/demo-app created<br></code></pre></td></tr></table></figure><p>查看端口情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl get pod -o wide<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~<span class="hljs-comment"># kubectl get pod</span><br>NAME                        READY   STATUS    RESTARTS   AGE<br>demo-app-6c7476b8db-vfnkc   1/1     Running   0          3m21s<br>root@k8s-master01:~<span class="hljs-comment"># kubectl get pod -o wide</span><br>NAME                        READY   STATUS    RESTARTS   AGE     IP           NODE         NOMINATED NODE   READINESS GATES<br>demo-app-6c7476b8db-vfnkc   1/1     Running   0          3m30s   10.244.1.2   k8s-node01   &lt;none&gt;           &lt;none&gt;<br></code></pre></td></tr></table></figure><p>连接端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">curl 10.244.1.2<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~<span class="hljs-comment"># curl 10.244.1.2</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;<span class="hljs-built_in">head</span>&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br>&lt;style&gt;<br>    body &#123;<br>        width: 35em;<br>        margin: 0 auto;<br>        font-family: Tahoma, Verdana, Arial, sans-serif;<br>    &#125;<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;<br>&lt;p&gt;If you see this page, the nginx web server is successfully installed and<br>working. Further configuration is required.&lt;/p&gt;<br><br>&lt;p&gt;For online documentation and support please refer to<br>&lt;a href=<span class="hljs-string">&quot;http://nginx.org/&quot;</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;<br>Commercial support is available at<br>&lt;a href=<span class="hljs-string">&quot;http://nginx.com/&quot;</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;<br><br>&lt;p&gt;&lt;em&gt;Thank you <span class="hljs-keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ping 10.244.1.2<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~<span class="hljs-comment"># ping 10.244.1.2</span><br>PING 10.244.1.2 (10.244.1.2) 56(84) bytes of data.<br>64 bytes from 10.244.1.2: icmp_seq=1 ttl=63 time=1.02 ms<br>64 bytes from 10.244.1.2: icmp_seq=2 ttl=63 time=0.915 ms<br>^C<br>--- 10.244.1.2 ping statistics ---<br>2 packets transmitted, 2 received, 0% packet loss, time 1002ms<br>rtt min/avg/max/mdev = 0.915/0.967/1.019/0.052 ms<br></code></pre></td></tr></table></figure><h2 id="8创建Service"><a href="#8创建Service" class="headerlink" title="8创建Service"></a>8创建Service</h2><p>创建<code>yaml</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vi demo-app-service.yaml<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># demo-app-service.yaml</span><br>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: demo-app-service<br>spec:<br>  <span class="hljs-built_in">type</span>: NodePort<br>  selector:<br>    app: demo-app<br>  ports:<br>    - protocol: TCP<br>      port: 80<br></code></pre></td></tr></table></figure><p>加载<code>yaml</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl apply -f demo-app-service.yaml<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s<span class="hljs-comment"># kubectl get svc</span><br>NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE<br>kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   3d1h<br>root@k8s-master01:~/k8s<span class="hljs-comment"># ls</span><br>demo-app-service.yaml  flannel<br>root@k8s-master01:~/k8s<span class="hljs-comment"># kubectl apply -f demo-app-service.yaml </span><br>service/demo-app-service created<br>root@k8s-master01:~/k8s<span class="hljs-comment"># kubectl get svc</span><br>NAME               TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE<br>demo-app-service   NodePort    10.103.61.57   &lt;none&gt;        80:31182/TCP   3s<br>kubernetes         ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP        3d1h<br>root@k8s-master01:~/k8s<span class="hljs-comment"># curl 10.103.61.57</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;<span class="hljs-built_in">head</span>&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br>&lt;style&gt;<br>    body &#123;<br>        width: 35em;<br>        margin: 0 auto;<br>        font-family: Tahoma, Verdana, Arial, sans-serif;<br>    &#125;<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;<br>&lt;p&gt;If you see this page, the nginx web server is successfully installed and<br>working. Further configuration is required.&lt;/p&gt;<br><br>&lt;p&gt;For online documentation and support please refer to<br>&lt;a href=<span class="hljs-string">&quot;http://nginx.org/&quot;</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;<br>Commercial support is available at<br>&lt;a href=<span class="hljs-string">&quot;http://nginx.com/&quot;</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;<br><br>&lt;p&gt;&lt;em&gt;Thank you <span class="hljs-keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br>root@k8s-master01:~/k8s<span class="hljs-comment"># curl k8s-node02:31182</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;<span class="hljs-built_in">head</span>&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br>&lt;style&gt;<br>    body &#123;<br>        width: 35em;<br>        margin: 0 auto;<br>        font-family: Tahoma, Verdana, Arial, sans-serif;<br>    &#125;<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;<br>&lt;p&gt;If you see this page, the nginx web server is successfully installed and<br>working. Further configuration is required.&lt;/p&gt;<br><br>&lt;p&gt;For online documentation and support please refer to<br>&lt;a href=<span class="hljs-string">&quot;http://nginx.org/&quot;</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;<br>Commercial support is available at<br>&lt;a href=<span class="hljs-string">&quot;http://nginx.com/&quot;</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;<br><br>&lt;p&gt;&lt;em&gt;Thank you <span class="hljs-keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><blockquote><p>其中：80端口是clusterIP的端口，31182是所在NodePort的端口。</p></blockquote><h2 id="9安装Ingress控制器"><a href="#9安装Ingress控制器" class="headerlink" title="9安装Ingress控制器"></a>9安装Ingress控制器</h2><p>为了让 <a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress-controllers/">Ingress</a> 资源工作，集群必须有一个正在运行的 Ingress 控制器。Kubernetes 作为一个项目，目前支持和维护 AWS、 GCE 和 <a href="https://www.nginx.com/products/nginx-ingress-controller/">Nginx Ingress 控制器</a>。</p><p><a href="https://docs.nginx.com/nginx-ingress-controller/installation/installation-with-manifests/">官方安装教程</a></p><h3 id="9-1拉取代码"><a href="#9-1拉取代码" class="headerlink" title="9.1拉取代码"></a>9.1拉取代码</h3><p>克隆 NGINX 入口控制器存储库并更改为部署文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git <span class="hljs-built_in">clone</span> https://github.com/nginxinc/kubernetes-ingress.git<br><span class="hljs-built_in">cd</span> kubernetes-ingress/deployments<br></code></pre></td></tr></table></figure><h3 id="9-2配置-RBAC"><a href="#9-2配置-RBAC" class="headerlink" title="9.2配置 RBAC"></a>9.2配置 RBAC</h3><p>为 NGINX 入口控制器创建命名空间和服务帐户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl apply -f common/ns-and-sa.yaml<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s/kubernetes-ingress/deployments<span class="hljs-comment"># kubectl apply -f common/ns-and-sa.yaml</span><br>namespace/nginx-ingress created<br>serviceaccount/nginx-ingress created<br></code></pre></td></tr></table></figure><p>为服务帐户创建群集角色和群集角色绑定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl apply -f rbac/rbac.yaml<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s/kubernetes-ingress/deployments<span class="hljs-comment"># kubectl apply -f rbac/rbac.yaml</span><br>clusterrole.rbac.authorization.k8s.io/nginx-ingress created<br>clusterrolebinding.rbac.authorization.k8s.io/nginx-ingress created<br></code></pre></td></tr></table></figure><p>（仅限应用保护）创建应用保护角色和角色绑定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl apply -f rbac/ap-rbac.yaml<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s/kubernetes-ingress/deployments<span class="hljs-comment"># kubectl apply -f rbac/ap-rbac.yaml</span><br>clusterrole.rbac.authorization.k8s.io/nginx-ingress-app-protect created<br>clusterrolebinding.rbac.authorization.k8s.io/nginx-ingress-app-protect created<br><br></code></pre></td></tr></table></figure><p>（仅限应用程序保护 DoS）创建应用程序保护 DoS 角色和角色绑定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl apply -f rbac/apdos-rbac.yaml<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s/kubernetes-ingress/deployments<span class="hljs-comment"># kubectl apply -f rbac/apdos-rbac.yaml</span><br>clusterrole.rbac.authorization.k8s.io/nginx-ingress-app-protect-dos created<br>clusterrolebinding.rbac.authorization.k8s.io/nginx-ingress-app-protect-dos created<br></code></pre></td></tr></table></figure><h3 id="9-3创建公共资源"><a href="#9-3创建公共资源" class="headerlink" title="9.3创建公共资源"></a>9.3创建公共资源</h3><p>使用 TLS 证书和密钥为 NGINX 中的默认服务器创建一个密钥（下面假设您在 <code>kubernetes-ingress/deployment</code> 目录中）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl apply -f ../examples/shared-examples/default-server-secret/default-server-secret.yaml<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s/kubernetes-ingress/deployments<span class="hljs-comment"># kubectl apply -f ../examples/shared-examples/default-server-secret/default-server-secret.yaml</span><br>secret/default-server-secret created<br></code></pre></td></tr></table></figure><p>创建用于自定义 NGINX 配置的配置图：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl apply -f common/nginx-config.yaml<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s/kubernetes-ingress/deployments<span class="hljs-comment"># kubectl apply -f common/nginx-config.yaml</span><br>configmap/nginx-config created<br></code></pre></td></tr></table></figure><p>创建入口类资源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl apply -f common/ingress-class.yaml<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s/kubernetes-ingress/deployments<span class="hljs-comment"># kubectl apply -f common/ingress-class.yaml</span><br>ingressclass.networking.k8s.io/nginx created<br></code></pre></td></tr></table></figure><h3 id="9-4创建自定义资源"><a href="#9-4创建自定义资源" class="headerlink" title="9.4创建自定义资源"></a>9.4创建自定义资源</h3><p>为 VirtualServer 和 VirtualServerRoute、TransportServer 和 Policy 资源创建自定义资源定义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl apply -f common/crds/k8s.nginx.org_virtualservers.yaml<br>kubectl apply -f common/crds/k8s.nginx.org_virtualserverroutes.yaml<br>kubectl apply -f common/crds/k8s.nginx.org_transportservers.yaml<br>kubectl apply -f common/crds/k8s.nginx.org_policies.yaml<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s/kubernetes-ingress/deployments<span class="hljs-comment"># kubectl apply -f common/crds/k8s.nginx.org_virtualservers.yaml</span><br>customresourcedefinition.apiextensions.k8s.io/virtualservers.k8s.nginx.org created<br>root@k8s-master01:~/k8s/kubernetes-ingress/deployments<span class="hljs-comment"># kubectl apply -f common/crds/k8s.nginx.org_virtualserverroutes.yaml</span><br>customresourcedefinition.apiextensions.k8s.io/virtualserverroutes.k8s.nginx.org created<br>root@k8s-master01:~/k8s/kubernetes-ingress/deployments<span class="hljs-comment"># kubectl apply -f common/crds/k8s.nginx.org_transportservers.yaml</span><br>customresourcedefinition.apiextensions.k8s.io/transportservers.k8s.nginx.org created<br>root@k8s-master01:~/k8s/kubernetes-ingress/deployments<span class="hljs-comment"># kubectl apply -f common/crds/k8s.nginx.org_policies.yaml</span><br>customresourcedefinition.apiextensions.k8s.io/policies.k8s.nginx.org created<br></code></pre></td></tr></table></figure><h3 id="9-5部署Nginx入口控制器"><a href="#9-5部署Nginx入口控制器" class="headerlink" title="9.5部署Nginx入口控制器"></a>9.5部署Nginx入口控制器</h3><p>当您使用 DaemonSet 运行入口控制器时，Kubernetes 将在集群的每个节点上创建一个入口控制器 Pod。</p><p>For NGINX, run: 对于 NGINX，请运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl apply -f daemon-set/nginx-ingress.yaml<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s/kubernetes-ingress/deployments<span class="hljs-comment"># kubectl apply -f daemon-set/nginx-ingress.yaml</span><br>daemonset.apps/nginx-ingress created<br></code></pre></td></tr></table></figure><p>运行以下命令以确保 NGINX 入口控制器 Pod 正在运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl get pods --namespace=nginx-ingress<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s/kubernetes-ingress/deployments<span class="hljs-comment"># kubectl get pods --namespace=nginx-ingress</span><br>NAME                  READY   STATUS              RESTARTS   AGE<br>nginx-ingress-ttgx8   0/1     ContainerCreating   0          35s<br>nginx-ingress-zxdvd   0/1     ContainerCreating   0          35s<br></code></pre></td></tr></table></figure><h3 id="9-6访问NGINX-入口控制器"><a href="#9-6访问NGINX-入口控制器" class="headerlink" title="9.6访问NGINX 入口控制器"></a>9.6访问NGINX 入口控制器</h3><p>创建类型为 NodePort 的服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl create -f service/nodeport.yaml<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s/kubernetes-ingress/deployments<span class="hljs-comment"># kubectl create -f service/nodeport.yaml</span><br>service/nginx-ingress created<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl get svc<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s/kubernetes-ingress/deployments<span class="hljs-comment"># kubectl get svc</span><br>NAME               TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE<br>demo-app-service   NodePort    10.103.61.57   &lt;none&gt;        80:31182/TCP   112m<br>kubernetes         ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP        3d3h<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl get svc -n nginx-ingress<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s/kubernetes-ingress/deployments<span class="hljs-comment"># kubectl get svc -n nginx-ingress</span><br>NAME            TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)                      AGE<br>nginx-ingress   NodePort   10.102.194.162   &lt;none&gt;        80:32144/TCP,443:30186/TCP   54s<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl get pods --namespace=nginx-ingress<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s/kubernetes-ingress/deployments<span class="hljs-comment"># kubectl get pods --namespace=nginx-ingress</span><br>NAME                  READY   STATUS    RESTARTS   AGE<br>nginx-ingress-ttgx8   1/1     Running   0          6m8s<br>nginx-ingress-zxdvd   1/1     Running   0          6m8s<br></code></pre></td></tr></table></figure><h3 id="9-7验证Ingress是否安装完成"><a href="#9-7验证Ingress是否安装完成" class="headerlink" title="9.7验证Ingress是否安装完成"></a>9.7验证Ingress是否安装完成</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">curl http://k8s-node01<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s/kubernetes-ingress/deployments<span class="hljs-comment"># curl http://k8s-node01</span><br>&lt;html&gt;<br>&lt;<span class="hljs-built_in">head</span>&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;<br>&lt;body&gt;<br>&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;<br>&lt;hr&gt;&lt;center&gt;nginx/1.25.1&lt;/center&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">curl http://k8s-node02<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@k8s-master01:~/k8s/kubernetes-ingress/deployments<span class="hljs-comment"># curl http://k8s-node02</span><br>&lt;html&gt;<br>&lt;<span class="hljs-built_in">head</span>&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;<br>&lt;body&gt;<br>&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;<br>&lt;hr&gt;&lt;center&gt;nginx/1.25.1&lt;/center&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>1 <code>container runtime is not running</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Bash">root@master-VirtualBox:/home/master/Desktop<span class="hljs-comment"># sudo kubeadm init \</span><br>&gt;   --apiserver-advertise-address=192.168.43.201 \<br>&gt;   --pod-network-cidr=10.244.0.0/16 \<br>&gt;   --image-repository=registry.aliyuncs.com/google_containers<br>[init] Using Kubernetes version: v1.27.3<br>[preflight] Running pre-flight checks<br>error execution phase preflight: [preflight] Some fatal errors occurred:<br>  [ERROR CRI]: container runtime is not running: output: time=<span class="hljs-string">&quot;2023-07-12T15:58:14+08:00&quot;</span> level=fatal msg=<span class="hljs-string">&quot;validate service connection: CRI v1 runtime API is not implemented for endpoint \&quot;unix:///var/run/containerd/containerd.sock\&quot;: rpc error: code = Unimplemented desc = unknown service runtime.v1.RuntimeService&quot;</span><br>, error: <span class="hljs-built_in">exit</span> status 1<br>[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`<br>To see the stack trace of this error execute with --v=5 or higher<br></code></pre></td></tr></table></figure><p>解决方案</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">rm</span> -rf /etc/containerd/config.toml<br>systemctl restart containerd<br></code></pre></td></tr></table></figure><p>2 <code>dial tcp 192.168.43.201:6443: connect: connection refused&quot; interval=&quot;7s&quot;</code></p><p>解决方案</p><p>2.1 安装firewall-cmd</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt-get install firewalld<br></code></pre></td></tr></table></figure><p>2.2开放端口（比如开放6443）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">firewall-cmd --add-port=6443/tcp --permanent<br>firewall-cmd --reload<br></code></pre></td></tr></table></figure><p>2.3查看开放的端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">firewall-cmd  --list-all<br></code></pre></td></tr></table></figure><p>3 <code>[ERROR Port-10250]: Port 10250 is in use</code></p><p>解决方案</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubeadm reset<br></code></pre></td></tr></table></figure><p>4 <code>root@k8s-master:/etc/kubernetes/manifests# telnet 127.0.0.1 8080 Trying 127.0.0.1... telnet: Unable to connect to remote host: Connection refused</code></p><p>解决方案</p><p>4.1查看端口状态</p><p>能够执行telnet命令并不代表系统中安装了telnet服务。由于是远程连接本地，所以本地需要有telnet服务才能进行连接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Bash">netstat -tnl<br>Proto Recv-Q Send-Q Local Address           Foreign Address         State      <br>tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     <br>tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN     <br>tcp6       0      0 :::22                   :::*                    LISTEN     <br>tcp6       0      0 ::1:631                 :::*                    LISTEN<br><br></code></pre></td></tr></table></figure><p>可以看到没有进程在监听本地的23端口，说明本地的telnet服务没有启动。</p><p>4.2安装xinetd和telnetd</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt-get install xinetd telnetd<br></code></pre></td></tr></table></figure><p>4.3创建文件<code>/etc/inetd.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo vi /etc/inetd.conf<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">telnet stream tcp nowait telnetd /usr/sbin/tcpd /usr/sbin/in.telnetd<br></code></pre></td></tr></table></figure><p>4.4修改文件<code>/etc/xinetd.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo vi /etc/xinetd.conf<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># Simple configuration file for xinetd</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Some defaults, and include /etc/xinetd.d/</span><br><br>defaults<br>&#123;<br><span class="hljs-comment"># Please note that you need a log_type line to be able to use log_on_success</span><br><span class="hljs-comment"># and log_on_failure. The default is the following :</span><br><span class="hljs-comment"># log_type = SYSLOG daemon info</span><br>instances = 60<br>log_type = SYSLOG authpriv<br>log_on_success = HOST PID<br>log_on_failure = HOST<br>cps = 25 30<br>&#125;<br>includedir /etc/xinetd.d<br></code></pre></td></tr></table></figure><p>4.5创建文件<code>/etc/xinetd.d/telnet</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo vi /etc/xinetd.d/telnet<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># default: on</span><br><span class="hljs-comment"># description: The telnet server serves telnet sessions; it uses \</span><br><span class="hljs-comment"># unencrypted username/password pairs for authentication.</span><br>service telnet<br>&#123;    <br><span class="hljs-built_in">disable</span> = no<br>flags = REUSE<br>socket_type = stream<br><span class="hljs-built_in">wait</span> = no<br>user = root<br>server = /usr/sbin/in.telnetd<br>log_on_failure += USERID<br>&#125;<br></code></pre></td></tr></table></figure><p>4.6重启系统，查看端口状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">reboot<br>netstat -tnl<br></code></pre></td></tr></table></figure><p>可以看到正在监听23端口</p><p> Proto Recv-Q Send-Q Local Address           Foreign Address         State      </p><p>   tcp        0      0 127.0.1.1:53            0.0.0.0:*               LISTEN     </p><p>   tcp        0      0 0.0.0.0:23              0.0.0.0:*               LISTEN     </p><p>   tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN     </p><p>   tcp6       0      0 ::1:631                 :::*                    LISTEN</p><p>4.7最后测试远程登录本地</p><pre><code class="hljs">`$ telnet 127.0.0.1`</code></pre><p>5 <code>yaml already exists</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Bash">error execution phase preflight: [preflight] Some fatal errors occurred:<br>    [ERROR FileAvailable--etc-kubernetes-manifests-kube-apiserver.yaml]: /etc/kubernetes/manifests/kube-apiserver.yaml already exists<br>    [ERROR FileAvailable--etc-kubernetes-manifests-kube-controller-manager.yaml]: /etc/kubernetes/manifests/kube-controller-manager.yaml already exists<br>    [ERROR FileAvailable--etc-kubernetes-manifests-kube-scheduler.yaml]: /etc/kubernetes/manifests/kube-scheduler.yaml already exists<br>    [ERROR FileAvailable--etc-kubernetes-manifests-etcd.yaml]: /etc/kubernetes/manifests/etcd.yaml already exists<br>[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`<br></code></pre></td></tr></table></figure><p>初始化生产的文件，重新初始化，需要删除即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">rm</span> -fr /etc/kubernetes/manifests/*<br></code></pre></td></tr></table></figure><p>6 <code>ssh登录时提示[permission denied please try again]</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo vi /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 去掉 # 号</span><br>PermitRootLogin <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_51153463/article/details/123966124">https://blog.csdn.net/qq_51153463/article/details/123966124</a><br><a href="https://docs.docker.com/engine/install/ubuntu/">https://docs.docker.com/engine/install/ubuntu/</a><br><a href="https://yeasy.gitbook.io/docker_practice/install/ubuntu">https://yeasy.gitbook.io/docker_practice/install/ubuntu</a><br><a href="https://blog.csdn.net/qq_52787609/article/details/127173886">https://blog.csdn.net/qq_52787609/article/details/127173886</a><br><a href="https://xie.infoq.cn/article/4a4bf681ef319ca80674e9c6e">https://xie.infoq.cn/article/4a4bf681ef319ca80674e9c6e</a><br><a href="https://www.51cto.com/article/704190.html?u_atoken=52c3e849-c467-4eef-938b-c2d3c7cc95c9&u_asession=01kKP4HIssUSc7WPqUh-VM6ym9lQDNAxenTgAh4NWSP4aJUINCgUnlUGtTMKow5ywPX0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K_vYdMZMrGT7B5NBjrjISNpfLQ4WAzKMpeQ5gBYVoJommBkFo3NEHBv0PZUm6pbxQU&u_asig=05aKhHCfLIMI7ffgmH0YvZE_Sew_pMgM14YOX6GTvHD-ZEl5ILnBJMwvVqtbChg4NaWsyPhT3O9JcSUBSGd6ZOqp7ZmqiJYY_li6K3CZ0_Fpk9ohDzbZLnj-TJF8nKxoxGAt8xlgG1WB8wlt9PBM4CRRa2Uk09152ZbyCLayi-1OT9JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJzaSUEiTC70askN7VQs6nEBvnqDsWREcFX5InhzuOVc_ALCDZcaGZC2eDyMNrbIBtJ-3h9VXwMyh6PgyDIVSG1W8f7eqgw9KxzL8w8Jzt-zuc2t06Kw4WXjL8pvgPxmcQyjnMxXeLYjmCcOrtPxTbIOx3KUuk5c7oAOl7aX6j_Cs-mWspDxyAEEo4kbsryBKb9Q&u_aref=MsubxaXbbpQHDuwfGLzTHGB04AI=">https://www.51cto.com/article/704190.html?u_atoken=52c3e849-c467-4eef-938b-c2d3c7cc95c9&amp;u_asession=01kKP4HIssUSc7WPqUh-VM6ym9lQDNAxenTgAh4NWSP4aJUINCgUnlUGtTMKow5ywPX0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K_vYdMZMrGT7B5NBjrjISNpfLQ4WAzKMpeQ5gBYVoJommBkFo3NEHBv0PZUm6pbxQU&amp;u_asig=05aKhHCfLIMI7ffgmH0YvZE_Sew_pMgM14YOX6GTvHD-ZEl5ILnBJMwvVqtbChg4NaWsyPhT3O9JcSUBSGd6ZOqp7ZmqiJYY_li6K3CZ0_Fpk9ohDzbZLnj-TJF8nKxoxGAt8xlgG1WB8wlt9PBM4CRRa2Uk09152ZbyCLayi-1OT9JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJzaSUEiTC70askN7VQs6nEBvnqDsWREcFX5InhzuOVc_ALCDZcaGZC2eDyMNrbIBtJ-3h9VXwMyh6PgyDIVSG1W8f7eqgw9KxzL8w8Jzt-zuc2t06Kw4WXjL8pvgPxmcQyjnMxXeLYjmCcOrtPxTbIOx3KUuk5c7oAOl7aX6j_Cs-mWspDxyAEEo4kbsryBKb9Q&amp;u_aref=MsubxaXbbpQHDuwfGLzTHGB04AI%3D</a><br><a href="https://www.cnblogs.com/pluse/p/16219500.html">https://www.cnblogs.com/pluse/p/16219500.html</a><br><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/">https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/</a><br><a href="https://k8s.easydoc.net/docs/dRiQjyTY/28366845/6GiNOzyZ/nd7yOvdY">https://k8s.easydoc.net/docs/dRiQjyTY/28366845/6GiNOzyZ/nd7yOvdY</a><br><a href="https://blog.csdn.net/donaldsy/article/details/102679413">https://blog.csdn.net/donaldsy/article/details/102679413</a><br><a href="https://cloud.tencent.com/developer/article/1890887">https://cloud.tencent.com/developer/article/1890887</a></p>]]></content>
    
    
    <categories>
      
      <category>k8s</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部署双节点X86OpenStack集群</title>
    <link href="/2023/08/10/%E9%83%A8%E7%BD%B2%E5%8F%8C%E8%8A%82%E7%82%B9X86OpenStack%E9%9B%86%E7%BE%A4/"/>
    <url>/2023/08/10/%E9%83%A8%E7%BD%B2%E5%8F%8C%E8%8A%82%E7%82%B9X86OpenStack%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="配置基础环境"><a href="#配置基础环境" class="headerlink" title="配置基础环境"></a>配置基础环境</h1><p>以下步骤在主机侧部署，控制节点和计算节点环境均在Ubuntu 22.04。</p><p><strong>节点拓扑图</strong></p><p><img src="/../image/%E8%8A%82%E7%82%B9%E6%8B%93%E6%89%91%E5%9B%BE.png" alt="节点拓扑图"></p><p><strong>网络拓扑</strong></p><table><thead><tr><th align="center">序号</th><th align="center">主机</th><th align="center">接口</th><th align="center">网卡名</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">controller：10.100.192.79</td><td align="center">内部接口</td><td align="center">enp2s0</td></tr><tr><td align="center">1</td><td align="center">controller：10.100.192.92</td><td align="center">外部接口</td><td align="center">enxf8e43b63eb2f</td></tr><tr><td align="center">2</td><td align="center">compute2：10.100.192.94</td><td align="center">内部接口</td><td align="center">eno1</td></tr><tr><td align="center">2</td><td align="center">compute2：10.100.192.93</td><td align="center">外部接口</td><td align="center">enx00e04c680218</td></tr></tbody></table><h3 id="更新Ubuntu源"><a href="#更新Ubuntu源" class="headerlink" title="更新Ubuntu源"></a>更新Ubuntu源</h3><p>选择阿里云源22.04版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Bash">deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restrcdicted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse<br></code></pre></td></tr></table></figure><h2 id="一、基础环境（2台高性能开发机）"><a href="#一、基础环境（2台高性能开发机）" class="headerlink" title="一、基础环境（2台高性能开发机）"></a>一、基础环境（2台高性能开发机）</h2><h3 id="1、关闭防火墙及修改内核"><a href="#1、关闭防火墙及修改内核" class="headerlink" title="1、关闭防火墙及修改内核"></a>1、关闭防火墙及修改内核</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo -i<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ufw <span class="hljs-built_in">disable</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;net.bridge.bridge-nf-call-ip6tables = 1&#x27;</span> &gt;&gt; /etc/sysctl.d/99-sysctl.conf<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;net.bridge.bridge-nf-call-iptables = 1&#x27;</span> &gt;&gt; /etc/sysctl.d/99-sysctl.conf<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;net.ipv6.conf.all.disable_ipv6 = 1&#x27;</span> &gt;&gt; /etc/sysctl.d/99-sysctl.conf<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">modprobe br_netfilter<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sysctl --system<br></code></pre></td></tr></table></figure><h3 id="2、修改-etc-hosts"><a href="#2、修改-etc-hosts" class="headerlink" title="2、修改  /etc/hosts"></a>2、修改  <code>/etc/hosts</code></h3><p>各节点下执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hostnamectl set-hostname controller<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;10.100.192.79  controller&#x27;</span>  &gt;&gt; /etc/hosts<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;10.100.192.94  compute2&#x27;</span>  &gt;&gt; /etc/hosts<br></code></pre></td></tr></table></figure><h3 id="3、安装软件包"><a href="#3、安装软件包" class="headerlink" title="3、安装软件包"></a>3、安装软件包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">apt update<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">apt install -y net-tools bash-completion python3-openstackclient wget chrony<br></code></pre></td></tr></table></figure><h3 id="4、配置时间同步"><a href="#4、配置时间同步" class="headerlink" title="4、配置时间同步"></a>4、配置时间同步</h3><p>集群环境时刻要求每个节点的时间一致，一般由时钟同步软件保证。本文使用<code>chrony</code>软件。步骤如下：</p><p><strong>controller</strong></p><p>1、 安装服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt update<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt install -y chrony<br></code></pre></td></tr></table></figure><p>2、修改 <code>/etc/chrony/chrony.conf</code> 配置文件，新增一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/chrony/chrony.conf<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 表示允许哪些IP从本节点同步时钟</span><br>allow 10.100.192.0/24<br></code></pre></td></tr></table></figure><p>3、重启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo service chrony restart<br></code></pre></td></tr></table></figure><p><strong>compute2</strong></p><p>1、安装服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt update<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt install -y chrony<br></code></pre></td></tr></table></figure><p>2、修改 <code>/etc/chrony.conf</code> 配置文件，新增一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># NTP_SERVER 是controller IP，表示从这个机器获取时间，这里我们填 192.168.0.2，或者在`/etc/hosts`里配置好的 controller 名字即可。</span><br>server NTP_SERVER iburst<br></code></pre></td></tr></table></figure><blockquote><p>同时，要把<code>pool pool.ntp.org iburst</code>这一行注释掉，表示不从公网同步时钟。</p></blockquote><p>3、重启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo service chrony restart<br></code></pre></td></tr></table></figure><p><strong>验证</strong></p><p>配置完成后，检查一下结果，在其他非controller节点执行<code>chronyc sources</code>，返回结果类似如下内容，表示成功从controller同步时钟。</p><h2 id="二、openstack安装（Controller）"><a href="#二、openstack安装（Controller）" class="headerlink" title="二、openstack安装（Controller）"></a>二、openstack安装（Controller）</h2><p>通过 <a href="https://docs.openstack.org/install-guide/environment-packages-ubuntu.html#archive-enablement">OpenStack packages for Ubuntu</a> 查看对应版本，22.04的默认版本为OpenStack Yoga。使用这个版本无需添加配置。如果其他版本自行修改。</p><h3 id="1、安装Mariadb数据库"><a href="#1、安装Mariadb数据库" class="headerlink" title="1、安装Mariadb数据库"></a>1、安装Mariadb数据库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">apt install mariadb-server python3-pymysql -y<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cat</span> &gt; /etc/mysql/mariadb.conf.d/99-openstack.cnf  &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">[mysqld]</span><br><span class="hljs-string">bind-address = 10.100.192.79</span><br><span class="hljs-string">default-storage-engine = innodb</span><br><span class="hljs-string">innodb_file_per_table = on</span><br><span class="hljs-string">max_connections = 4096</span><br><span class="hljs-string">collation-server = utf8_general_ci</span><br><span class="hljs-string">character-set-server = utf8</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><p>重启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service mysql restart<br></code></pre></td></tr></table></figure><p>通过运行<code>mysql_secure_installation</code> 脚本来保护数据库服务。特别是，为数据库root帐户选择一个合适的密码 ：（设置数据库密码为<code>000000</code>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">mysql_secure_installation<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">netstat -antup | grep mariadb<br></code></pre></td></tr></table></figure><p>检查能否登录Mariadb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -u root -p<br></code></pre></td></tr></table></figure><h3 id="2、安装Rabbitmq消息队列"><a href="#2、安装Rabbitmq消息队列" class="headerlink" title="2、安装Rabbitmq消息队列"></a>2、安装Rabbitmq消息队列</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">apt install rabbitmq-server -y<br></code></pre></td></tr></table></figure><p>添加OpenStack用户，用户密码设置为<code>000000</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">rabbitmqctl add_user openstack 000000<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">rabbitmqctl set_user_tags openstack administrator<br></code></pre></td></tr></table></figure><p>替换RABBIT_PASS为合适的密码。 允许用户的配置、写入和读取访问权限 OpenStack：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">rabbitmqctl set_permissions openstack <span class="hljs-string">&quot;.*&quot;</span> <span class="hljs-string">&quot;.*&quot;</span> <span class="hljs-string">&quot;.*&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">rabbitmqctl list_user_permissions openstack<br></code></pre></td></tr></table></figure><p>添加可视化插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">rabbitmq-plugins <span class="hljs-built_in">enable</span> rabbitmq_management<br></code></pre></td></tr></table></figure><p>登录<code>rabbitmq</code>,登录地址：<a href="http://ip:15672/">http://localhost:15672</a></p><p>可通过<code>guest</code>登录，密码：<code>guest</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">netstat  -antup | grep 5672<br></code></pre></td></tr></table></figure><p>重启消息队列服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service rabbitmq-server restart<br></code></pre></td></tr></table></figure><h3 id="3、安装MemCached内存缓存处理"><a href="#3、安装MemCached内存缓存处理" class="headerlink" title="3、安装MemCached内存缓存处理"></a>3、安装MemCached内存缓存处理</h3><p>服务的身份服务认证机制使用 Memcached 来缓存令牌。memcached 服务通常在控制器节点上运行。对于生产部署，我们建议启用防火墙、身份验证和加密的组合来保护它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">apt install -y memcached python3-memcache<br></code></pre></td></tr></table></figure><blockquote><p>编辑 <code>/etc/memcached.conf</code> 文件并将服务配置为使用控制器节点的管理 IP 地址。这是为了允许其他节点通过管理网络进行访问修改：将 <code>-l</code> 后面的IP改为如下 <code>-l IP</code> 地址。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sed -i <span class="hljs-string">&#x27;s/-l 127.0.0.1/-l 10.100.192.79/g&#x27;</span> /etc/memcached.conf<br></code></pre></td></tr></table></figure><p>重启 Memcached 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service memcached restart<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">netstat -antup | grep memcached<br></code></pre></td></tr></table></figure><h3 id="4、安装etcd分布式键值存储"><a href="#4、安装etcd分布式键值存储" class="headerlink" title="4、安装etcd分布式键值存储"></a>4、安装etcd分布式键值存储</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">apt install etcd -y<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cat</span> &gt;  /etc/default/etcd  &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">ETCD_NAME=&quot;controller&quot;</span><br><span class="hljs-string">ETCD_DATA_DIR=&quot;/var/lib/etcd&quot;</span><br><span class="hljs-string">ETCD_INITIAL_CLUSTER_STATE=&quot;new&quot;</span><br><span class="hljs-string">ETCD_INITIAL_CLUSTER_TOKEN=&quot;etcd-cluster-01&quot;</span><br><span class="hljs-string">ETCD_INITIAL_CLUSTER=&quot;controller=http://10.100.192.79:2380&quot;</span><br><span class="hljs-string">ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;http://10.100.192.79:2380&quot;</span><br><span class="hljs-string">ETCD_ADVERTISE_CLIENT_URLS=&quot;http://10.100.192.79:2379&quot;</span><br><span class="hljs-string">ETCD_LISTEN_PEER_URLS=&quot;http://0.0.0.0:2380&quot;</span><br><span class="hljs-string">ETCD_LISTEN_CLIENT_URLS=&quot;http://10.100.192.79:2379&quot;</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service etcd restart<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">netstat -antup | grep etcd<br></code></pre></td></tr></table></figure><h3 id="5、安装keystone"><a href="#5、安装keystone" class="headerlink" title="5、安装keystone"></a>5、安装keystone</h3><p>以root用户身份连接数据库服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo su<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">mysql<br></code></pre></td></tr></table></figure><p>以下步骤在root数据库环境执行</p><p>创建keystone数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">CREATE DATABASE keystone;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">GRANT ALL PRIVILEGES ON keystone.* TO <span class="hljs-string">&#x27;keystone&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;000000&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">GRANT ALL PRIVILEGES ON keystone.* TO <span class="hljs-string">&#x27;keystone&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;000000&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><p>退出数据库访问客户端。</p><p>运行以下命令来安装软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">apt install keystone libapache2-mod-wsgi-py3 -y<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vi /etc/keystone/keystone.conf<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 修改如下</span><br>[database]<br>connection = mysql+pymysql://keystone:000000@controller/keystone<br><br>[token]<br>provider = fernet<br></code></pre></td></tr></table></figure><p>填充身份服务数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">su -s /bin/sh -c <span class="hljs-string">&quot;keystone-manage db_sync&quot;</span> keystone<br></code></pre></td></tr></table></figure><p>初始化 Fernet 密钥库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">keystone-manage fernet_setup --keystone-user keystone --keystone-group keystone<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">keystone-manage credential_setup --keystone-user keystone --keystone-group keystone<br></code></pre></td></tr></table></figure><p>引导身份服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">keystone-manage bootstrap --bootstrap-password 000000 \<br>  --bootstrap-admin-url http://controller:5000/v3/ \<br>  --bootstrap-internal-url http://controller:5000/v3/ \<br>  --bootstrap-public-url http://controller:5000/v3/ \<br>  --bootstrap-region-id RegionOne<br></code></pre></td></tr></table></figure><p>配置 Apache HTTP 服务器</p><p>编辑 <code>/etc/apache2/apache2.conf</code> 文件并配置 <code>ServerName</code> 选项以引用控制器节点：如果该 <code>ServerName</code> 条目尚不存在，则需要添加该条目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;ServerName controller&#x27;</span> &gt;&gt;  /etc/apache2/apache2.conf<br></code></pre></td></tr></table></figure><p>安全部署应将 Web 服务器配置为使用 SSL 或在 SSL 终结器后面运行。<br>重启Apache服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service apache2 restart<br></code></pre></td></tr></table></figure><p>检查状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service apache2 status<br></code></pre></td></tr></table></figure><p>后续所有service都可通过status命令检查重启状态，后面不再重复，请自行检查配置的服务是否重启成功。</p><p>配置keystone管理员的环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">export</span> OS_USERNAME=admin<br><span class="hljs-built_in">export</span> OS_PASSWORD=000000<br><span class="hljs-built_in">export</span> OS_PROJECT_NAME=admin<br><span class="hljs-built_in">export</span> OS_USER_DOMAIN_NAME=Default<br><span class="hljs-built_in">export</span> OS_PROJECT_DOMAIN_NAME=Default<br><span class="hljs-built_in">export</span> OS_AUTH_URL=http://controller:5000/v3<br><span class="hljs-built_in">export</span> OS_IDENTITY_API_VERSION=3<br></code></pre></td></tr></table></figure><p>创建域、项目、keystone用户和角色</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack domain create --description <span class="hljs-string">&quot;An Example Domain&quot;</span> example<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack project create --domain default --description <span class="hljs-string">&quot;Service Project&quot;</span> service<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack project create --domain default --description <span class="hljs-string">&quot;Demo Project&quot;</span> demo<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack user create --domain default --password-prompt demo<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack role create user<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack role add --project demo --user demo user<br></code></pre></td></tr></table></figure><p>验证keystone</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">unset</span> OS_AUTH_URL OS_PASSWORD<br></code></pre></td></tr></table></figure><p>获取keystone管理员的令牌</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack --os-auth-url http://controller:5000/v3 \<br>  --os-project-domain-name Default --os-user-domain-name Default \<br>  --os-project-name admin --os-username admin token issue<br></code></pre></td></tr></table></figure><p>输入Password：<code>000000</code></p><p>获取令牌，keystone正常</p><p>获取keystone普通用户demo的令牌</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack --os-auth-url http://controller:5000/v3 \<br>  --os-project-domain-name Default --os-user-domain-name Default \<br>  --os-project-name demo --os-username demo token issue<br></code></pre></td></tr></table></figure><p>创建openstack客户端环境变量脚本文件</p><p>前面的部分使用环境变量和命令选项的组合通过openstack客户端与身份服务进行交互 。为了提高客户端操作的效率，OpenStack支持简单的客户端环境脚本，也称为 OpenRC 文件。这些脚本通常包含所有客户端的通用选项，但也支持独特的选项。创建客户端环境的脚本admin和demo 项目和用户。本指南的后续部分将参考这些脚本来加载客户端操作的适当凭据。</p><p>admin</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cat</span> &gt; admin-openrc  &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">export OS_PROJECT_DOMAIN_NAME=Default</span><br><span class="hljs-string">export OS_USER_DOMAIN_NAME=Default</span><br><span class="hljs-string">export OS_PROJECT_NAME=admin</span><br><span class="hljs-string">export OS_USERNAME=admin</span><br><span class="hljs-string">export OS_PASSWORD=000000</span><br><span class="hljs-string">export OS_AUTH_URL=http://controller:5000/v3</span><br><span class="hljs-string">export OS_IDENTITY_API_VERSION=3</span><br><span class="hljs-string">export OS_IMAGE_API_VERSION=2</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><p>demo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cat</span> &gt; demo-openrc  &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">export OS_PROJECT_DOMAIN_NAME=Default</span><br><span class="hljs-string">export OS_USER_DOMAIN_NAME=Default</span><br><span class="hljs-string">export OS_PROJECT_NAME=demo</span><br><span class="hljs-string">export OS_USERNAME=demo</span><br><span class="hljs-string">export OS_PASSWORD=000000</span><br><span class="hljs-string">export OS_AUTH_URL=http://controller:5000/v3</span><br><span class="hljs-string">export OS_IDENTITY_API_VERSION=3</span><br><span class="hljs-string">export OS_IMAGE_API_VERSION=2</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">source</span> admin-openrc<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack token issue<br></code></pre></td></tr></table></figure><h3 id="6、安装glance"><a href="#6、安装glance" class="headerlink" title="6、安装glance"></a>6、安装glance</h3><p>创建数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">mysql<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">CREATE DATABASE glance;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">GRANT ALL PRIVILEGES ON glance.* TO <span class="hljs-string">&#x27;glance&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;000000&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">GRANT ALL PRIVILEGES ON glance.* TO <span class="hljs-string">&#x27;glance&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;000000&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><p>退出数据库访问客户端</p><p>创建用户并授权</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">. admin-openrc<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack user create --domain default --password-prompt glance<br></code></pre></td></tr></table></figure><p>在server项目中给用户glance授予管理员权限admin</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack role add --project service --user glance admin<br></code></pre></td></tr></table></figure><p>创建服务类型为image的实体glance</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack service create --name glance  --description <span class="hljs-string">&quot;OpenStack Image&quot;</span> image<br></code></pre></td></tr></table></figure><p>创建镜像服务的调用端点</p><p>为image服务类型创建公开（public）的调用端点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack endpoint create --region RegionOne image public http://controller:9292<br></code></pre></td></tr></table></figure><p>为image服务类型创建内部（internal）的调用端点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack endpoint create --region RegionOne image internal http://controller:9292<br></code></pre></td></tr></table></figure><p>为image服务类型创建管理（admin）的调用端点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack endpoint create --region RegionOne image admin http://controller:9292<br></code></pre></td></tr></table></figure><p>安装并配置相关软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">apt install glance -y<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vi /etc/glance/glance-api.conf<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 修改如下</span><br>[database]<br>connection = mysql+pymysql://glance:000000@controller/glance<br><br>[keystone_authtoken]<br>www_authenticate_uri = http://controller:5000<br>auth_url = http://controller:5000<br>memcached_servers = controller:11211<br>auth_type = password<br>project_domain_name = Default<br>user_domain_name = Default<br>project_name = service<br>username = glance<br>password = 000000<br><br>[paste_deploy]<br>flavor = keystone<br><br>[glance_store]<br>stores = file,http<br>default_store = file<br>filesystem_store_datadir = /var/lib/glance/images/<br></code></pre></td></tr></table></figure><p>向数据库中导入glance的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">su -s /bin/sh -c <span class="hljs-string">&quot;glance-manage db_sync&quot;</span> glance<br></code></pre></td></tr></table></figure><p>启动glance服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service glance-api restart<br></code></pre></td></tr></table></figure><p>验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">. admin-openrc<br></code></pre></td></tr></table></figure><p>下载镜像到<code>/root</code>目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">wget http://download.cirros-cloud.net/0.4.0/cirros-0.4.0-x86_64-disk.img<br></code></pre></td></tr></table></figure><p>使用QCOW2磁盘格式、裸容器格式和公开可见性将镜像上传到 Image 服务 ，以便所有项目都可以访问它：执行成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">glance image-create --name <span class="hljs-string">&quot;cirros&quot;</span> --file cirros-0.4.0-x86_64-disk.img \<br>--disk-format qcow2 --container-format bare  --visibility=public<br></code></pre></td></tr></table></figure><p>OpenStack 动态生成 ID，因此您将在示例命令输出中看到不同的值。</p><p>确认上传镜像并验证属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">glance image-list<br></code></pre></td></tr></table></figure><h3 id="7、安装placement"><a href="#7、安装placement" class="headerlink" title="7、安装placement"></a>7、安装placement</h3><p>创建数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">mysql<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">CREATE DATABASE placement;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">GRANT ALL PRIVILEGES ON placement.* TO <span class="hljs-string">&#x27;placement&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;000000&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">GRANT ALL PRIVILEGES ON placement.* TO <span class="hljs-string">&#x27;placement&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;000000&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><p>创建用户并授权</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">. admin-openrc<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack user create --domain default --password-prompt placement<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack role add --project service --user placement admin<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack service create --name placement --description <span class="hljs-string">&quot;Placement API&quot;</span> placement<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack endpoint create --region RegionOne placement public http://controller:8778<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack endpoint create --region RegionOne placement internal http://controller:8778<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack endpoint create --region RegionOne placement admin http://controller:8778<br></code></pre></td></tr></table></figure><p>安装并配置相关软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">apt install placement-api -y<br></code></pre></td></tr></table></figure><p>编辑 <code>/etc/placement/placement.conf</code> 文件并完成以下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vi /etc/placement/placement.conf<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 增加如下</span><br>[placement_database]<br>connection = mysql+pymysql://placement:000000@controller/placement<br><br>[api]<br>auth_strategy = keystone<br><br>[keystone_authtoken]<br>auth_url = http://controller:5000/v3<br>memcached_servers = controller:11211<br>auth_type = password<br>project_domain_name = Default<br>user_domain_name = Default<br>project_name = service<br>username = placement<br>password = 000000<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">su -s /bin/sh -c <span class="hljs-string">&quot;placement-manage db sync&quot;</span> placement<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service apache2 restart<br></code></pre></td></tr></table></figure><p>验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">. admin-openrc<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">placement-status upgrade check<br></code></pre></td></tr></table></figure><h3 id="安装osc-placement插件"><a href="#安装osc-placement插件" class="headerlink" title="安装osc-placement插件"></a>安装osc-placement插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">pip3 install osc-placement<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack --os-placement-api-version 1.2 resource class list --sort-column name<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack --os-placement-api-version 1.6 trait list --sort-column name<br></code></pre></td></tr></table></figure><h3 id="8、安装-nova"><a href="#8、安装-nova" class="headerlink" title="8、安装 nova"></a>8、安装 nova</h3><p><strong>controller</strong></p><p>创建数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">mysql<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">CREATE DATABASE nova_api;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">CREATE DATABASE nova;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">CREATE DATABASE nova_cell0;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">GRANT ALL PRIVILEGES ON nova_api.* TO <span class="hljs-string">&#x27;nova&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;000000&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">GRANT ALL PRIVILEGES ON nova_api.* TO <span class="hljs-string">&#x27;nova&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;000000&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">GRANT ALL PRIVILEGES ON nova.* TO <span class="hljs-string">&#x27;nova&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;000000&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">GRANT ALL PRIVILEGES ON nova.* TO <span class="hljs-string">&#x27;nova&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;000000&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">GRANT ALL PRIVILEGES ON nova_cell0.* TO <span class="hljs-string">&#x27;nova&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;000000&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">GRANT ALL PRIVILEGES ON nova_cell0.* TO <span class="hljs-string">&#x27;nova&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;000000&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">. admin-openrc<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack user create --domain default --password-prompt nova<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack role add --project service --user nova admin<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack service create --name nova --description <span class="hljs-string">&quot;OpenStack Compute&quot;</span> compute<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack endpoint create --region RegionOne compute public http://controller:8774/v2.1<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack endpoint create --region RegionOne compute internal http://controller:8774/v2.1<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack endpoint create --region RegionOne compute admin http://controller:8774/v2.1<br></code></pre></td></tr></table></figure><p>安装并配置相关软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">apt install nova-api nova-conductor nova-novncproxy nova-scheduler -y<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vi /etc/nova/nova.conf<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 增加内容</span><br>[DEFAULT]<br>transport_url = rabbit://openstack:000000@controller:5672/<br>my_ip = 10.100.192.79<br><br>[api_database]<br>connection = mysql+pymysql://nova:000000@controller/nova_api<br><br>[database]<br>connection = mysql+pymysql://nova:000000@controller/nova<br><br>[api]<br>auth_strategy = keystone<br><br>[keystone_authtoken]<br>www_authenticate_uri = http://controller:5000/<br>auth_url = http://controller:5000/<br>memcached_servers = controller:11211<br>auth_type = password<br>project_domain_name = Default<br>user_domain_name = Default<br>project_name = service<br>username = nova<br>password = 000000<br><br>[vnc]<br>enabled = <span class="hljs-literal">true</span><br>server_listen = <span class="hljs-variable">$my_ip</span><br>server_proxyclient_address = <span class="hljs-variable">$my_ip</span><br><br>[glance]<br>api_servers = http://controller:9292<br><br>[oslo_concurrency]<br>lock_path = /var/lib/nova/tmp<br><br>[placement]<br>region_name = RegionOne<br>project_domain_name = Default<br>project_name = service<br>auth_type = password<br>user_domain_name = Default<br>auth_url = http://controller:5000/v3<br>username = placement<br>password = 000000<br><br>[scheduler]<br>discover_hosts_in_cells_interval = 300<br><br></code></pre></td></tr></table></figure><p>向数据库中导入nova，nova-api，nova-cell0的数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">su -s /bin/sh -c <span class="hljs-string">&quot;nova-manage api_db sync&quot;</span> nova<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">su -s /bin/sh -c <span class="hljs-string">&quot;nova-manage cell_v2 map_cell0&quot;</span> nova<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">su -s /bin/sh -c <span class="hljs-string">&quot;nova-manage cell_v2 create_cell --name=cell1 --verbose&quot;</span> nova<br></code></pre></td></tr></table></figure><p>检查</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">su -s /bin/sh -c <span class="hljs-string">&quot;nova-manage db sync&quot;</span> nova<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">su -s /bin/sh -c <span class="hljs-string">&quot;nova-manage cell_v2 list_cells&quot;</span> nova<br></code></pre></td></tr></table></figure><p>重启所有服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service nova-api restart<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service nova-scheduler restart<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service nova-conductor restart<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service nova-novncproxy restart<br></code></pre></td></tr></table></figure><p>查看所有状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service nova-api status &amp;&amp; service nova-scheduler status &amp;&amp; service nova-conductor status &amp;&amp; service nova-novncproxy status<br></code></pre></td></tr></table></figure><p><strong>compute1(OpenEuler X86)</strong></p><p>1、安装软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dnf install openstack-nova-compute<br></code></pre></td></tr></table></figure><p>2、编辑<code>/etc/nova/nova.conf</code>配置文件</p><p>在[default]部分，启用计算和元数据的API，配置RabbitMQ消息队列入口，使用Compute节点管理IP配置my_ip，显式定义compute_driver、instances_path、log_dir：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[DEFAULT]<br>enabled_apis = osapi_compute,metadata<br>transport_url = rabbit://openstack:000000@controller:5672/<br>my_ip = 10.12.193.53<br>compute_driver = libvirt.LibvirtDriver<br>instances_path = /var/lib/nova/instances<br>log_dir = /var/log/nova<br></code></pre></td></tr></table></figure><p>在[api]和[keystone_authtoken]部分，配置身份认证服务入口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">[api]<br>auth_strategy = keystone<br><br>[keystone_authtoken]<br>auth_url = http://controller:5000/v3<br>memcached_servers = controller:11211<br>auth_type = password<br>project_domain_name = Default<br>user_domain_name = Default<br>project_name = service<br>username = nova<br>password = 000000<br></code></pre></td></tr></table></figure><p>在[vnc]部分，启用并配置远程控制台入口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[vnc]<br>enabled = <span class="hljs-literal">true</span><br>server_listen = <span class="hljs-variable">$my_ip</span><br>server_proxyclient_address = <span class="hljs-variable">$my_ip</span><br>novncproxy_base_url = http://controller:6080/vnc_auto.html<br></code></pre></td></tr></table></figure><p>在[glance]部分，配置镜像服务API的地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[glance]<br>api_servers = http://controller:9292<br></code></pre></td></tr></table></figure><p>在[oslo_concurrency]部分，配置lock path：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[oslo_concurrency]<br>lock_path = /var/lib/nova/tmp<br></code></pre></td></tr></table></figure><p>[placement]部分，配置placement服务的入口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[placement]<br>region_name = RegionOne<br>project_domain_name = Default<br>project_name = service<br>auth_type = password<br>user_domain_name = Default<br>auth_url = http://controller:5000/v3<br>username = placement<br>password = 000000<br></code></pre></td></tr></table></figure><p>3、确认计算节点是否支持虚拟机硬件加速（x86_64）</p><p>处理器为x86_64架构时，可通过运行如下命令确认是否支持硬件加速：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">egrep -c <span class="hljs-string">&#x27;(vmx|svm)&#x27;</span> /proc/cpuinfo<br></code></pre></td></tr></table></figure><p>如果返回值为0则不支持硬件加速，需要配置libvirt使用QEMU而不是默认的KVM。编辑&#x2F;etc&#x2F;nova&#x2F;nova.conf的[libvirt]部分：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[libvirt]<br>virt_type = qemu<br>如果返回值为1或更大的值，则支持硬件加速，不需要进行额外的配置。<br></code></pre></td></tr></table></figure><p>4、启动服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x /etc/rc.d/rc.local<br>systemctl <span class="hljs-built_in">enable</span> libvirtd.service openstack-nova-compute.service<br>systemctl start libvirtd.service openstack-nova-compute.service<br></code></pre></td></tr></table></figure><p><strong>compute2（Ubuntu）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">apt install nova-compute -y<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vi /etc/nova/nova.conf<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 增加内容</span><br>[DEFAULT]<br>transport_url = rabbit://openstack:000000@controller<br>my_ip = 10.100.192.94<br><br>[api]<br>auth_strategy = keystone<br><br>[keystone_authtoken]<br>www_authenticate_uri = http://controller:5000/<br>auth_url = http://controller:5000/<br>memcached_servers = controller:11211<br>auth_type = password<br>project_domain_name = Default<br>user_domain_name = Default<br>project_name = service<br>username = nova<br>password = 000000<br><br>[vnc]<br>enabled = <span class="hljs-literal">true</span><br>server_listen = <span class="hljs-variable">$my_ip</span><br>server_proxyclient_address = <span class="hljs-variable">$my_ip</span><br>novncproxy_base_url = http://controller:6080/vnc_auto.html<br><br>[glance]<br>api_servers = http://controller:9292<br><br>[oslo_concurrency]<br>lock_path = /var/lib/nova/tmp<br><br>[placement]<br>region_name = RegionOne<br>project_domain_name = Default<br>project_name = service<br>auth_type = password<br>user_domain_name = Default<br>auth_url = http://controller:5000/v3<br>username = placement<br>password = 000000<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service nova-compute restart<br></code></pre></td></tr></table></figure><p><strong>controller</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">. admin-openrc<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack compute service list --service nova-compute<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">su -s /bin/sh -c <span class="hljs-string">&quot;nova-manage cell_v2 discover_hosts --verbose&quot;</span> nova<br></code></pre></td></tr></table></figure><p>验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack compute service list<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack catalog list<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack image list<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">nova-status upgrade check<br></code></pre></td></tr></table></figure><h3 id="9、安装neutron"><a href="#9、安装neutron" class="headerlink" title="9、安装neutron"></a>9、安装neutron</h3><p><strong>controller</strong></p><p>创建数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">mysql<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">CREATE DATABASE neutron;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">GRANT ALL PRIVILEGES ON neutron.* TO <span class="hljs-string">&#x27;neutron&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>  IDENTIFIED BY <span class="hljs-string">&#x27;000000&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">GRANT ALL PRIVILEGES ON neutron.* TO <span class="hljs-string">&#x27;neutron&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;000000&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">. admin-openrc<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack user create --domain default --password-prompt neutron<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack role add --project service --user neutron admin<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack service create --name neutron --description <span class="hljs-string">&quot;OpenStack Networking&quot;</span> network<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack endpoint create --region RegionOne network public http://controller:9696<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack endpoint create --region RegionOne network internal http://controller:9696<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack endpoint create --region RegionOne network admin http://controller:9696<br></code></pre></td></tr></table></figure><p>安装并配置相关软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">apt install neutron-server neutron-plugin-ml2 \<br>  neutron-linuxbridge-agent neutron-l3-agent neutron-dhcp-agent \<br>  neutron-metadata-agent -y<br></code></pre></td></tr></table></figure><p>配置服务器组件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vi /etc/neutron/neutron.conf<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 修改内容</span><br>[DEFAULT]<br>core_plugin = ml2<br>service_plugins = router<br>allow_overlapping_ips = <span class="hljs-literal">true</span><br>transport_url = rabbit://openstack:000000@controller<br>auth_strategy = keystone<br>notify_nova_on_port_status_changes = <span class="hljs-literal">true</span><br>notify_nova_on_port_data_changes = <span class="hljs-literal">true</span><br><br>[database]<br>connection = mysql+pymysql://neutron:000000@controller/neutron<br><br>[keystone_authtoken]<br>www_authenticate_uri = http://controller:5000<br>auth_url = http://controller:5000<br>memcached_servers = controller:11211<br>auth_type = password<br>project_domain_name = default<br>user_domain_name = default<br>project_name = service<br>username = neutron<br>password = 000000<br><br>[nova]<br>auth_url = http://controller:5000<br>auth_type = password<br>project_domain_name = default<br>user_domain_name = default<br>region_name = RegionOne<br>project_name = service<br>username = nova<br>password = 000000<br><br>[oslo_concurrency]<br>lock_path = /var/lib/neutron/tmp<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vi /etc/neutron/plugins/ml2/ml2_conf.ini<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 修改内容</span><br>[ml2]<br>type_drivers = flat,vlan,vxlan<br>tenant_network_types = flat<br>mechanism_drivers = linuxbridge,l2population<br>extension_drivers = port_security<br><br>[ml2_type_flat]<br>flat_networks = provider<br><br>[ml2_type_vxlan]<br>vni_ranges = 1:1000<br><br>[securitygroup]<br>enable_ipset = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vi /etc/neutron/plugins/ml2/linuxbridge_agent.ini<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 修改内容</span><br>[linux_bridge]<br>physical_interface_mappings = provider:enxf8e43b63eb2f<br><br>[vxlan]<br>enable_vxlan = <span class="hljs-literal">false</span><br>local_ip = 10.100.192.79<br>l2_population = <span class="hljs-literal">true</span><br><br>[securitygroup]<br>enable_security_group = <span class="hljs-literal">true</span><br>firewall_driver = neutron.agent.linux.iptables_firewall.IptablesFirewallDriver<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vi /etc/neutron/l3_agent.ini<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 修改内容</span><br>[DEFAULT]<br>interface_driver = linuxbridge<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vi /etc/neutron/dhcp_agent.ini<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 修改内容</span><br>[DEFAULT]<br>interface_driver = linuxbridge<br>dhcp_driver = neutron.agent.linux.dhcp.Dnsmasq<br>enable_isolated_metadata = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vi /etc/neutron/metadata_agent.ini<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 修改内容</span><br>[DEFAULT]<br>nova_metadata_host = controller<br>metadata_proxy_shared_secret = 000000<br></code></pre></td></tr></table></figure><p>配置Compute 服务以使用Networking 服务</p><p>必须安装 Nova 计算服务才能完成此步骤。</p><p>编辑<code>/etc/nova/nova.conf</code>文件并执行以下操作：</p><p>在该[neutron]部分中，配置访问参数，启用元数据代理，并配置密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vi /etc/nova/nova.conf<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 修改内容</span><br><br>[neutron]<br>auth_url = http://controller:5000<br>auth_type = password<br>project_domain_name = default<br>user_domain_name = default<br>region_name = RegionOne<br>project_name = service<br>username = neutron<br>password = 000000<br>service_metadata_proxy = <span class="hljs-literal">true</span><br>metadata_proxy_shared_secret = 000000<br></code></pre></td></tr></table></figure><p>向数据库中导入neutron的数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">su -s /bin/sh -c <span class="hljs-string">&quot;neutron-db-manage --config-file /etc/neutron/neutron.conf \</span><br><span class="hljs-string">--config-file /etc/neutron/plugins/ml2/ml2_conf.ini upgrade head&quot;</span> neutron<br></code></pre></td></tr></table></figure><p>由于脚本需要完整的服务器和插件配置文件，因此 Networking 的数据库填充发生在</p><p>重启计算 API 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service nova-api restart<br></code></pre></td></tr></table></figure><p>重新启动网络服务。<br>对于两个网络选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service neutron-server restart<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service neutron-linuxbridge-agent restart<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service neutron-dhcp-agent restart<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service neutron-metadata-agent restart<br></code></pre></td></tr></table></figure><p>对于网络选项 2，还要重新启动第 3 层服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service neutron-l3-agent restart<br></code></pre></td></tr></table></figure><p>执行命令查看neutron安装是否成功 -无结果，没有成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack network agent list<br></code></pre></td></tr></table></figure><p><strong>compute1(OpenEuler X86)</strong></p><ol><li>安装软件包</li></ol> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dnf install openstack-neutron-linuxbridge ebtables ipset -y<br></code></pre></td></tr></table></figure><ol start="2"><li>配置Neutron</li></ol><p>修改<code>/etc/neutron/neutron.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">[DEFAULT]<br>transport_url = rabbit://openstack:000000@controller<br>auth_strategy = keystone<br><br>[keystone_authtoken]<br>www_authenticate_uri = http://controller:5000<br>auth_url = http://controller:5000<br>memcached_servers = controller:11211<br>auth_type = password<br>project_domain_name = Default<br>user_domain_name = Default<br>project_name = service<br>username = neutron<br>password = 000000<br><br>[oslo_concurrency]<br>lock_path = /var/lib/neutron/tmp<br></code></pre></td></tr></table></figure><p>修改 <code>/etc/neutron/plugins/ml2/linuxbridge_agent.ini</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">[linux_bridge]<br>physical_interface_mappings = provider:ens3<br><br>[vxlan]<br>enable_vxlan = <span class="hljs-literal">true</span><br>local_ip = 10.12.193.53<br>l2_population = <span class="hljs-literal">true</span><br><br>[securitygroup]<br>enable_security_group = <span class="hljs-literal">true</span><br>firewall_driver = neutron.agent.linux.iptables_firewall.IptablesFirewallDriver<br></code></pre></td></tr></table></figure><p>配置nova compute服务使用neutron，修改<code>/etc/nova/nova.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[neutron]<br>auth_url = http://controller:5000<br>auth_type = password<br>project_domain_name = default<br>user_domain_name = default<br>region_name = RegionOne<br>project_name = service<br>username = neutron<br>password = 000000<br></code></pre></td></tr></table></figure><p>重启nova-compute服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl restart openstack-nova-compute.service<br></code></pre></td></tr></table></figure><p>启动Neutron linuxbridge agent服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> neutron-linuxbridge-agent<br>systemctl start neutron-linuxbridge-agent<br></code></pre></td></tr></table></figure><p><strong>compute2</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">apt install neutron-linuxbridge-agent -y<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vim /etc/neutron/neutron.conf<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 修改内容</span><br>[DEFAULT]<br>core_plugin = ml2<br>transport_url = rabbit://openstack:000000@controller<br>auth_strategy = keystone<br><br>[keystone_authtoken]<br>www_authenticate_uri = http://controller:5000<br>auth_url = http://controller:5000<br>memcached_servers = controller:11211<br>auth_type = password<br>project_domain_name = default<br>user_domain_name = default<br>project_name = service<br>username = neutron<br>password = 000000<br><br>[oslo_concurrency]<br>lock_path = /var/lib/neutron/tmp<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vi /etc/neutron/plugins/ml2/linuxbridge_agent.ini<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 修改内容</span><br>[linux_bridge]<br>physical_interface_mappings = provider:enx00e04c680218<br><br>[vxlan]<br>enable_vxlan = <span class="hljs-literal">false</span><br>local_ip = 10.100.192.94<br>l2_population = <span class="hljs-literal">true</span><br><br>[securitygroup]<br>enable_security_group = <span class="hljs-literal">true</span><br>firewall_driver = neutron.agent.linux.iptables_firewall.IptablesFirewallDriver<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vi /etc/nova/nova.conf<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 修改内容</span><br>[neutron]<br>auth_url = http://controller:5000<br>auth_type = password<br>project_domain_name = default<br>user_domain_name = default<br>region_name = RegionOne<br>project_name = service<br>username = neutron<br>password = 000000<br></code></pre></td></tr></table></figure><p>重启计算服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service nova-compute restart<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service neutron-linuxbridge-agent restart<br></code></pre></td></tr></table></figure><p>验证</p><p><strong>controller</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">. admin-openrc<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack network agent list<br></code></pre></td></tr></table></figure><h3 id="10、安装dashboard"><a href="#10、安装dashboard" class="headerlink" title="10、安装dashboard"></a>10、安装dashboard</h3><p>安装并配置相关软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">apt install openstack-dashboard -y<br></code></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vi /etc/openstack-dashboard/local_settings.py<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 搜索&#x27;OPENSTACK_HOST&#x27;并修改如下</span><br>OPENSTACK_HOST = <span class="hljs-string">&quot;10.100.192.92&quot;</span><br><br><span class="hljs-comment"># 搜索&#x27;LOCATION&#x27;并修改如下</span><br><span class="hljs-string">&#x27;LOCATION&#x27;</span>: <span class="hljs-string">&#x27;controller:11211&#x27;</span>,<br><br><span class="hljs-comment"># 搜索&#x27;TIME_ZONE&#x27;并修改如下 </span><br>TIME_ZONE = <span class="hljs-string">&quot;Asia/Shanghai&quot;</span><br><br>OPENSTACK_KEYSTONE_URL = <span class="hljs-string">&quot;http://%s:5000/v3&quot;</span> % OPENSTACK_HOST<br><br>OPENSTACK_KEYSTONE_MULTIDOMAIN_SUPPORT = True<br>OPENSTACK_KEYSTONE_DEFAULT_DOMAIN = <span class="hljs-string">&quot;Default&quot;</span><br>OPENSTACK_KEYSTONE_DEFAULT_ROLE = <span class="hljs-string">&quot;user&quot;</span><br>SESSION_ENGINE = <span class="hljs-string">&#x27;django.contrib.sessions.backends.file&#x27;</span><br>OPENSTACK_API_VERSIONS = &#123;<br>    <span class="hljs-string">&quot;identity&quot;</span>: 3,<br>    <span class="hljs-string">&quot;image&quot;</span>: 2,<br>    <span class="hljs-string">&quot;volume&quot;</span>: 3,<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">systemctl reload apache2.service<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service apache2 restart<br></code></pre></td></tr></table></figure><h3 id="11、-创建实例"><a href="#11、-创建实例" class="headerlink" title="11、 创建实例"></a>11、 创建实例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">source</span> admin-openrc<br></code></pre></td></tr></table></figure><p>创建一个虚拟机类型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack flavor create --<span class="hljs-built_in">id</span> 0 --vcpus 1 --ram 64 --disk 1 m1.nano<br></code></pre></td></tr></table></figure><p>ssh远程登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">. demo-openrc<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ssh-keygen -q -N <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><ul><li><code>-q</code> 选项表示静默模式，即在生成密钥对的过程中不会输出任何提示信息或警告。</li><li><code>-N</code> 选项后面可以跟一个密码作为参数。该密码将用于保护生成的私钥文件。如果不指定 <code>-N</code> 参数，则私钥文件将不受密码保护。</li></ul><p>创建秘钥对</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack keypair create --public-key ~/.ssh/id_rsa.pub mykey<br></code></pre></td></tr></table></figure><p>查看秘钥对</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack keypair list<br></code></pre></td></tr></table></figure><p>创建类型为<code>provider</code>，名字为<code>public</code>的网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">source</span> admin-openrc<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack network create  --share --external \<br>  --provider-physical-network provider \<br>  --provider-network-type flat provider<br></code></pre></td></tr></table></figure><p>在<code>public</code>上创建一个子网<code>public_net</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack subnet create --network provider \<br>  --allocation-pool start=10.100.192.50,end=10.100.192.100 \<br>  --dns-nameserver 8.8.8.8 --gateway 10.100.192.1 \<br>  --subnet-range 10.100.192.0/24 provider<br></code></pre></td></tr></table></figure><p>添加安全组规则，允许ping和ssh到虚拟机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">source</span> demo-openrc<br></code></pre></td></tr></table></figure><p>添加icmp协议</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack security group rule create --proto icmp default<br></code></pre></td></tr></table></figure><p>添加tcp协议</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack security group rule create --proto tcp --dst-port 22 default<br></code></pre></td></tr></table></figure><p>创建内部网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack network create selfservice<br></code></pre></td></tr></table></figure><p>创建内部网络子网</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack subnet create --network selfservice \<br>  --dns-nameserver 192.168.3.1 --gateway 192.168.10.1 \<br>  --subnet-range 192.168.10.0/24 selfservice<br></code></pre></td></tr></table></figure><p>创建实例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">openstack server create --flavor m1.nano --image cirros --nic net-id=3d4fdcc0-25a1-49e8-8f11-4b20bd1fe52e --security-group default vm<br></code></pre></td></tr></table></figure><p>修改实例的 Mac 地址并查看 ID 地址的 Port ID</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">neutron port-list<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@controller:~<span class="hljs-comment"># neutron port-list</span><br>neutron CLI is deprecated and will be removed <span class="hljs-keyword">in</span> the Z cycle. Use openstack CLI instead.<br>+--------------------------------------+------+----------------------------------+-------------------+--------------------------------------------------------------------------------------+<br>| <span class="hljs-built_in">id</span>                                   | name | tenant_id                        | mac_address       | fixed_ips                                                                            |<br>+--------------------------------------+------+----------------------------------+-------------------+--------------------------------------------------------------------------------------+<br>| 3a9268d0-56e5-4d30-b81c-6692c50f7648 |      | b9f9c436ebb04a42a9d764e0eab068b5 | fa:16:3e:74:4f:b7 | &#123;<span class="hljs-string">&quot;subnet_id&quot;</span>: <span class="hljs-string">&quot;2326cbde-c3d2-4982-8b00-c29bfe8b11b1&quot;</span>, <span class="hljs-string">&quot;ip_address&quot;</span>: <span class="hljs-string">&quot;10.100.192.88&quot;</span>&#125; |<br>| 638e755f-5bb9-404a-ad7a-8e75ee0c92b9 |      | b9f9c436ebb04a42a9d764e0eab068b5 | fa:16:3e:ff:a0:2e | &#123;<span class="hljs-string">&quot;subnet_id&quot;</span>: <span class="hljs-string">&quot;2326cbde-c3d2-4982-8b00-c29bfe8b11b1&quot;</span>, <span class="hljs-string">&quot;ip_address&quot;</span>: <span class="hljs-string">&quot;10.100.192.50&quot;</span>&#125; |<br>| bfc91685-c9ee-41f9-af5a-d725a944d1b0 |      | b9f9c436ebb04a42a9d764e0eab068b5 | e0:be:03:88:54:e8 | &#123;<span class="hljs-string">&quot;subnet_id&quot;</span>: <span class="hljs-string">&quot;2326cbde-c3d2-4982-8b00-c29bfe8b11b1&quot;</span>, <span class="hljs-string">&quot;ip_address&quot;</span>: <span class="hljs-string">&quot;10.100.192.53&quot;</span>&#125; |<br>| cb90cb52-e95a-4c6e-8e9e-c9afaa700b28 |      | b9f9c436ebb04a42a9d764e0eab068b5 | fa:16:3e:be:42:cf | &#123;<span class="hljs-string">&quot;subnet_id&quot;</span>: <span class="hljs-string">&quot;2326cbde-c3d2-4982-8b00-c29bfe8b11b1&quot;</span>, <span class="hljs-string">&quot;ip_address&quot;</span>: <span class="hljs-string">&quot;10.100.192.96&quot;</span>&#125; |<br>+--------------------------------------+------+----------------------------------+-------------------+--------------------------------------------------------------------------------------+<br></code></pre></td></tr></table></figure><p>查看虚拟机 ID</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nova list<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@controller:~<span class="hljs-comment"># nova list</span><br>+--------------------------------------+---------------+--------+------------+-------------+----------------------+<br>| ID                                   | Name          | Status | Task State | Power State | Networks             |<br>+--------------------------------------+---------------+--------+------------+-------------+----------------------+<br>| d5257795-5ff2-4cce-b430-e7a2b29a62fe | openeuler2209 | ACTIVE | -          | Running     | public=10.100.192.96 |<br>| 8381931e-5114-442d-ba28-a693516f1c4c | vm10          | ACTIVE | -          | Running     | public=10.100.192.53 |<br>| 714588ac-862d-495a-aef1-9d36301fcae7 | vm11          | ACTIVE | -          | Running     | public=10.100.192.88 |<br>+--------------------------------------+---------------+--------+------------+-------------+----------------------+<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nova interface-list <span class="hljs-string">&quot;ID&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@controller:~<span class="hljs-comment"># nova interface-list d5257795-5ff2-4cce-b430-e7a2b29a62fe</span><br>+------------+--------------------------------------+--------------------------------------+---------------+-------------------+-----+<br>| Port State | Port ID                              | Net ID                               | IP addresses  | MAC Addr          | Tag |<br>+------------+--------------------------------------+--------------------------------------+---------------+-------------------+-----+<br>| BUILD      | cb90cb52-e95a-4c6e-8e9e-c9afaa700b28 | 8d3c368e-9b36-4f73-91bc-b0b2d3b6cd14 | 10.100.192.96 | fa:16:3e:be:42:cf | -   |<br>+------------+--------------------------------------+--------------------------------------+---------------+-------------------+-----+<br></code></pre></td></tr></table></figure><p>解绑当前 IP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nova interface-detach <span class="hljs-string">&quot;ID&quot;</span> <span class="hljs-string">&quot;Port ID&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@controller:~<span class="hljs-comment"># nova interface-detach 8381931e-5114-442d-ba28-a693516f1c4c bfc91685-c9ee-41f9-af5a-d725a944d1b0</span><br></code></pre></td></tr></table></figure><p>查看网络 Net-list 和子网 Subnet-list</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">neutron net-list<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">neutron subnet-list<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@controller:~<span class="hljs-comment"># neutron subnet-list</span><br>neutron CLI is deprecated and will be removed <span class="hljs-keyword">in</span> the Z cycle. Use openstack CLI instead.<br>+--------------------------------------+---------------+----------------------------------+-----------------+-----------------------------------------------------+<br>| <span class="hljs-built_in">id</span>                                   | name          | tenant_id                        | cidr            | allocation_pools                                    |<br>+--------------------------------------+---------------+----------------------------------+-----------------+-----------------------------------------------------+<br>| 2326cbde-c3d2-4982-8b00-c29bfe8b11b1 | public_subnet | b9f9c436ebb04a42a9d764e0eab068b5 | 10.100.192.0/24 | &#123;<span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-string">&quot;10.100.192.50&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>: <span class="hljs-string">&quot;10.100.192.100&quot;</span>&#125; |<br>+--------------------------------------+---------------+----------------------------------+-----------------+-----------------------------------------------------+<br></code></pre></td></tr></table></figure><p>创建一个 Port 指定 MAC 地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">neutron port-create --fixed-ip subnet_id=2326cbde-c3d2-4982-8b00-c29bfe8b11b1(subnet),ip_address=10.100.192.96 --mac-address e0:be:03:88:54:e9 8d3c368e-9b36-4f73-91bc-b0b2d3b6cd14(net)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">+-----------------------+--------------------------------------------------------------------------------------+<br>| Field                 | Value                                                                                |<br>+-----------------------+--------------------------------------------------------------------------------------+<br>| admin_state_up        | True                                                                                 |<br>| allowed_address_pairs |                                                                                      |<br>| binding:host_id       |                                                                                      |<br>| binding:profile       | &#123;&#125;                                                                                   |<br>| binding:vif_details   | &#123;&#125;                                                                                   |<br>| binding:vif_type      | unbound                                                                              |<br>| binding:vnic_type     | normal                                                                               |<br>| created_at            | 2023-08-10T05:38:47Z                                                                 |<br>| description           |                                                                                      |<br>| device_id             |                                                                                      |<br>| device_owner          |                                                                                      |<br>| extra_dhcp_opts       |                                                                                      |<br>| fixed_ips             | &#123;<span class="hljs-string">&quot;subnet_id&quot;</span>: <span class="hljs-string">&quot;2326cbde-c3d2-4982-8b00-c29bfe8b11b1&quot;</span>, <span class="hljs-string">&quot;ip_address&quot;</span>: <span class="hljs-string">&quot;10.100.192.96&quot;</span>&#125; |<br>| <span class="hljs-built_in">id</span>                    | 66365266-0487-4898-a39c-25640fd6b5dc                                                 |<br>| mac_address           | e0:be:03:88:54:e9                                                                    |<br>| name                  |                                                                                      |<br>| network_id            | 8d3c368e-9b36-4f73-91bc-b0b2d3b6cd14                                                 |<br>| port_security_enabled | True                                                                                 |<br>| project_id            | b9f9c436ebb04a42a9d764e0eab068b5                                                     |<br>| revision_number       | 1                                                                                    |<br>| security_groups       | e852881b-50fb-4648-8e44-35c2f6d12af3                                                 |<br>| status                | DOWN                                                                                 |<br>| tags                  |                                                                                      |<br>| tenant_id             | b9f9c436ebb04a42a9d764e0eab068b5                                                     |<br>| updated_at            | 2023-08-10T05:38:48Z                                                                 |<br>+-----------------------+--------------------------------------------------------------------------------------+<br></code></pre></td></tr></table></figure><p>把 Port Attach 到虚拟机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nova interface-attach d5257795-5ff2-4cce-b430-e7a2b29a62fe --port-id 66365266-0487-4898-a39c-25640fd6b5dc<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">+------------+--------------------------------------+<br>| Property   | Value                                |<br>+------------+--------------------------------------+<br>| ip_address | 10.100.192.96                        |<br>| mac_addr   | e0:be:03:88:54:e9                    |<br>| net_id     | 8d3c368e-9b36-4f73-91bc-b0b2d3b6cd14 |<br>| port_id    | 66365266-0487-4898-a39c-25640fd6b5dc |<br>| port_state | DOWN                                 |<br>| tag        | -                                    |<br>+------------+--------------------------------------+<br></code></pre></td></tr></table></figure><p>Controller</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@controller:~<span class="hljs-comment"># ifconfig </span><br>brq8d3c368e-9b: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 10.100.192.92  netmask 255.255.254.0  broadcast 10.100.193.255<br>        ether f8:e4:3b:63:eb:2f  txqueuelen 1000  (Ethernet)<br>        RX packets 5915428  bytes 6997533910 (6.9 GB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 5405890  bytes 10408992759 (10.4 GB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500<br>        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255<br>        ether 02:42:1d:8e:3c:d1  txqueuelen 0  (Ethernet)<br>        RX packets 0  bytes 0 (0.0 B)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 0  bytes 0 (0.0 B)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>enp2s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 10.100.192.79  netmask 255.255.254.0  broadcast 10.100.193.255<br>        inet6 fe80::2bc8:6996:aabc:b44  prefixlen 64  scopeid 0x20&lt;<span class="hljs-built_in">link</span>&gt;<br>        ether e0:be:03:88:ee:cb  txqueuelen 1000  (Ethernet)<br>        RX packets 4983510  bytes 1342995804 (1.3 GB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 432797  bytes 347422676 (347.4 MB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>enxf8e43b63eb2f: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 10.100.192.92  netmask 255.255.254.0  broadcast 10.100.193.255<br>        inet6 fe80::759b:702c:b49a:39ae  prefixlen 64  scopeid 0x20&lt;<span class="hljs-built_in">link</span>&gt;<br>        ether f8:e4:3b:63:eb:2f  txqueuelen 1000  (Ethernet)<br>        RX packets 2513156  bytes 2952978665 (2.9 GB)<br>        RX errors 0  dropped 917  overruns 0  frame 0<br>        TX packets 1819723  bytes 1557298439 (1.5 GB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536<br>        inet 127.0.0.1  netmask 255.0.0.0<br>        loop  txqueuelen 1000  (Local Loopback)<br>        RX packets 16803159  bytes 10055108231 (10.0 GB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 16803159  bytes 10055108231 (10.0 GB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>tap638e755f-5b: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        ether d2:a8:e4:03:71:4e  txqueuelen 1000  (Ethernet)<br>        RX packets 129  bytes 10944 (10.9 KB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 62611  bytes 4787883 (4.7 MB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br></code></pre></td></tr></table></figure><p>Compute</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@compute2:~<span class="hljs-comment"># ifconfig </span><br>brq8d3c368e-9b: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 10.100.192.93  netmask 255.255.254.0  broadcast 10.100.193.255<br>        ether 00:e0:4c:68:02:18  txqueuelen 1000  (Ethernet)<br>        RX packets 1710244  bytes 1636482655 (1.6 GB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 1325319  bytes 251080446 (251.0 MB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>eno1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 10.100.192.94  netmask 255.255.254.0  broadcast 10.100.193.255<br>        inet6 fe80::1dfe:2a01:4237:a169  prefixlen 64  scopeid 0x20&lt;<span class="hljs-built_in">link</span>&gt;<br>        ether 80:e8:2c:ca:49:7e  txqueuelen 1000  (Ethernet)<br>        RX packets 492369  bytes 38557253 (38.5 MB)<br>        RX errors 0  dropped 5  overruns 0  frame 0<br>        TX packets 7092  bytes 647907 (647.9 KB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br>        device interrupt 16  memory 0xf1100000-f1120000  <br><br>enx00e04c680218: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 10.100.192.93  netmask 255.255.254.0  broadcast 10.100.193.255<br>        inet6 fe80::d7c4:b50:8ffa:b171  prefixlen 64  scopeid 0x20&lt;<span class="hljs-built_in">link</span>&gt;<br>        ether 00:e0:4c:68:02:18  txqueuelen 1000  (Ethernet)<br>        RX packets 1869249  bytes 1668190374 (1.6 GB)<br>        RX errors 0  dropped 3135  overruns 0  frame 0<br>        TX packets 1462894  bytes 240742887 (240.7 MB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536<br>        inet 127.0.0.1  netmask 255.0.0.0<br>        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;<br>        loop  txqueuelen 1000  (Local Loopback)<br>        RX packets 595201  bytes 46392915 (46.3 MB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 595201  bytes 46392915 (46.3 MB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>tap3a9268d0-56: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet6 fe80::fc16:3eff:fe74:4fb7  prefixlen 64  scopeid 0x20&lt;<span class="hljs-built_in">link</span>&gt;<br>        ether fe:16:3e:74:4f:b7  txqueuelen 1000  (Ethernet)<br>        RX packets 1186  bytes 102252 (102.2 KB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 233618  bytes 14976194 (14.9 MB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>tap66365266-04: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet6 fe80::fcbe:3ff:fe88:54e9  prefixlen 64  scopeid 0x20&lt;<span class="hljs-built_in">link</span>&gt;<br>        ether fe:be:03:88:54:e9  txqueuelen 1000  (Ethernet)<br>        RX packets 3737  bytes 271987 (271.9 KB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 38787  bytes 33210607 (33.2 MB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>virbr0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500<br>        inet 192.168.122.1  netmask 255.255.255.0  broadcast 192.168.122.255<br>        ether 52:54:00:5c:40:e6  txqueuelen 1000  (Ethernet)<br>        RX packets 0  bytes 0 (0.0 B)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 0  bytes 0 (0.0 B)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br></code></pre></td></tr></table></figure><h3 id="Bug-总结"><a href="#Bug-总结" class="headerlink" title="Bug 总结"></a>Bug 总结</h3><p><code>subprocess installed post-installation script returned error exit status 10</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">rm</span> /var/lib/dpkg/info/r-base-core*<br>sudo dpkg --configure -D 777 r-base-core<br>sudo apt -f install<br></code></pre></td></tr></table></figure><p><code>openstack通过dashboard云主机控制台访问时异常</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/nova/nova.conf<br><br><br>[vnc] <br>enabled = True <br>vncserver_listen = 0.0.0.0 <br>vncserver_proxyclient_address = <span class="hljs-variable">$my_ip</span> <br>novncproxy_base_url = http://controller:6080/vnc_auto.html<br><br><span class="hljs-comment"># controller 修改为具体的 IP</span><br></code></pre></td></tr></table></figure><p><code>Openstack Nova Failed to allocate network(s)</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/nova/nova.conf<br><br><span class="hljs-comment">#Fail instance boot if vif plugging fails  </span><br>vif_plugging_is_fatal = False  <br><br><span class="hljs-comment">#Number of seconds to wait for neutron vif  </span><br><span class="hljs-comment">#plugging events to arrive before continuing or failing  </span><br><span class="hljs-comment">#(see vif_plugging_is_fatal). If this is set to zero and  </span><br><span class="hljs-comment">#vif_plugging_is_fatal is False, events should not be expected to arrive at all.  </span><br>vif_plugging_timeout = 0  <br></code></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/hhsh/p/16414025.html#openstack_125">https://www.cnblogs.com/hhsh/p/16414025.html#openstack_125</a></p><p><a href="https://blog.csdn.net/w975121565/article/details/127460218">https://blog.csdn.net/w975121565/article/details/127460218</a></p><p><a href="https://blog.csdn.net/zuopiezia/article/details/118972094">https://blog.csdn.net/zuopiezia/article/details/118972094</a></p><p><a href="https://www.cnblogs.com/omgasw/p/12023433.html">https://www.cnblogs.com/omgasw/p/12023433.html</a></p><p><a href="https://blog.csdn.net/weiqing1995/article/details/81908023">https://blog.csdn.net/weiqing1995/article/details/81908023</a></p>]]></content>
    
    
    <categories>
      
      <category>OpenStack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于CentOS部署OpenStack</title>
    <link href="/2023/07/06/%E5%9F%BA%E4%BA%8ECentOS%E9%83%A8%E7%BD%B2OpenStack/"/>
    <url>/2023/07/06/%E5%9F%BA%E4%BA%8ECentOS%E9%83%A8%E7%BD%B2OpenStack/</url>
    
    <content type="html"><![CDATA[<h2 id="1-安装CentoS7虚拟机"><a href="#1-安装CentoS7虚拟机" class="headerlink" title="1. 安装CentoS7虚拟机"></a>1. 安装CentoS7虚拟机</h2><p>使用VirtualBox安装虚拟机小伙伴们应该都很熟悉了，这里只标识出我选择的<a href="https://mirrors.aliyun.com/centos/7/isos/x86_64/">CentOS7版本</a>。</p><p><img src="/../image/centos%E4%B8%8B%E8%BD%BD.png" alt="centos下载"></p><h2 id="2-系统配置"><a href="#2-系统配置" class="headerlink" title="2. 系统配置"></a>2. 系统配置</h2><p>我在安装时选择了最小安装的模式，在CentOS7安装完成后只有终端操作界面，没有对应的UI界面。</p><h3 id="2-1-以root账户登录"><a href="#2-1-以root账户登录" class="headerlink" title="2.1 以root账户登录"></a>2.1 以root账户登录</h3><p><img src="/../image/root%E7%99%BB%E9%99%86.png" alt="root登陆"></p><h3 id="2-2-生成动态IP地址"><a href="#2-2-生成动态IP地址" class="headerlink" title="2.2 生成动态IP地址"></a>2.2 生成动态IP地址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">dhclient<br></code></pre></td></tr></table></figure><h3 id="2-3-查看生成的IP地址"><a href="#2-3-查看生成的IP地址" class="headerlink" title="2.3 查看生成的IP地址"></a>2.3 查看生成的IP地址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ip addr<br></code></pre></td></tr></table></figure><p><img src="/../image/ip%E5%9C%B0%E5%9D%80.png" alt="ip地址"></p><p>记住 <code>10.0.2.15</code> 的 IP 地址，后续配网时需要用到。</p><h3 id="2-4-修改网络"><a href="#2-4-修改网络" class="headerlink" title="2.4 修改网络"></a>2.4 修改网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> /etc/sysconfig/network-scripts/<br><span class="hljs-built_in">ls</span><br>vi ifcfg-enp0s3<br></code></pre></td></tr></table></figure><p><img src="/../image/%E7%BD%91%E5%8D%A1%E5%9C%B0%E5%9D%80.png" alt="网卡地址"></p><p><img src="/../image/%E7%BD%91%E5%8D%A1%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF.png" alt="网卡配置信息"></p><h3 id="2-5-重启网卡"><a href="#2-5-重启网卡" class="headerlink" title="2.5 重启网卡"></a>2.5 重启网卡</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">systemctl restart network<br></code></pre></td></tr></table></figure><h3 id="2-6-禁止-SELinux"><a href="#2-6-禁止-SELinux" class="headerlink" title="2.6 禁止 SELinux"></a>2.6 禁止 SELinux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vi /etc/selinux/config<br><span class="hljs-comment"># SELINUX=enforcing 改为 SELINUX=disabled</span><br></code></pre></td></tr></table></figure><p><img src="/../image/selinux%E9%85%8D%E7%BD%AE.png" alt="selinux配置"></p><p>原因：SELinux主要作用是最大限度的减少系统中服务进程可访问的资源（最小资源原则）。linux中默认开启了防火墙，SELinux也处于启动状态，一般状态为enforing，导致很多服务端口默认为关闭状态。</p><p>SELinux有三种工作模式，分别是：</p><ol><li>enforing：强制模式。违反SELinux规则的行为将被阻止并记录到日志中；</li><li>permissive：宽容模式，违反SELinux规则的行为只会记录到日志中，一般为调试用。</li><li>disabled：关闭SELinux。</li></ol><p>这里注意，设置<code>SELINUX=disabled</code>后，必须要<strong>重启</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">reboot<br></code></pre></td></tr></table></figure><h3 id="2-7-停用-NetworkManager-服务"><a href="#2-7-停用-NetworkManager-服务" class="headerlink" title="2.7 停用 NetworkManager 服务"></a>2.7 停用 NetworkManager 服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">systemctl <span class="hljs-built_in">disable</span> NetworkManager<br>systemctl stop NetworkManager<br>systemctl <span class="hljs-built_in">enable</span> network<br>systemctl start network<br></code></pre></td></tr></table></figure><p><img src="/../image/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1.png" alt="网络服务"></p><h3 id="2-8-修改主机名以及映射"><a href="#2-8-修改主机名以及映射" class="headerlink" title="2.8 修改主机名以及映射"></a>2.8 修改主机名以及映射</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">hostnamectl set-hostname node-a<br>vi /etc/hosts<br></code></pre></td></tr></table></figure><p><img src="/../image/%E4%B8%BB%E6%9C%BA%E5%90%8D1.png" alt="主机名1"></p><p><img src="/../image/%E4%B8%BB%E6%9C%BA%E5%90%8D2.png" alt="主机名2"></p><h3 id="2-9-安装时间同步软件"><a href="#2-9-安装时间同步软件" class="headerlink" title="2.9 安装时间同步软件"></a>2.9 安装时间同步软件</h3><p>centos7支持chrony时间同步配置，ntp在centos8上已经不再支持。</p><p>Chrony相比ntp时间同步配置更简单更高效，它是一个开源的软件能保持系统始终与服<br>务器时间同步。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">yum install -y chrony<br></code></pre></td></tr></table></figure><h3 id="2-10-添加NTP服务地址"><a href="#2-10-添加NTP服务地址" class="headerlink" title="2.10 添加NTP服务地址"></a>2.10 添加NTP服务地址</h3><p>NTP服务器的地址是为网络上的其他设备提供准确时间信息的服务器的IP地址或主机名。<br>NTP是一种用于通过网络同步计算机和其他设备时钟的协议。通过使用NTP设备可以确保它们的时钟准确且彼此同步，这对于日志记录和事件关联等许多应用程序都很重要。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vi /etc/chrony.conf<br><span class="hljs-comment"># 把阿里云作为时间源：server ntp1.aliyun.com iburst</span><br></code></pre></td></tr></table></figure><h3 id="2-11-准备所需的软件库"><a href="#2-11-准备所需的软件库" class="headerlink" title="2.11 准备所需的软件库"></a>2.11 准备所需的软件库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">yum -y update<br></code></pre></td></tr></table></figure><h3 id="2-12-安装OpenStack仓库"><a href="#2-12-安装OpenStack仓库" class="headerlink" title="2.12 安装OpenStack仓库"></a>2.12 安装OpenStack仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">yum -y install centos-release-openstack-train<br></code></pre></td></tr></table></figure><h3 id="2-13-安装packstack安装器"><a href="#2-13-安装packstack安装器" class="headerlink" title="2.13 安装packstack安装器"></a>2.13 安装packstack安装器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">yum -y update<br><span class="hljs-comment"># 安装 packstack 安装器</span><br>yum -y install openstack-packstack<br></code></pre></td></tr></table></figure><h3 id="2-14运行packstack安装OpenStack"><a href="#2-14运行packstack安装OpenStack" class="headerlink" title="2.14运行packstack安装OpenStack"></a>2.14运行packstack安装OpenStack</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">packstack --allinone<br><span class="hljs-comment"># 查看当前安装版本</span><br>nova-manage --version<br></code></pre></td></tr></table></figure><h3 id="2-15-查看网页的用户名和密码"><a href="#2-15-查看网页的用户名和密码" class="headerlink" title="2.15 查看网页的用户名和密码"></a>2.15 查看网页的用户名和密码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">source</span> keystonerc_admin<br><span class="hljs-built_in">cat</span> keystonerc_admin<br><span class="hljs-built_in">source</span> keystonerc_demo<br><span class="hljs-built_in">cat</span> keystonerc_demo<br><br></code></pre></td></tr></table></figure><h3 id="2-16-安装CentOS桌面"><a href="#2-16-安装CentOS桌面" class="headerlink" title="2.16 安装CentOS桌面"></a>2.16 安装CentOS桌面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 获取并批量以组安装的方式安装CentOS默认的图形界面GNOME程序包</span><br>yum grouplist<br><span class="hljs-comment"># 使用root用户登录 &amp;&amp; 可以访问外网</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y groupinstall <span class="hljs-string">&quot;GNOME Desktop&quot;</span> <span class="hljs-string">&quot;Graphical Administration Tools&quot;</span><br>reboot<br><span class="hljs-comment"># 调整分辨率</span><br>startx<br></code></pre></td></tr></table></figure><p>安装好之后重启系统。</p><h2 id="3-配置网络服务"><a href="#3-配置网络服务" class="headerlink" title="3. 配置网络服务"></a>3. 配置网络服务</h2><p>Openstack云平台默认已经配置了虚拟网络，但由于没有针对实际环境进行配置，即使分配了浮动IP地址，创建的虚拟机实例也不能与外部网络通信。主要的思路是新建路由器将内部网络和外部网络连接。</p><blockquote><p>内部网络：虚拟机实例本身所在的网络<br>外部网络：外部物理网络或外部虚拟网络</p></blockquote><h3 id="3-1查看网桥"><a href="#3-1查看网桥" class="headerlink" title="3.1查看网桥"></a>3.1查看网桥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ovs-vsctl list-br<br><br></code></pre></td></tr></table></figure><h3 id="3-2查看-br-ex-网桥的端口"><a href="#3-2查看-br-ex-网桥的端口" class="headerlink" title="3.2查看 br-ex 网桥的端口"></a>3.2查看 br-ex 网桥的端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ovs-vsctl list-ports br-ex<br><br></code></pre></td></tr></table></figure><blockquote><p>注释：这里出现的enp0s3是因为我配置过，所以才会enp0s3，正常是只有下面一条记录，br-ex网桥只有一个连接集成网桥br-int的Patch端口，没有端口连接到OpenStack主机的外部网络，因此，当前OpenStack云平台上的虚拟机实例无法与外部网络进行通信。</p></blockquote><h3 id="3-3配置网桥"><a href="#3-3配置网桥" class="headerlink" title="3.3配置网桥"></a>3.3配置网桥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> /etc/sysconfig/network-scripts/<br></code></pre></td></tr></table></figure><blockquote><p>注释：在目录下没有<code>ifcfg-br-ex</code>文件，需要新建一个目录。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> ifcfg-enp0s3 ifcfg-br-ex<br></code></pre></td></tr></table></figure><h4 id="3-3-1修改ifcfg-br-ex文件"><a href="#3-3-1修改ifcfg-br-ex文件" class="headerlink" title="3.3.1修改ifcfg-br-ex文件"></a>3.3.1修改ifcfg-br-ex文件</h4><blockquote><p>注释：Open vSwitch（ovs）：开放式虚拟交换机。<br>【TYPE】：OVSBridge<br>【DEVICETYPE】：ovs<br>【NAME】：br-ex<br>【DEVICE】：br-ex</p></blockquote><h4 id="3-3-2修改ifcfg-enp0s3文件"><a href="#3-3-2修改ifcfg-enp0s3文件" class="headerlink" title="3.3.2修改ifcfg-enp0s3文件"></a>3.3.2修改ifcfg-enp0s3文件</h4><blockquote><p>注释：Port是OVS Bridge的端口<br>【TYPE】：OVSPort<br>【DEVICETYPE】：ovs<br>【OVS_BRIDGE】：br-ex</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">TYPE=Ethernet               <span class="hljs-comment"># 网卡类型：为以太网</span><br>PROXY_METHOD=none           <span class="hljs-comment"># 代理方式：关闭状态</span><br>BROWSER_ONLY=no             <span class="hljs-comment"># 只是浏览器：否</span><br>BOOTPROTO=dhcp              <span class="hljs-comment"># 网卡的引导协议：DHCP[中文名称: 动态主机配置协议]</span><br>DEFROUTE=<span class="hljs-built_in">yes</span>                <span class="hljs-comment"># 默认路由：是, 不明白的可以百度关键词 `默认路由` </span><br>IPV4_FAILURE_FATAL=no       <span class="hljs-comment"># 是不开启IPV4致命错误检测：否</span><br>IPV6INIT=<span class="hljs-built_in">yes</span>                <span class="hljs-comment"># IPV6是否自动初始化: 是[不会有任何影响, 现在还没用到IPV6]</span><br>IPV6_AUTOCONF=<span class="hljs-built_in">yes</span>           <span class="hljs-comment"># IPV6是否自动配置：是[不会有任何影响, 现在还没用到IPV6]</span><br>IPV6_DEFROUTE=<span class="hljs-built_in">yes</span>           <span class="hljs-comment"># IPV6是否可以为默认路由：是[不会有任何影响, 现在还没用到IPV6]</span><br>IPV6_FAILURE_FATAL=no       <span class="hljs-comment"># 是不开启IPV6致命错误检测：否</span><br>IPV6_ADDR_GEN_MODE=stable-privacy  <span class="hljs-comment"># IPV6地址生成模型：stable-privacy [这只一种生成IPV6的策略]</span><br>NAME=ens33                   <span class="hljs-comment"># 网卡物理设备名称</span><br>UUID=f47bde51-fa78-4f79-b68f-d5dd90cfc698  <span class="hljs-comment"># 通用唯一识别码, 每一个网卡都会有, 不能重复, 否两台linux只有一台网卡可用</span><br>DEVICE=ens33                    <span class="hljs-comment"># 网卡设备名称, 必须和 `NAME` 值一样</span><br>ONBOOT=no                       <span class="hljs-comment"># 是否开机启动， 要想网卡开机就启动或通过 `systemctl restart network`控制网卡,必须设置为 `yes`</span><br></code></pre></td></tr></table></figure><h3 id="3-4重启网络"><a href="#3-4重启网络" class="headerlink" title="3.4重启网络"></a>3.4重启网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">systemctl restart network<br><br></code></pre></td></tr></table></figure><p>这一步容易出错，错误如下，解决方案可以参考下面的链接尝试解决。</p><h2 id="4-虚拟机实例访问外部网络"><a href="#4-虚拟机实例访问外部网络" class="headerlink" title="4. 虚拟机实例访问外部网络"></a>4. 虚拟机实例访问外部网络</h2><h3 id="4-1-清除外部路由"><a href="#4-1-清除外部路由" class="headerlink" title="4.1 清除外部路由"></a>4.1 清除外部路由</h3><p>【管理员】-&gt;【网络】-&gt;【路由】-&gt;【删除外部网关】</p><blockquote><p>注释：默认配置的路由器已将将外部网络设置为其网关，因此需要先将网关清除或直接删掉路由器。</p></blockquote><h3 id="4-2删除外部网络"><a href="#4-2删除外部网络" class="headerlink" title="4.2删除外部网络"></a>4.2删除外部网络</h3><p>【管理员】-&gt;【网络】-&gt;【网络】-&gt;【删除子网】</p><h3 id="4-3创建同名子网"><a href="#4-3创建同名子网" class="headerlink" title="4.3创建同名子网"></a>4.3创建同名子网</h3><p>对应子网的信息是需查看配置的<code>ifcfg-br-ex</code>文件。</p><h3 id="4-4调整路由配置"><a href="#4-4调整路由配置" class="headerlink" title="4.4调整路由配置"></a>4.4调整路由配置</h3><p>【demo】-&gt;【项目】-&gt;【网络】-&gt;【路由】</p><ul><li>设置网关：public</li><li>编辑路由：router-demo</li></ul><h3 id="4-5查看网络拓扑"><a href="#4-5查看网络拓扑" class="headerlink" title="4.5查看网络拓扑"></a>4.5查看网络拓扑</h3><h3 id="4-6分配浮动IP"><a href="#4-6分配浮动IP" class="headerlink" title="4.6分配浮动IP"></a>4.6分配浮动IP</h3><p>浮动IP的意义：把 <code>10.0.2.x</code> ip 映射到 <code>10.0.0.x</code> ip 地址上。</p><h2 id="5-更换yum源"><a href="#5-更换yum源" class="headerlink" title="5. 更换yum源"></a>5. 更换yum源</h2><h3 id="5-1-ubuntu换源"><a href="#5-1-ubuntu换源" class="headerlink" title="5.1 ubuntu换源"></a>5.1 ubuntu换源</h3><h4 id="5-1-1-更换-pip-源"><a href="#5-1-1-更换-pip-源" class="headerlink" title="5.1.1 更换 pip 源"></a>5.1.1 更换 pip 源</h4><p>在用户根目录创建文件夹 <code>.pip</code> ，添加配置文件 <code>pip.conf</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 创建文件夹</span><br><span class="hljs-built_in">cd</span> &amp;&amp; <span class="hljs-built_in">mkdir</span> .pip &amp;&amp; <span class="hljs-built_in">cd</span> .pip<br><span class="hljs-comment"># 创建并编辑配置文件</span><br>sudo vim pip.conf<br></code></pre></td></tr></table></figure><p>pip 源配置如下。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">[global]<br>timeout = 6000<br>index-url = http://mirrors.aliyun.com/pypi/simple/<br>trusted-host = mirrors.aliyun.com<br></code></pre></td></tr></table></figure><h4 id="5-1-2-更换-Ubuntu-源"><a href="#5-1-2-更换-Ubuntu-源" class="headerlink" title="5.1.2 更换 Ubuntu 源"></a>5.1.2 更换 Ubuntu 源</h4><p>备份源文件，再替换成阿里云的镜像源。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 备份</span><br>sudo <span class="hljs-built_in">mv</span> /etc/apt/sources.list /etc/apt/sources.list.bk<br><span class="hljs-comment"># 设置镜像源</span><br>sudo vim /etc/apt/sources.list<br></code></pre></td></tr></table></figure><p>镜像源设置如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse<br></code></pre></td></tr></table></figure><p>更新镜像源。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 更新</span><br>sudo apt update<br></code></pre></td></tr></table></figure><h3 id="5-2-centos换源"><a href="#5-2-centos换源" class="headerlink" title="5.2 centos换源"></a>5.2 centos换源</h3><p>进入root并切换到<code>yum.repos.d</code>目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> /etc/yum.repos.d/<br></code></pre></td></tr></table></figure><p>创建新文件夹并将源文件备份为<code>repo.bak</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">mkdir</span> backup &amp;&amp; <span class="hljs-built_in">mv</span> *repo backup/<br></code></pre></td></tr></table></figure><p>下载国内yum源文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo<br></code></pre></td></tr></table></figure><p>更新下载yum源地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sed -i -e<span class="hljs-string">&quot;s|mirrors.cloud.aliyuncs.com|mirrors.aliyun.com|g &quot;</span> /etc/yum.repos.d/CentOS-*<br>sed -i -e <span class="hljs-string">&quot;s|releasever|releasever-stream|g&quot;</span> /etc/yum.repos.d/CentOS-*<br><br></code></pre></td></tr></table></figure><p>生成缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">yum clean all &amp;&amp; yum makecache<br></code></pre></td></tr></table></figure><h2 id="6-安装docker"><a href="#6-安装docker" class="headerlink" title="6. 安装docker"></a>6. 安装docker</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 安装git</span><br>sudo apt install git<br><span class="hljs-comment"># 使用官方脚本安装docker</span><br>curl -fsSL https://test.docker.com -o test-docker.sh<br>sudo sh test.docker.sh<br>-----------------------------------------------------------<br><span class="hljs-comment"># 手动安装</span><br>https://download.docker.com/linux/ubuntu/dists/bionic/pool/stable/amd64/<br><span class="hljs-comment"># 下载 Docker Engine、CLI、containerd 和 Docker Compose 软件包的以下 deb 文件：</span><br>sudo dpkg -i ./containerd.io_&lt;version&gt;_&lt;<span class="hljs-built_in">arch</span>&gt;.deb \<br>  ./docker-ce_&lt;version&gt;_&lt;<span class="hljs-built_in">arch</span>&gt;.deb \<br>  ./docker-ce-cli_&lt;version&gt;_&lt;<span class="hljs-built_in">arch</span>&gt;.deb \<br>  ./docker-buildx-plugin_&lt;version&gt;_&lt;<span class="hljs-built_in">arch</span>&gt;.deb \<br>  ./docker-compose-plugin_&lt;version&gt;_&lt;<span class="hljs-built_in">arch</span>&gt;.deb<br><span class="hljs-comment"># 运行 hello-world 验证 Docker 引擎</span><br>sudo service docker start<br>sudo docker run hello-world<br><br><span class="hljs-comment"># 查看本地 image 库</span><br>docker image <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 打包 image</span><br>docker save -o hello-world.tar hello-world:latest<br>docker save -o a.tar a:latest<br><span class="hljs-comment"># 运行 image</span><br>docker load -i hello-world.tar<br>docker load -i a.tar<br></code></pre></td></tr></table></figure><h2 id="7-使用-SSH-登录实例"><a href="#7-使用-SSH-登录实例" class="headerlink" title="7. 使用 SSH 登录实例"></a>7. 使用 SSH 登录实例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">chmod</span> 700 xxx.pem<br>ssh -i xxx.pem 用户名@ip<br><span class="hljs-comment"># ssh -i cirros-key.pem ubuntu@10.0.2.77</span><br></code></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>ubuntu换源后有个包无法更新。</p><p> 经过查阅之后，发现是因为现在阿里源中为压缩格式，需要手动下载并解压。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">wget http://mirrors.aliyun.com/ubuntu/dists/jammy/universe/binary-amd64/Packages.gz<br>gzip -d Packages.gz<br><span class="hljs-comment"># -d：delete，解压并删除压缩包</span><br></code></pre></td></tr></table></figure></li><li><p>Error appeared during Puppet run: 10.0.2.15_controller.pp</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Bash">yum autoremove epel-release<br>yum autoremove openstack-packstack<br>yum clean all  <br><span class="hljs-comment"># 重新安装 openstack 安装器</span><br>yum install -y openstack-packstack<br><span class="hljs-comment"># 安装 openstack</span><br>packstack --allinone<br><span class="hljs-comment"># 查看当前安装版本</span><br>nova-manage --version<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>OpenStack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IasS、PasS、SasS云服务区别</title>
    <link href="/2023/05/31/%E4%BA%91%E6%9C%8D%E5%8A%A1/"/>
    <url>/2023/05/31/%E4%BA%91%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是云计算？"><a href="#1-什么是云计算？" class="headerlink" title="1. 什么是云计算？"></a>1. 什么是云计算？</h2><h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><p><a href="https://zh.wikipedia.org/wiki/%E9%9B%B2%E7%AB%AF%E9%81%8B%E7%AE%97">云计算</a>（Cloud Computing），是一种基于互联网的计算方式，通过这种方式，共享的软硬件资源和信息可以按需求提供给计算机各种终端和其他设备，使用服务商提供的电脑基建作计算和资源。云计算能够体验到每秒10万亿次的运算能力，拥有强大的算力可以模拟核爆、预测气候变化和市场发展趋势。用户通过电脑、手机、笔记本等方式接入数据中心，按自己的需求进行运算。同时数据中心根据用户需求，从资源池中为其动态分配计算资源。换句话说，云计算是以前服务器计算的升级版，其主要有扩展性强、廉价、虚拟化、计算能力强等特点。</p><h3 id="1-2-基本特征"><a href="#1-2-基本特征" class="headerlink" title="1.2 基本特征"></a>1.2 基本特征</h3><p>云是网络、互联网的一种比喻说法。互联网上的云计算服务特征和自然界的云、水循环具有一定的相似性，因此云是一个相当贴切的比喻。根据美国国家标准和技术研究院的定义，云计算服务应该具有以下几条特征：</p><ul><li>随需应变自助服务；</li><li>随时随地用任何网络设备访问；</li><li>多人共享资源池；</li><li>快速重新部署灵活度；</li><li>可被监控与量测的服务；<br>一般认为还有如下特征：</li><li>基于虚拟化技术快速部署资源或获得服务；</li><li>减少用户终端的处理负担；</li><li>降低了用户对于IT专业知识的依赖。</li></ul><h2 id="2-服务模式"><a href="#2-服务模式" class="headerlink" title="2. 服务模式"></a>2. 服务模式</h2><p>美国国家标准和技术研究院的云计算定义中明确了三种服务模式：</p><ul><li><p>基础设施即服务（<strong>IaaS</strong>）：消费者使用“基础计算资源”，如处理能力、存储空间、网络组件或中间件。消费者能掌控操作系统、存储空间、已部署的应用程序及网络组件（如防火墙、负载平衡器等），但并不掌控云基础架构。例如：Amazon AWS、Rackspace；</p></li><li><p>平台即服务（<strong>PaaS</strong>）：消费者使用主机操作应用程序。消费者掌控运作应用程序的环境（也拥有主机部分掌控权），但并不掌控操作系统、硬件或运作的网络基础架构。平台通常是应用程序基础架构。例如：Google App Engine；</p></li><li><p>软件即服务（<strong>SaaS</strong>）：消费者使用应用程序，但并不掌控操作系统、硬件或运作的网络基础架构。是一种服务观念的基础，软件服务供应商，以租赁的概念提供客户服务，而非购买，比较常见的模式是提供一组账号密码。例如：Adobe Creative Cloud，Microsoft CRM与 Salesforce.com。</p></li></ul><p><img src="/../image/IaaS_PaaS_SaaS_1.png" alt="IaaS/PaaS/SaaS"></p><p>首先，可以将云计算理解成一栋大楼，而这栋楼又可以分为顶层、中层、底层三大块，如上图所示，可以把 <strong>IaaS</strong>（基础设施）、<strong>PaaS</strong>（平台）、<strong>SaaS</strong>（软件）理解为这栋楼的三大块。基础设施在底层，平台在中层，软件在顶层。</p><p><img src="/../image/IaaS_PaaS_SaaS_2.png" alt="IaaS/PaaS/SaaS"></p><h3 id="IaaS"><a href="#IaaS" class="headerlink" title="IaaS"></a>IaaS</h3><p><a href="https://en.wikipedia.org/wiki/Infrastructure_as_a_service">IaaS</a>是一种云计算服务模型，通过该模型，计算资源由云服务提供商提供。IaaS 供应商提供存储、网络、服务器和虚拟化等，此服务使用户能够摆脱维护本地数据中心&#x2F;数据库的负担。</p><p>举个栗子：如果 A 公司想在办公室或者公司网站上运行一些企业应用，需要去买服务器或高昂的硬件来控制本地应用，才能让业务能够正常运行。但现在可以租用 IaaS 公司提供的场外服务器、存储和网络硬件，这样便可以大大节省服务器的维护成本和办公场地。</p><h3 id="PaaS"><a href="#PaaS" class="headerlink" title="PaaS"></a>PaaS</h3><p><a href="https://en.wikipedia.org/wiki/Platform_as_a_service">PssS</a>允许客户配置、实例化、运行和管理由计算平台和一个或多个应用程序组成的模块化捆绑包，无需构建和维护通常与开发和启动应用程序相关的基础架构，并允许开发人员创建、开发和打包此类软件包。</p><p>举个栗子：如果 B 公司在网上提供各种开发和分发应用的解决方案，比如虚拟服务器、操作系统、网页应用管理、应用设计、应用虚拟主机、存储、安全以及应用开发协同工具等。A 公司接洽评估后，觉得可以节省在硬件上的费用，同时也能让分散的工作室之间的协同合作变得更加容易。</p><h3 id="SaaS"><a href="#SaaS" class="headerlink" title="SaaS"></a>SaaS</h3><p><a href="https://en.wikipedia.org/wiki/Software_as_a_service">SaaS</a>应用程序通常由 Web 浏览器的用户访问，因此成为许多业务应用程序的通用交付模型，包括办公软件、消息传递软件、工资单处理软件、DBMS 软件、管理软件、CAD 软件、开发软件、游戏化、虚拟化、会计、协作、客户关系管理（CRM）、管理信息系统（MIS）、企业资源规划（ERP）、发票、现场服务管理、人力资源管理（HRM）、人才招聘、学习管理系统、内容管理（CM）、地理信息系统（GIS）和服务台管理等。</p><p>举个栗子：生活中，几乎每天都在接触 SaaS 云服务，比如：我们平时使用的苹果手机服务、网页中的一些云服务等。</p><h3 id="IaaS-和-PaaS-对比"><a href="#IaaS-和-PaaS-对比" class="headerlink" title="IaaS 和 PaaS 对比"></a>IaaS 和 PaaS 对比</h3><p>IaaS 主要作用是提供虚拟机或者其他资源作为服务提供给用户，PaaS 主要作用是将一个开发和运行平台作为服务提供给用户。</p><ol><li><p>开发环境<br>IaaS 方面主要还是沿用之前比较熟悉那套开发环境，但因为之前那套开发环境在和云的整合方面比较欠缺，使用起来不是很方便。PaaS 方面基本都会给开发者提供一整套包括 IDE 在内的开发和测试环境。</p></li><li><p>支持应用<br>因为 IaaS 主要是提供虚拟机，而且普通的虚拟机能支持多种操作系统，所以IaaS支持的应用的范围是比较广泛。但如果要让一个应用能跑在某个 PaaS 平台不是一件轻松的事，因为不仅需要确保这个应用是基于这个平台所支持的语言，而且也要确保这个应用只能调用这个平台所支持的 API，如果这个应用调用了平台所不支持的 API，那么就需要对这个应用进行修改。</p></li><li><p>整合率和经济性<br>PaaS 平台整合率是非常高，比如 PaaS 的代表 Google App Engine 能在一台服务器上承载成千上万的应用，而普通的IaaS平台的整合率最多也不会超过 100，而且普遍在 10 左右，使得 IaaS 的经济性不如 PaaS。</p></li><li><p>开放标准<br>虽然很多 IaaS 平台都存在一定的私有功能，但是由于 OVF 等协议的存在，使得 IaaS 在跨平台和避免被供应商锁定这两面是稳步前进的。而 PaaS 平台的情况则不容乐观，因为不论是 Google 的 App Engine，还是Salesforce 的 Force.com 都存在一定的私有 API。</p></li><li><p>可伸缩性<br>PaaS 平台会自动调整资源来帮助运行于其上的应用更好地应对突发流量。而 IaaS 平台则需要开发人员手动对资源进行调整才能应对。</p></li><li><p>计费和监督<br>PaaS 平台在计费和监管这两方面不仅达到了 IaaS 平台所能企及的操作系统层面，比如，CPU 和内存的使用量等，而且还能做到应用层面，比如，应用的反应时间（Response Time）或者应用所消耗的事务多少等，这将提高计费和管理的精确性。</p></li><li><p>学习难度<br>IaaS 上开发和管理应用和现有的方式比较接近，而 PaaS 上开发则有可能需要学一门新的语言或者新的框架，所以IaaS学习难度更低。</p></li></ol><h2 id="部署模型"><a href="#部署模型" class="headerlink" title="部署模型"></a>部署模型</h2><p>美国国家标准和技术研究院的云计算定义中也涉及了关于云计算的部署模型：</p><ul><li>公用云</li></ul><p>简而言之，公用云（Public Cloud）服务可透过网络及第三方服务供应者，开放给客户使用，“公用”一词并不一定代表“免费”，但也可能代表免费或相当廉价，公用云并不表示用户资料可供任何人查看，公用云供应者通常会对用户实施使用存取控制机制，公用云作为解决方案，既有弹性，又具备成本效益。</p><ul><li>私有云</li></ul><p>私有云（Private Cloud）具备许多公用云环境的优点，例如弹性、适合提供服务，两者差别在于私有云服务中，资料与程序皆在组织内管理，且与公用云服务不同，不会受到网络带宽、安全疑虑、法规限制影响；此外，私有云服务让供应者及用户更能掌控云基础架构、改善安全与弹性，因为用户与网络都受到特殊限制。</p><ul><li>社群云</li></ul><p>社群云（Community Cloud）由众多利益相仿的组织掌控及使用，例如特定安全要求、共同宗旨等。社群成员共同使用云资料及应用程序。</p><ul><li>混合云</li></ul><p>混合云（Hybrid Cloud）结合公用云及私有云，这个模式中，用户通常将非企业关键信息外包，并在公用云上处理，但同时掌控企业关键服务及资料。</p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li>IaaS（Infrastructure as a Service）：基础设施即服务</li><li>PaaS（Platform as a Service）：平台即服务</li><li>SaaS（Software as a Service）：软件即服务</li><li>CaaS（Communications as a Service）：通讯即服务</li><li>MaaS（Machine as a Service）：物联网即服务</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.wikipedia.org/wiki/%E9%9B%B2%E7%AB%AF%E9%81%8B%E7%AE%97">https://zh.wikipedia.org/wiki/%E9%9B%B2%E7%AB%AF%E9%81%8B%E7%AE%97</a></p><p><a href="https://blog.csdn.net/yipala/article/details/120076350">https://blog.csdn.net/yipala/article/details/120076350</a></p><p><a href="https://www.sohu.com/a/577767035_121369651">https://www.sohu.com/a/577767035_121369651</a></p>]]></content>
    
    
    <categories>
      
      <category>云服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenStack 单机部署 —— DevStack</title>
    <link href="/2023/05/30/OpenStack%20%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2%20%E2%80%94%E2%80%94%20DevStack/"/>
    <url>/2023/05/30/OpenStack%20%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2%20%E2%80%94%E2%80%94%20DevStack/</url>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>DevStack 是一系列可扩展的脚本，用于基于 git master 的最新版本快速构建完整的 OpenStack 环境。它以交互方式用作开发环境，并作为大部分 OpenStack 项目功能测试的基础。</p><h2 id="1-更换-pip-源"><a href="#1-更换-pip-源" class="headerlink" title="1. 更换 pip 源"></a>1. 更换 pip 源</h2><p>在用户根目录创建文件夹 <code>.pip</code> ，添加配置文件 <code>pip.conf</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 创建文件夹</span><br><span class="hljs-built_in">cd</span> &amp;&amp; <span class="hljs-built_in">mkdir</span> .pip &amp;&amp; <span class="hljs-built_in">cd</span> .pip<br><span class="hljs-comment"># 创建并编辑配置文件</span><br>sudo vim pip.conf<br></code></pre></td></tr></table></figure><p>pip 源配置如下。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">[global]<br>timeout = 6000<br>index-url = http://mirrors.aliyun.com/pypi/simple/<br>trusted-host = mirrors.aliyun.com<br></code></pre></td></tr></table></figure><h2 id="2-更换-Ubuntu-源"><a href="#2-更换-Ubuntu-源" class="headerlink" title="2. 更换 Ubuntu 源"></a>2. 更换 Ubuntu 源</h2><p>备份源文件，再替换成阿里云的镜像源。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 备份</span><br>sudo <span class="hljs-built_in">mv</span> /etc/apt/sources.list /etc/apt/sources.list.bk<br><span class="hljs-comment"># 设置镜像源</span><br>sudo vim /etc/apt/sources.list<br></code></pre></td></tr></table></figure><p>镜像源设置如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse<br></code></pre></td></tr></table></figure><p>更新镜像源。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 更新</span><br>sudo apt update<br></code></pre></td></tr></table></figure><h2 id="3-添加用户"><a href="#3-添加用户" class="headerlink" title="3. 添加用户"></a>3. 添加用户</h2><p>DevStack 应该以非 root 用户（但拥有 <code>sudo</code> 权限）执行，手动添加 <code>stack</code> 用户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 添加 stack 用户</span><br>sudo useradd -s /bin/bash -d /opt/stack -m stack<br><span class="hljs-comment"># 授予 stack 用户的主目录权限</span><br>sudo <span class="hljs-built_in">chmod</span> +x /opt/stack<br><span class="hljs-comment"># 授予 sudo 权限</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;stack ALL=(ALL) NOPASSWD: ALL&quot;</span> | sudo <span class="hljs-built_in">tee</span> /etc/sudoers.d/stack<br>sudo -u stack -i<br><span class="hljs-comment"># 以 stack 用户登录</span><br>sudo su - stack<br></code></pre></td></tr></table></figure><h1 id="4-DevStack-部署-OpenStack"><a href="#4-DevStack-部署-OpenStack" class="headerlink" title="4. DevStack 部署 OpenStack"></a>4. DevStack 部署 OpenStack</h1><h3 id="下载DevStack"><a href="#下载DevStack" class="headerlink" title="下载DevStack"></a>下载DevStack</h3><p>建议在 <code>/opt/stack</code>目录下下载 <code>DevStack</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 下载 DevStack</span><br>git <span class="hljs-built_in">clone</span> https://github.com/openstack/devstack<br><span class="hljs-comment"># 进入文件夹</span><br><span class="hljs-built_in">cd</span> devstack<br></code></pre></td></tr></table></figure><h2 id="5-创建配置文件-local-conf"><a href="#5-创建配置文件-local-conf" class="headerlink" title="5. 创建配置文件 local.conf"></a>5. 创建配置文件 <code>local.conf</code></h2><p>在 devstack 的根目录下创建一个带有四个预设密码的 <code>local.conf</code> 文件，这是开始使用 DevStack 所需的最低配置，详细配置见 <a href="https://docs.openstack.org/devstack/latest/">devstack&#x2F;latest</a>。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">[[local|localrc]]<br>// HOST_IP=10.12.97.185<br>// GIT_BASE=https://github.com/<br>ADMIN_PASSWORD=secret<br>DATABASE_PASSWORD=$ADMIN_PASSWORD<br>RABBIT_PASSWORD=$ADMIN_PASSWORD<br>SERVICE_PASSWORD=$ADMIN_PASSWORD<br></code></pre></td></tr></table></figure><ul><li><code>ADMIN_PASSWORD</code>：OpenStack 用户 <code>admin</code> 和 <code>demo</code> 的密码；</li><li><code>DATABASE_PASSWORD</code>：MySQL 管理员用户密码；</li><li><code>RABBIT_PASSWORD</code>：RabbitMQ 密码；</li><li><code>SERVICE_PASSWORD</code>：服务组件和 KeyStone 交互的密码；</li><li><code>GIT_BASE</code>：源代码托管服务器；</li><li><code>HOST_IP</code>：绑定的 IP 地址。</li></ul><h2 id="6-开始安装"><a href="#6-开始安装" class="headerlink" title="6. 开始安装"></a>6. 开始安装</h2><p>执行目录下的脚本开始自动安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 安装</span><br>./stack.sh<br><span class="hljs-comment"># 停止 DevStack</span><br>./unstack.sh<br><span class="hljs-comment"># 停止 DevStack 并删除配置文件等</span><br>./clean.sh<br></code></pre></td></tr></table></figure><p>安装过程中受网速影响比较大，安装了将近2个小时才安装完成。以下是成功安装后的打印信息。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs text">=========================<br>DevStack Component Timing<br> (times are in seconds)  <br>=========================<br>wait_for_service      10<br>async_wait           129<br>osc                  114<br>apt-get              1414<br>test_with_retry        3<br>dbsync                 2<br>pip_install          403<br>apt-get-update         2<br>run_process           21<br>git_timed            3661<br>-------------------------<br>Unaccounted time     814<br>=========================<br>Total runtime        6573<br><br>=================<br> Async summary<br>=================<br> Time spent in the background minus waits: 555 sec<br> Elapsed time: 6573 sec<br> Time if we did everything serially: 7128 sec<br> Speedup:  1.08444<br><br><br>Post-stack database query stats:<br>+------------+-----------+-------+<br>| db         | op        | count |<br>+------------+-----------+-------+<br>| keystone   | SELECT    | 41619 |<br>| keystone   | INSERT    |    93 |<br>| glance     | SELECT    |  1001 |<br>| glance     | CREATE    |    65 |<br>| glance     | INSERT    |   255 |<br>| glance     | SHOW      |     8 |<br>| glance     | UPDATE    |    17 |<br>| glance     | ALTER     |     9 |<br>| glance     | DROP      |     1 |<br>| cinder     | SELECT    |   403 |<br>| cinder     | CREATE    |    74 |<br>| cinder     | SET       |     1 |<br>| cinder     | ALTER     |    21 |<br>| neutron    | SELECT    |  5263 |<br>| neutron    | SHOW      |    35 |<br>| neutron    | CREATE    |   318 |<br>| neutron    | INSERT    |  1310 |<br>| neutron    | UPDATE    |   246 |<br>| neutron    | ALTER     |   150 |<br>| neutron    | DROP      |    52 |<br>| neutron    | DELETE    |    29 |<br>| nova_cell1 | SELECT    |   647 |<br>| nova_cell1 | CREATE    |   211 |<br>| nova_cell0 | SELECT    |   845 |<br>| nova_cell0 | CREATE    |   211 |<br>| nova_cell1 | ALTER     |     3 |<br>| nova_cell1 | SHOW      |    59 |<br>| nova_cell0 | ALTER     |     3 |<br>| nova_cell0 | SHOW      |    59 |<br>| nova_cell1 | INSERT    |     7 |<br>| nova_cell0 | INSERT    |    12 |<br>| placement  | SELECT    |   116 |<br>| placement  | INSERT    |    59 |<br>| placement  | SET       |     3 |<br>| nova_api   | SELECT    |   120 |<br>| placement  | UPDATE    |     3 |<br>| cinder     | INSERT    |     5 |<br>| nova_cell0 | UPDATE    |   194 |<br>| nova_cell1 | UPDATE    |   205 |<br>| cinder     | UPDATE    |    87 |<br>| cinder     | DELETE    |     1 |<br>| nova_cell1 | DELETE    |     1 |<br>| nova_api   | INSERT    |    20 |<br>| nova_api   | SAVEPOINT |    10 |<br>| nova_api   | RELEASE   |    10 |<br>+------------+-----------+-------+<br><br>This is your host IP address: 10.12.97.185<br>This is your host IPv6 address: ::1<br>Horizon is now available at http://10.12.97.185/dashboard<br>Keystone is serving at http://10.12.97.185/identity/<br>The default users are: admin and demo<br>The password: secret<br><br>Services are running under systemd unit files.<br>For more information see: <br>https://docs.openstack.org/devstack/latest/systemd.html<br><br>DevStack Version: 2023.2<br>Change: c424a7a299e37004d318107648bb18e157344985 Merge &quot;Use RDO official CloudSIG mirrors for C9S deployments&quot; 2023-05-29 13:14:36 +0000<br>OS Version: Ubuntu 22.04 jammy<br><br>2023-05-30 09:23:05.918 | stack.sh completed in 6573 seconds.<br></code></pre></td></tr></table></figure><p><img src="/../image/OpenStack%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2.png" alt="OpenStack登录界面"></p><p><img src="/../image/OpenStack%E6%93%8D%E4%BD%9C%E7%95%8C%E9%9D%A2.png" alt="OpenStack操作界面"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>  安装过程极为坎坷，经过换开发机（无公开网络）、换源（无相关软件包）、软件包版本未满足依赖关系等。</p><ol><li><p>更新镜像源时报错。</p><p> <img src="/../image/Ubuntu%E9%95%9C%E5%83%8F%E6%BA%90%E6%97%A0%E5%85%AC%E9%92%A5.png" alt="Ubuntu镜像源无公钥"></p><p> 解决方案为添加对应公钥。</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 3B4FE6ACC0B21F32<br></code></pre></td></tr></table></figure></li><li><p>软件包未满足依赖条件。</p><p> <img src="/../image/%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%9C%AA%E6%BB%A1%E8%B6%B3%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png" alt="软件包未满足依赖关系"></p><p> 解决方案：使用 <code>aptitude</code>手动执行安装。</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 安装 aptitude</span><br>sudo apt-get install aptitude<br><span class="hljs-comment"># 使用 aptitude 手动执行安装</span><br>sudo aptitude install xxx<br><span class="hljs-comment"># 运行后，不接受未安装方案，接收降级方案</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://jckling.github.io/2021/02/07/OpenStack/OpenStack%20%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2%20%E2%80%94%E2%80%94%20DevStack/">https://jckling.github.io/2021/02/07/OpenStack/OpenStack%20%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2%20%E2%80%94%E2%80%94%20DevStack/</a></p><p><a href="https://blog.51cto.com/zhangxueliang/3057866">https://blog.51cto.com/zhangxueliang/3057866</a></p><p><a href="https://www.88888889.xyz/?thread-40.htm">https://www.88888889.xyz/?thread-40.htm</a></p><p><a href="https://developer.aliyun.com/article/704603">https://developer.aliyun.com/article/704603</a></p><p><a href="https://blog.csdn.net/zhuyong006/article/details/85258748">https://blog.csdn.net/zhuyong006/article/details/85258748</a></p>]]></content>
    
    
    <categories>
      
      <category>OpenStack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 命令</title>
    <link href="/2023/05/29/Linux%20%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/05/29/Linux%20%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h2><h3 id="系统监视器"><a href="#系统监视器" class="headerlink" title="系统监视器"></a>系统监视器</h3><p>启动 Linux 资源管理器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gnome-system-monitor<br><span class="hljs-comment"># 若没有安装，则使用下面命令安装</span><br>sudo apt-get install gnome-system-monitor<br></code></pre></td></tr></table></figure><h3 id="pip-安装"><a href="#pip-安装" class="headerlink" title="pip 安装"></a>pip 安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install python3-pip<br></code></pre></td></tr></table></figure><h3 id="useradd-命令"><a href="#useradd-命令" class="headerlink" title="useradd 命令"></a>useradd 命令</h3><p><strong>useradd</strong> 命令用于建立用户帐号。帐号建好之后，再用 <strong>passwd</strong> 设定帐号的密码。而可用 <strong>userdel</strong> 删除帐号。使用 <strong>useradd</strong> 指令所建立的帐号，实际上是保存在 <code>/etc/passwd</code> 文本文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 语法</span><br>useradd [-mMnr][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s &lt;shell&gt;][-u &lt;uid&gt;][用户帐号]<br></code></pre></td></tr></table></figure><ul><li><code>-c&lt;备注&gt;</code>:加上备注文字。备注文字会保存在passwd的备注栏位中。</li><li><code>-d&lt;登入目录&gt;</code>:指定用户登入时的起始目录。</li><li><code>-D</code>:变更预设值．</li><li><code>-e&lt;有效期限&gt;</code>:指定帐号的有效期限。</li><li><code>-f&lt;缓冲天数&gt;</code>:指定在密码过期后多少天即关闭该帐号。</li><li><code>-g&lt;群组&gt;</code>:指定用户所属的群组。</li><li><code>-G&lt;群组&gt;</code>:指定用户所属的附加群组。</li><li><code>-m</code>:制定用户的登入目录。</li><li><code>-M</code>:不要自动建立用户的登入目录。</li><li><code>-n</code>:取消建立以用户名称为名的群组．</li><li><code>-r</code>:建立系统帐号。</li><li><code>-s&lt;shell&gt;</code>:指定用户登入后所使用的shell。</li><li><code>-u&lt;uid&gt;</code>:指定用户ID。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 举个栗子</span><br>sudo useradd -s /bin/bash -d /opt/stack -m stack<br><span class="hljs-comment"># 使用 bash 作为 shell，指定 /opt/stack 作为起始目录，指定登入目录为 stack</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 新建用户</span><br>sudo useradd zzz<br><span class="hljs-comment"># 将 zzz 添加到 fw 组</span><br>sudo usermod -aG fw zzz<br><span class="hljs-comment"># 设置密码</span><br>sudo passwd zzz<br><span class="hljs-comment"># 添加家目录</span><br><span class="hljs-built_in">mkdir</span> /home/zzz<br><span class="hljs-built_in">chown</span> zzz -R /home/zzz<br>usermod -d /home/zzz zzz<br><span class="hljs-comment"># 修改 zhaozhaozhao 为 zzz</span><br>sudo usermod -l zzz zhapzhaozhao<br><span class="hljs-comment"># 查看用户属于的用户组</span><br><span class="hljs-built_in">groups</span> zzz<br><span class="hljs-comment"># 删除 zhaozhaozhao 这个用户组</span><br>sudo groupdel zhaozhaozhao<br><span class="hljs-comment"># 查看所有用户及其家目录,  确认自己的家目录是否正确</span><br><span class="hljs-built_in">cat</span> /etc/passwd<br></code></pre></td></tr></table></figure><h3 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h3><p>查看 Linux 系统是 X86 架构还是 ARM 架构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -m<br><span class="hljs-comment"># x86_64</span><br><span class="hljs-comment"># (base) </span><br><span class="hljs-built_in">uname</span> -a<br><span class="hljs-comment"># Linux user-QiTianM437-A631 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr 18 17:40:00 UTC 2 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="hljs-comment"># (base) </span><br></code></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/u011068702/article/details/70244713">https://blog.csdn.net/u011068702/article/details/70244713</a></p><p><a href="https://www.runoob.com/linux/linux-comm-useradd.html">https://www.runoob.com/linux/linux-comm-useradd.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS解构赋值</title>
    <link href="/2023/05/11/JS%20%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <url>/2023/05/11/JS%20%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>JavaScript 中最常见的两种数据结构是 Object 和 Array。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS 箭头函数</title>
    <link href="/2023/05/10/JS%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <url>/2023/05/10/JS%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>创建函数还有另一种非常简单的语法————箭头函数，并且这种方法通常比函数表达式更好。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> func = <span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2,...,argN</span>) &#123;<br>    <span class="hljs-keyword">return</span>  expression;<br>&#125;<br>---------------------------------------------- <span class="hljs-comment">// 两种等同</span><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">arg1, arg2,...,argN</span>) =&gt; expression;<br></code></pre></td></tr></table></figure><p>这里创建一个函数 <code>func</code>，接受参数 <code>arg1...argN</code>，然后使用参数对右侧的 expression 求值并返回其结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br>---------------------------- <span class="hljs-comment">// 两者等同</span><br><span class="hljs-keyword">let</span> sum  = <span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;；<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) );         <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>可以看到 <code>(a, b) =&gt; a + b</code> 表示一个函数接受两个名为 <code>a</code> 和 <code>b</code> 的参数，在执行时，将对表达式 <code>a + b</code> 求值，并返回计算结果。</p><ul><li>若只有一个参数，则可以省略外面的圆括号，使代码更短。  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">double</span> = n =&gt; n * <span class="hljs-number">2</span>;<br><span class="hljs-title function_">alert</span>( <span class="hljs-title function_">double</span>(<span class="hljs-number">3</span>) );     <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure></li><li>若没有参数，括号则是空的（但括号必须保留）。  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">sayHi</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br><span class="hljs-title function_">sayHi</span>();<br></code></pre></td></tr></table></figure></li></ul><p>箭头函数可以像函数表达式一样使用。例如动态创建一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> age = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;What&#x27;s your age?&quot;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-keyword">let</span>  welocme = (age &lt; <span class="hljs-number">18</span>) ?<br>    <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello!&quot;</span>) :<br>    <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Greeting!&quot;</span>);<br><br><span class="hljs-title function_">welocme</span>();<br></code></pre></td></tr></table></figure><h2 id="多行的箭头函数"><a href="#多行的箭头函数" class="headerlink" title="多行的箭头函数"></a>多行的箭头函数</h2><p>单行的箭头函数较为简单，它们从 <code>=&gt;</code> 的左侧获取参数，计算并返回右侧表达式的计算结果。</p><p>有时需要更复杂点的函数，比如带有多行的表达式或语句，在这种情况下，可以使用花括号将他们括起来。主要区别在于，用花括号括起来后，需要包含 <code>return</code> 才能返回值（与常规函数一样）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> result = a + b;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;;<br><span class="hljs-title function_">alert</span>( <span class="hljs-title function_">sum</span>( <span class="hljs-number">1</span> + <span class="hljs-number">2</span>) );      <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>箭头函数对于简单的操作很方便，特别是单行的函数。具体有两种形式：</p><ol><li>不带花括号：<code>(...args) =&gt; expression</code>————右侧是一个表达式：函数计算表达式并返回其结果，若只有一个参数，则可以省略括号；</li><li>带花括号：<code>(...args) =&gt; &#123; body &#125;</code>————花括号允许在函数中编写多个语句，但需要 <code>return</code> 返回一些内容。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.javascript.info/arrow-functions-basics">https://zh.javascript.info/arrow-functions-basics</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Map and Set（映射和集合）</title>
    <link href="/2023/05/08/Map%20and%20Set%EF%BC%88%E6%98%A0%E5%B0%84%E5%92%8C%E9%9B%86%E5%90%88%EF%BC%89/"/>
    <url>/2023/05/08/Map%20and%20Set%EF%BC%88%E6%98%A0%E5%B0%84%E5%92%8C%E9%9B%86%E5%90%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a> 是一个带键的数据项的集合，就像一个 <code>Object</code> 一样，但它们最大的区别是 <code>Map</code> 允许任何类型的键（Key）。</p><p>方法和属性如下：</p><ul><li><code>new Map()</code>————创建 <code>map</code>；</li><li><code>map.set(key, value)</code>————根据键存储值；</li><li><code>map.get(key)</code>————根据键来返回值，如果 <code>map</code> 中不存在对应的 <code>key</code>，则返回 <code>undefined</code>；</li><li><code>map.has(key)</code>————如果 <code>key</code> 存在则返回 <code>true</code>，否则返回 <code>false</code>；</li><li><code>map.delete(key)</code>————删除指定键的值；</li><li><code>map.clear()</code>————清空 <code>map</code>；</li><li><code>map.size</code>————返回当前元素的个数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;str1&#x27;</span>);   <span class="hljs-comment">// 字符串键</span><br>map.<span class="hljs-title function_">set</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;num1&#x27;</span>);     <span class="hljs-comment">// 数字键</span><br>map.<span class="hljs-title function_">set</span>(<span class="hljs-literal">true</span>, <span class="hljs-string">&#x27;bool1&#x27;</span>); <span class="hljs-comment">// 布尔值键</span><br><br><span class="hljs-comment">// Map 会保留键的类型，所以下面这两个结果不同。</span><br><span class="hljs-title function_">alert</span>( map.<span class="hljs-title function_">get</span>(<span class="hljs-number">1</span>) );        <span class="hljs-comment">// &#x27;num1&#x27;</span><br><span class="hljs-title function_">alert</span>( map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;1&#x27;</span>) );      <span class="hljs-comment">// &#x27;str1&#x27;</span><br><span class="hljs-title function_">alert</span>( map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;bool1&#x27;</span>) );  <span class="hljs-comment">// &#x27;bool1&#x27;</span><br><span class="hljs-title function_">alert</span>( map.<span class="hljs-property">size</span> );          <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>与对象不同，键不会被转换成字符串，可以是任何类型。</p><p><code>Map</code> 还可以使用对象作为键。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> john = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Jojn&quot;</span> &#125;;<br><span class="hljs-keyword">let</span> visitsCountMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();     <span class="hljs-comment">// 存储每个用户的来访次数</span><br><br>visitsCountMap.<span class="hljs-title function_">set</span>(john, <span class="hljs-number">123</span>);      <span class="hljs-comment">// john 是 Map 中的键</span><br><span class="hljs-title function_">alert</span>( visitsCountMap.<span class="hljs-title function_">get</span>(john) );  <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><p>使用对象作为键是 <code>Map</code> 最值得注意和重要的功能之一。在 <code>Object</code> 中，我们无法使用对象作为键，在 <code>Object</code> 中使用字符串作为键是可以的，但无法使用另一个 <code>Object</code> 作为 <code>Object</code> 中的键。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> john = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><span class="hljs-keyword">let</span> ben = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Ben&quot;</span> &#125;;<br><br><span class="hljs-keyword">let</span> visitsCountObj = &#123;&#125;;        <span class="hljs-comment">// 尝试使用对象</span><br>visitsCountObj[ben] = <span class="hljs-number">234</span>;      <span class="hljs-comment">// 尝试将对象 ben 用作键</span><br>visitsCountObj[john] = <span class="hljs-number">123</span>;     <span class="hljs-comment">// 尝试将对象 john 作用键，但我们会发现使用对象 ben 作为键存下的值会被替换掉</span><br><span class="hljs-title function_">alert</span>( visitsCountObj )[<span class="hljs-string">&quot;[object object]&quot;</span>]; <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><p>因为 <code>visitsCountObj</code> 是一个对象，它会将所有的 <code>Object</code> 键例如上面的 <code>john</code> 和 <code>ben</code> 转换为字符串 <code>&quot;[object object]&quot;</code>。</p><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>每一次 map.set 调用都会返回 map 本身，可以进行 “链式”调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;str1&#x27;</span>)<br>    .<span class="hljs-title function_">set</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;num1&#x27;</span>)<br>    .<span class="hljs-title function_">set</span>(<span class="hljs-literal">true</span>, <span class="hljs-string">&#x27;bool1&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="Map-迭代"><a href="#Map-迭代" class="headerlink" title="Map 迭代"></a>Map 迭代</h2><p>如果要在 <code>map</code> 里使用循环，可以使用以下三个方法：</p><ul><li><code>map.keys()</code>————遍历并返回一个包含所有键的可迭代对象；</li><li><code>map.values()</code>————遍历并返回一个包含所有值得可迭代对象；</li><li><code>map.entries()</code>————遍历并返回一个包含所有实体 <code>[key, value]</code> 的可迭代对象，<code>for...of</code> 在默认情况下使用的就是这个。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> recipeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>    [<span class="hljs-string">&#x27;cucumber&#x27;</span>, <span class="hljs-number">500</span>],<br>    [<span class="hljs-string">&#x27;tomatoes&#x27;</span>, <span class="hljs-number">350</span>],<br>    [<span class="hljs-string">&#x27;onion&#x27;</span>, <span class="hljs-number">50</span>]<br>]);<br><br><span class="hljs-comment">// 遍历所有的键（vegetable）</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> vegetable <span class="hljs-keyword">of</span> recipeMap.<span class="hljs-title function_">keys</span>())&#123;<br>    <span class="hljs-title function_">alert</span>(vegetable);       <span class="hljs-comment">// cucumber, tomatoes, onion</span><br>&#125;<br><br><span class="hljs-comment">// 遍历所有的值（amounts）</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> amount <span class="hljs-keyword">of</span> recipeMap.<span class="hljs-title function_">value</span>())&#123;<br>    <span class="hljs-title function_">alert</span>(amount);          <span class="hljs-comment">// 500, 350, 50</span><br>&#125;<br><br><span class="hljs-comment">// 遍历所有的实体[key, value]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> recipeMap)&#123;<br>    <span class="hljs-title function_">alert</span>(entry);           <span class="hljs-comment">// cucumber, 500...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用插入顺序"><a href="#使用插入顺序" class="headerlink" title="使用插入顺序"></a>使用插入顺序</h3><p>迭代的顺序与插入值的顺序相同，与普通的 Object 不同，Map 保留了此顺序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 每个键值对（key, value）运行 forEach 函数</span><br>recipeMap.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key, map</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>:<span class="hljs-subst">$&#123;value&#125;</span>`</span>);   <span class="hljs-comment">// cucumber: 500 ...</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="Object-fromEntries-从-Map-创建对象"><a href="#Object-fromEntries-从-Map-创建对象" class="headerlink" title="Object.fromEntries: 从 Map 创建对象"></a>Object.fromEntries: 从 Map 创建对象</h2><p><code>Object.fromEntries</code> 方法与 <code>Object.entries(obj)</code> 从普通对象（<code>plain object</code>）创建 <code>Map</code> 方法相反，<code>Object.fromEntries</code> 为给定一个具有 <code>[key, value]</code> 键值对的数组，它会根据给定数组创建一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> prices = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>([<br>    [<span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-number">2</span>],<br>    [<span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-number">3</span>]<br>]);<br><br><span class="hljs-comment">// 现在 prices = &#123;banana: 1, apple: 2, orange: 3&#125;</span><br><span class="hljs-title function_">alert</span>(prices.<span class="hljs-property">orange</span>);   <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>我们可以使用 <code>Object.fromEntries</code> 从 <code>Map</code> 得到一个普通对象（plain object）。</p><p>例如，我们在 Map 中存储了一些数据，但需要将这些数据传给需要普通对象（plain object）的第三方代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-number">1</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-number">2</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">let</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(map.<span class="hljs-title function_">entries</span>());    <span class="hljs-comment">// 创建一个普通对象（plain object）</span><br><span class="hljs-comment">// object = &#123;banana: 1, apple: 2, orange: 3&#125;</span><br><span class="hljs-title function_">alert</span>(obj.<span class="hljs-property">orange</span>);      <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>调用 <code>map.entries()</code> 将返回一个可迭代的键&#x2F;值对，这刚好是 <code>Object.fromEntries</code> 所需要的格式，可以省掉 <code>.entries</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(map);      <span class="hljs-comment">// 省掉 .entries</span><br></code></pre></td></tr></table></figure><p>上面的代码作用也是一样的，因为 <code>Object.fromEntries</code> 期望得到一个可迭代对象作为参数，而不一定是数组。并且 <code>map</code> 的标准迭代会返回跟 <code>map.entries()</code> 一样的键&#x2F;值对。因此可以获得一个普通对象（plain object），其键&#x2F;值对与 <code>map</code> 相同。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 是一个特殊的类型集合————“值的集合”（没有键），它的每个值只能出现一次。其主要方法如下：</p><ul><li><code>new Set(iterable)</code>————创建一个 <code>set</code>，如果提供了一个 <code>iterable</code> 对象（通常是数组），将会从数组里面复制值到 <code>set</code> 中；</li><li><code>set.add(value)</code>————添加一个值，返回 <code>set</code> 本身；</li><li><code>set.delete(value)</code>————删除值，如果 <code>value</code> 在这个方法调用的时候存在，则返回 <code>true</code>，否则返回 <code>false</code>；</li><li><code>set.has(value)</code>————如果 <code>value</code> 在 <code>set</code> 中，返回 <code>true</code>，否则返回 <code>false</code>；</li><li><code>set.clear()</code>————清空 <code>set</code>；</li><li><code>set.size</code>————返回元素个数。</li></ul><p><code>Set</code> 的主要特点是，重复使用同一个值调用 <code>set.add(value)</code> 并不会发生什么改变，这就是 <code>Set</code> 里面的每个值只出现一次的原因。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br><span class="hljs-keyword">let</span> john = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><span class="hljs-keyword">let</span> pete = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span>&#125;;<br><span class="hljs-keyword">let</span> pete = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mary&quot;</span>&#125;;<br><br><span class="hljs-comment">// 一些访客来访好几次</span><br>set.<span class="hljs-title function_">add</span>(john);<br>set.<span class="hljs-title function_">add</span>(pete);<br>set.<span class="hljs-title function_">add</span>(mary);<br>set.<span class="hljs-title function_">add</span>(john);      <br>set.<span class="hljs-title function_">add</span>(mary);<br><br><span class="hljs-comment">// set 只保留不重复的值</span><br><span class="hljs-title function_">alert</span>( set.<span class="hljs-property">size</span> );  <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> user <span class="hljs-keyword">of</span> set)&#123;<br>    <span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>);   <span class="hljs-comment">// John, Pete, Mary</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Set</code> 的替代方法可以是一个用户数组，用 <code>arr.find</code> 在每次插入值时检查是否重复，但性能很差，因为这个方法会遍历整个数组来检查每个元素，<code>Set</code> 内部对唯一性检查进行了更好的优化。</p><h3 id="Set-迭代（iteration）"><a href="#Set-迭代（iteration）" class="headerlink" title="Set 迭代（iteration）"></a>Set 迭代（iteration）</h3><p>可以使用 <code>for...of</code> 或 <code>forEach</code> 来遍历 <code>Set</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>])<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> set)&#123;<br>    <span class="hljs-title function_">alert</span>(value);<br>&#125;;<br><br>set.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, valueAgain, set</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">alert</span>(value);<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>forEach</code> 的回调函数有三个参数：一个 <code>value</code>，然后是同一个值 <code>valueAgain</code>，最后是目标对象，同一个值在参数里出现了两次。主要原因是为了与 <code>Map</code> 兼容。</p><p><code>Map</code> 中用于迭代的方法在 <code>set</code> 中也同样支持：</p><ul><li><code>set.keys()</code>————遍历并返回一个包含所有值的可迭代对象；</li><li><code>set.values</code>————与 <code>set.keys()</code> 作用相同，为了兼容 <code>Map</code>；</li><li><code>set.entries</code>————遍历并返回一个包含所有的实体 <code>[value, value]</code> 的可迭代对象，也是为了兼容 <code>Map</code>。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Map</code> 是一个带键的数据项的集合。</p><p>方法和属性如下：</p><ul><li><code>new Map([iterable])</code>————创建 <code>map</code>，可选择带有 <code>[key, value]</code> 对的 <code>iterable</code>（例如数组）来进行初始化；</li><li><code>map.set(key, value)</code>————根据键存储值，返回 <code>map</code> 本身；</li><li><code>map.get(key)</code>————根据键来返回值，如果 <code>map</code> 中不存在对应的 <code>key</code>，则返回 <code>undefined</code>；</li><li><code>map.has(key)</code>————如果 <code>key</code> 存在，则返回 true，否则返回 <code>false</code>；</li><li><code>map.delete(key)</code>————删除指定键对应的值，如果在调用时 <code>key</code> 存在，则返回 <code>true</code>，否则返回 <code>false</code>；</li><li><code>map.clear()</code>————清空 <code>map</code>；</li><li><code>map.size</code>————返回当前元素个数。</li></ul><p>与普通对象 <code>Object</code> 的不同点：</p><ul><li>任何键、对象都可以作为键；</li><li>有其他的便捷方法，如 <code>size</code> 属性。</li></ul><p>Set 是一组唯一值的集合。</p><p>方法和属性如下：</p><ul><li><code>new Set([iterable])</code>————创建 <code>set</code>，可选择带有 <code>iterable</code>（例如数组）来进行初始化；</li><li><code>set.add(value)</code>————添加一个值（如何 <code>value</code> 存在则不做任何修改），返回 <code>set</code> 本身；</li><li><code>set.delete(value)</code>————删除值，如果 <code>value</code> 在这个方法调用的时候存在则返回 <code>true</code>，否则返回 <code>false</code>；</li><li><code>set.has(value)</code>————如果 <code>value</code> 在 <code>set</code> 中，返回 <code>true</code>，否则返回 <code>false</code>；</li><li><code>set.clear()</code>————清空 <code>set</code>；</li><li><code>set.size</code>————元素的个数。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.javascript.info/map-set">https://zh.javascript.info/map-set</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS 数组方法</title>
    <link href="/2023/05/04/JS%20%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
    <url>/2023/05/04/JS%20%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><h3 id="添加-x2F-移除数组元素"><a href="#添加-x2F-移除数组元素" class="headerlink" title="添加&#x2F;移除数组元素"></a>添加&#x2F;移除数组元素</h3><p>数组的首端或尾端添加和删除元素的方法。</p><ul><li><code>arr.push(...item)</code>————从尾端添加元素；</li><li><code>arr.pop()</code>————从尾端提取元素；</li><li><code>arr.shift()</code>————从首端提取元素；</li><li><code>arr.unshift(...item)</code>————从首端添加元素。</li></ul><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;go&quot;</span>, <span class="hljs-string">&quot;home&quot;</span>];<br><span class="hljs-keyword">delete</span> arr[<span class="hljs-number">1</span>];                  <span class="hljs-comment">// remove &quot;go&quot;</span><br><span class="hljs-title function_">alert</span>( arr[<span class="hljs-number">1</span>] );                <span class="hljs-comment">// undefined</span><br><span class="hljs-comment">// now arr = [&quot;I&quot;,  , &quot;home&quot;];</span><br><span class="hljs-title function_">alert</span>( arr.<span class="hljs-property">length</span> );            <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p><code>delete</code> 会将元素删除，<code>delete obj.key</code> 是通过 <code>key</code> 来移除对应的值，但仍会保留一个元素位置，因此 <code>arr.length == 3</code>，</p><h4 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice">arr.splice</a> 意为“拼接”。对于数组，希望删除后的元素能够移动并占据被释放的位置，可以实现数组添加、删除和插入元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">arr.<span class="hljs-title function_">splice</span>(start[, deleteCount, elem1, ..., elemN]);<br></code></pre></td></tr></table></figure><p>从索引 <code>start</code> 开始修改 <code>arr</code>：删除 <code>deleteCount</code> 个元素并在当前位置插入 <code>elem1, ..., elemN</code>。最后返回被删除的元素所组成的数组。</p><p>从索引 <code>1</code> 开始删除 <code>1</code> 个元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;study&quot;</span>, <span class="hljs-string">&quot;JavaScript&quot;</span>];<br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);               <span class="hljs-comment">// 从索引 1 开始删除 1 个元素</span><br><span class="hljs-title function_">alert</span>( arr );                   <span class="hljs-comment">// [&quot;I&quot;, &quot;JavaScript&quot;]</span><br></code></pre></td></tr></table></figure><p>从索引 <code>0</code> 开始删除 <code>3</code> 个元素并用另外 <code>2</code> 个元素替换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;study&quot;</span>, <span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-string">&quot;right&quot;</span>, <span class="hljs-string">&quot;now&quot;</span>];<br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;let,s&quot;</span>, <span class="hljs-string">&quot;dance&quot;</span>);<br><span class="hljs-title function_">alert</span>( arr );                   <span class="hljs-comment">// [&quot;Let&#x27;s&quot;, &quot;dance&quot;, &quot;right&quot;, &quot;now&quot;]</span><br></code></pre></td></tr></table></figure><p><code>splice</code> 删除元素所组成的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;study&quot;</span>, <span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-string">&quot;right&quot;</span>, <span class="hljs-string">&quot;now&quot;</span>];<br><span class="hljs-keyword">let</span> removed = arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br><span class="hljs-title function_">alert</span>( removed );               <span class="hljs-comment">// &quot;I&quot;, &quot;study&quot; 数组中删除了的元素</span><br></code></pre></td></tr></table></figure><p><code>splice</code> 添加元素，将 <code>deleteCount</code> 设置为 <code>0</code>，<code>splice</code> 方法能够插入元素而不用删除任何元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;study&quot;</span>, <span class="hljs-string">&quot;JavaScript&quot;</span>];<br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;complex&quot;</span>, <span class="hljs-string">&quot;language&quot;</span>);    <span class="hljs-comment">// 从索引 2 开始，删除 0 个元素，插入 2 个元素</span><br><span class="hljs-title function_">alert</span>( arr );                               <span class="hljs-comment">// &quot;I&quot;, &quot;study&quot;, &quot;complex&quot;, &quot;language&quot;, &quot;JavaScript&quot;</span><br></code></pre></td></tr></table></figure><p><code>splice</code> 允许负向索引，可以从数组末尾计算位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>];<br>arr.<span class="hljs-title function_">splice</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);    <span class="hljs-comment">// 从索引 -1（尾端前一位），删除 0 个元素，然后插入 3 和 4</span><br><span class="hljs-title function_">alert</span>( arr );               <span class="hljs-comment">// 1,2,3,4,5</span><br></code></pre></td></tr></table></figure><h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice">arr.slice</a> 意为“片、切片”。返回一个新数组，将所有从索引的 <code>start</code> 和 <code>end</code>（不包括 <code>end</code>）的数组项复制到一个新的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">arr.<span class="hljs-title function_">slice</span>([start], [end]);<br></code></pre></td></tr></table></figure><p><code>start</code> 和 <code>end</code> 都可以是负数，将从末尾计算索引。它和字符串的 <code>str.slice</code> 方法有点像，就是把子字符串替换成子数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;t&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-string">&quot;t&quot;</span>];<br><span class="hljs-title function_">alert</span>( arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) );   <span class="hljs-comment">// e,s（复制从位置 1 到位置 3 的元素）</span><br><span class="hljs-title function_">alert</span>( arr.<span class="hljs-title function_">slice</span>(-<span class="hljs-number">2</span>) );     <span class="hljs-comment">// s,t（复制从位置 -2 到尾端的元素）</span><br></code></pre></td></tr></table></figure><p>可以不带参数的调用：<code>arr.slice()</code> 会创建一个 <code>arr</code> 的副本，其常用于获取副本，以进行不影响原始数组的进一步转换。</p><h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat">arr.concat</a> 创建一个新数组，其中包含来自于其他数组和其他项的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">arr.<span class="hljs-title function_">concat</span>(arg1, arg2...);<br></code></pre></td></tr></table></figure><p>它接收任何数量的参数————数组或值都可以。结果是一个包含来自于 <code>arr</code>，然后 <code>arg1，arg2</code> 的元素的新数组。</p><p>如果参数 <code>argN</code> 是一个数组，那么其中的所有元素都会被复制，否则，将复制参数本身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-comment">// 从 arr 和 [3, 4] 创建一个新数组</span><br><span class="hljs-title function_">alert</span>( arr.<span class="hljs-title function_">concat</span>([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]) );            <span class="hljs-comment">// 1,2,3,4</span><br><span class="hljs-comment">// 从 arr、[3,4] 和 [5,6] 创建一个新数组</span><br><span class="hljs-title function_">alert</span>( arr.<span class="hljs-title function_">concat</span>([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]));     <span class="hljs-comment">// 1,2,3,4,5,6</span><br><span class="hljs-comment">// 从 arr、[3,4]、5 和 6 创建一个新数组</span><br><span class="hljs-title function_">alert</span>( arr.<span class="hljs-title function_">concat</span>([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">5</span>, <span class="hljs-number">6</span>) );      <span class="hljs-comment">// 1,2,3,4,5,6</span><br></code></pre></td></tr></table></figure><p>通常，它只复制数组中的元素，对于其他对象，即使看起来像数组一样，但也仍然会被作为一个整体添加。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">let</span> arrayLike = &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-string">&quot;something&quot;</span>，<br>    <span class="hljs-attr">length</span>: <span class="hljs-number">1</span><br>&#125;;<br><span class="hljs-title function_">alert</span>( arr.<span class="hljs-title function_">concat</span>(arrayLike) );         <span class="hljs-comment">// 1,2,[object object]</span><br></code></pre></td></tr></table></figure><p>但如果类数组对象具有 <code>Symbol.isConcatSpreadable</code> 属性，那么它就会被 <code>concat</code> 当做一个数组来处理：此对象中的元素将会被添加。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">let</span> arrayLike = &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-string">&quot;something&quot;</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-string">&quot;else&quot;</span><br>    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">isConcatSpreadable</span>]: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">length</span>: <span class="hljs-number">2</span><br>&#125;;<br><span class="hljs-title function_">alert</span>( arr.<span class="hljs-title function_">concat</span>(arrayLike) );     <span class="hljs-comment">// 1,2,something.else</span><br></code></pre></td></tr></table></figure><h2 id="遍历-forEach"><a href="#遍历-forEach" class="headerlink" title="遍历 forEach"></a>遍历 forEach</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">arr.forEach</a> 方法允许为数组的每个元素都运行一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>) &#123;<br>    <span class="hljs-comment">// do something with item</span><br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">forEach</span>(alert);   <span class="hljs-comment">// 1,2,3</span><br></code></pre></td></tr></table></figure><h2 id="在数组中搜索"><a href="#在数组中搜索" class="headerlink" title="在数组中搜索"></a>在数组中搜索</h2><p>数组中进行搜索的方法。</p><h3 id="indexOf-x2F-lastIndexOf-x2F-includes"><a href="#indexOf-x2F-lastIndexOf-x2F-includes" class="headerlink" title="indexOf&#x2F;lastIndexOf&#x2F;includes"></a>indexOf&#x2F;lastIndexOf&#x2F;includes</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf">arr.indexOf</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes">arr.includes</a> 语法类似，并且作用基本上也与字符串方法相同，只不过这里是对数组元素而不是字符进行操作。</p><ul><li><code>arr.indexOf(item, from)</code>————从索引 <code>from</code> 开始搜索 <code>item</code>，如果找到则返回索引，否则返回 <code>-1</code>；</li><li><code>arr.includes(item, from)</code>————从索引 <code>from</code> 开始搜索 <code>item</code>，如果找到则返回 <code>true</code>，否则返回 <code>false</code>；</li></ul><p>通常使用这些方法时只会传入一个参数：传入 item 开始搜索，默认从头开始。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>];<br><br><span class="hljs-title function_">alert</span>( arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">0</span>) );        <span class="hljs-comment">// 1</span><br><span class="hljs-title function_">alert</span>( arr.<span class="hljs-title function_">idnexOf</span>(<span class="hljs-literal">false</span>) );    <span class="hljs-comment">// 2</span><br><span class="hljs-title function_">alert</span>( arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-literal">null</span>) );     <span class="hljs-comment">// -1</span><br><span class="hljs-title function_">alert</span>( arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">1</span>) );       <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>indexOf</code> 和 <code>includes</code> 使用严格相等的 <code>===</code> 进行比较，如果搜索 <code>false</code>，则会准确找到 <code>false</code>，而不是数字 <code>0</code>。</p><p>若想检查数组中是否包含元素 item，并且不需要知道其确切的索引，那么 arr.includes 是首选。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf">arr.lastIndexOf</a> 与 <code>indexOf</code> 相同，但从右向左查找。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Orange&#x27;</span>, <span class="hljs-string">&#x27;Apple&#x27;</span>];<br><br><span class="hljs-title function_">alert</span>( fruits.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;Apple&#x27;</span>) );       <span class="hljs-comment">// 0（第一个 Apple）</span><br><span class="hljs-title function_">alert</span>( fruits.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&#x27;Apple&#x27;</span>) );   <span class="hljs-comment">// 2（最后一个 Apple）</span><br></code></pre></td></tr></table></figure><h3 id="find-x2F-findIndex-x2F-findLastIndex"><a href="#find-x2F-findIndex-x2F-findLastIndex" class="headerlink" title="find&#x2F;findIndex&#x2F;findLastIndex"></a>find&#x2F;findIndex&#x2F;findLastIndex</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find">arr.find</a> 从对象数组中找到具有特定条件的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> result = arr.<span class="hljs-title function_">find</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>) &#123;<br>    <span class="hljs-comment">// 如果返回 true，则返回 item 并停止迭代</span><br>    <span class="hljs-comment">// 如果返回 false，则返回 undefined</span><br>&#125;)；<br></code></pre></td></tr></table></figure><p>依次对数组中的每个元素调用该函数。</p><ul><li><code>item</code> 是元素；</li><li><code>index</code> 是它的索引；</li><li><code>array</code> 是数组本身。</li></ul><p>若它返回 <code>true</code>，则停止搜索，并返回 <code>item</code>；若没有搜索到，则返回 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> users = [<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mary&quot;</span>&#125;<br>];<br><span class="hljs-keyword">let</span> user = users.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">id</span> == <span class="hljs-number">1</span>);    <span class="hljs-comment">// 传给了 find 一个单参数函数 item =&gt; item.id == 1</span><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>);                               <span class="hljs-comment">// John</span><br></code></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex">arr.findIndex</a> 方法（与 <code>arr.find</code>）具有相同的语法，但它返回找到的元素的索引，而不是元素本身；若没找到，则返回 <code>-1</code>。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findLastIndex">arr.findLastIndex</a>方法类似于 <code>findIndex</code>，但从右往左搜索，类似于 <code>lastIndexOf</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> users = [<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mary&quot;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>&#125;<br>];<br><span class="hljs-comment">// 寻找第一个 John 的索引</span><br><span class="hljs-title function_">alert</span>(users.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> user.<span class="hljs-property">name</span> == <span class="hljs-string">&#x27;John&#x27;</span>));        <span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 寻找最后一个 John 的索引</span><br><span class="hljs-title function_">alert</span>(users.<span class="hljs-title function_">findLastIndex</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> user.<span class="hljs-property">name</span> == <span class="hljs-string">&#x27;John&#x27;</span>));    <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">arr.filter(fn)</a> 意为“筛选”，返回的是所有匹配元素组成的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> results = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>)&#123;<br>    <span class="hljs-comment">// 如果 true item 被 push 到 results，迭代继续</span><br>    <span class="hljs-comment">// 如果什么都没找到，则返回空数组</span><br>&#125;)；<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> users = [<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mary&quot;</span>&#125;<br>];<br><span class="hljs-keyword">let</span> someUsers = user.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">id</span> &lt; <span class="hljs-number">3</span>);<br><span class="hljs-title function_">alert</span>(someUsers.<span class="hljs-property">length</span>);    <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h2 id="转换数组"><a href="#转换数组" class="headerlink" title="转换数组"></a>转换数组</h2><p>数组转换和重新排序。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">arr.map</a> 意为“地图”，对数组的每个元素都调用函数，并返回结果数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> result = arr.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>)&#123;<br>    <span class="hljs-comment">// 返回新值而不是当前元素</span><br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> lengths = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">length</span>);     <span class="hljs-comment">// 将每个元素转换为它的字符串长度</span><br><span class="hljs-title function_">alert</span>(lengths);                                                         <span class="hljs-comment">// 5, 4, 6</span><br></code></pre></td></tr></table></figure><h3 id="sort-fn"><a href="#sort-fn" class="headerlink" title="sort(fn)"></a>sort(fn)</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">arr.sort</a> 意为“分类”，对数组进行原位 <strong>（in-place）</strong> 排序，更改元素的顺序。（原位是指在此数组内，而非生成一个新数组）。它还返回排序后的数组，但是返回值通常会被忽略，因为修改了 <code>arr</code> 本身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">15</span> ];<br>arr.<span class="hljs-title function_">sort</span>();                 <span class="hljs-comment">// 该方法重新排列 arr 的内容</span><br><span class="hljs-title function_">alert</span>( arr );               <span class="hljs-comment">// 1,15,2</span><br></code></pre></td></tr></table></figure><p>上面的顺序变成了 <code>1，15，2</code>。因为上面的<strong>元素在默认情况下被按字符串进行排序</strong>。从字面上看，所有元素都被转换为字符串，然后进行比较。对于字符串，按照字典顺序进行排序，实际上应该是 <code>&quot;2&quot;&gt;&quot;15&quot;</code>。</p><p>要使用我们自己的排序顺序，需要提供一个函数作为 <code>arr.sort()</code> 的参数。该函数应该比较两个任意值并返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compare</span>(<span class="hljs-params">a, b</span>)&#123;<br>    <span class="hljs-keyword">if</span>(a &gt; b)   <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;       <span class="hljs-comment">// 若第一个值比第二个值大</span><br>    <span class="hljs-keyword">if</span>(a == b)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       <span class="hljs-comment">// 若两个值相等</span><br>    <span class="hljs-keyword">if</span>(a &lt; b)   <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;      <span class="hljs-comment">// 若第一个值比第二个值小</span><br>&#125;<br></code></pre></td></tr></table></figure><p>按照数字排序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compareNumeric</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">if</span> (a &gt; b)    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (a == b)   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (a &lt; b)    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">15</span>];<br>arr.<span class="hljs-title function_">sort</span>(compareNumeric);<br><span class="hljs-title function_">alert</span>( arr );   <span class="hljs-comment">// 1, 2, 15</span><br></code></pre></td></tr></table></figure><p>现在结果超过预期了，<code>arr</code> 可以是由任何内容组成的数组，可能包含数字、字符串、对象或其他任何内容。我们有一组<strong>一些元素</strong>，要对其排序，需要一个<strong>排序函数</strong>来确认如何比较这些元素。默认是按照字符串进行排序。</p><p><code>arr.sort(fn)</code>方法实现了通用的排序算法。不需要关心内部工作原理（大部分情况下都是经过 <a href="https://en.wikipedia.org/wiki/Quicksort">快速排序</a> 或 <a href="https://en.wikipedia.org/wiki/Timsort">Timsort</a> 算法优化）。它将遍历数组，使用提供的函数比较其元素并对其重新排序，需要提供执行比较函数 <code>fn</code>。</p><p><strong>比较函数可以返回任何数字</strong>，实际上，比较函数只需要返回一个正数表示“大于”，一个负数表示“小于”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">15</span>];<br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) &#123; <span class="hljs-keyword">return</span> a - b; &#125;);<br><span class="hljs-title function_">alert</span>(arr);     <span class="hljs-comment">// 1, 2, 15</span><br>-------------------------------------------<br>arr.<span class="hljs-title function_">sort</span>( <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b );    <span class="hljs-comment">// 可用箭头函数代替</span><br></code></pre></td></tr></table></figure><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse">arr.reverse</a> 意为“颠倒”，用于颠倒 <code>arr</code> 中元素的顺序，并返回颠倒后的数组 <code>arr</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>arr.<span class="hljs-title function_">reverse</span>();<br><span class="hljs-title function_">alert</span>( arr );       <span class="hljs-comment">// 5, 4, 3, 2, 1</span><br></code></pre></td></tr></table></figure><h3 id="split-x2F-join"><a href="#split-x2F-join" class="headerlink" title="split&#x2F;join"></a>split&#x2F;join</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split">str.split(delim)</a>意为“分裂、拆开”，通过给定的分隔符 <code>delim</code> 将字符串分割成一个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> names = <span class="hljs-string">&#x27;Bilbo, Gandalf, Nazgul&#x27;</span>;<br><span class="hljs-keyword">let</span> arr = names.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;, &#x27;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> name <span class="hljs-keyword">of</span> arr)&#123;<br>    <span class="hljs-title function_">alert</span>( <span class="hljs-string">`A message tp <span class="hljs-subst">$&#123;name&#125;</span>.`</span> );   <span class="hljs-comment">// A message to Bilbo. / A message to Gandalf. / A message to Nazgul.</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>split</code> 方法有一个可选的第二个数字参数————对数组长度的限制。如果提供了，那么额外的元素就会被忽略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = <span class="hljs-string">&#x27;Bilbo, Gandalf, Nazgul, Saruman&#x27;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;, &#x27;</span>, <span class="hljs-number">2</span>);<br><span class="hljs-title function_">alert</span>(arr);                             <span class="hljs-comment">// Bilbo, Gandalf</span><br></code></pre></td></tr></table></figure><p>拆分为字母，调用带有空参数 <code>s</code> 的 <code>split(s)</code>，会将字符串拆分为字母数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;test&quot;</span><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>) );     <span class="hljs-comment">// t,e,s,t</span><br></code></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/join">arr.join(glue)</a>意为“加入”，与 <code>split</code> 相反，会在它们之间创建一串由 <code>glue</code> 粘合的 <code>arr</code> 项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;Bilbo&#x27;</span>, <span class="hljs-string">&#x27;Gandalf&#x27;</span>, <span class="hljs-string">&#x27;Nazgul&#x27;</span>];<br><span class="hljs-keyword">let</span> str = arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>);    <span class="hljs-comment">// 使用分号 ; 将数组粘合成字符串</span><br><span class="hljs-title function_">alert</span>( str );               <span class="hljs-comment">// Bilbo;Gandalf;Nazgul</span><br></code></pre></td></tr></table></figure><h3 id="reduce-x2F-reduceRight"><a href="#reduce-x2F-reduceRight" class="headerlink" title="reduce&#x2F;reduceRight"></a>reduce&#x2F;reduceRight</h3><p>当我们需要遍历一个数组时，可以使用 <code>forEach</code>，<code>for</code> 或 <code>for...of</code>，当我们需要遍历并返回每个元素的数据时，可以使用 <code>map</code>。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">arr.reduce</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">arr.reduceRight</a>意为“减少”，和上面的种类差不多，但稍微复杂些，用于根据数组计算单个值。<code>reduceRight</code> 与 <code>reduce</code> 方法功能一样，只是从右到左进行遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> value = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">accumulator, item, index, array</span>)&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;, [initial]);<br></code></pre></td></tr></table></figure><p>该函数一个接一个的应用于所有数组元素，并将其结果“搬运（carry on）”到下一个调用。</p><ul><li><code>accumulator</code>————是上一个函数调用的结果，第一次等于 <code>initial</code>（若提供了 <code>initial</code> 的话）；</li><li><code>item</code>————当前的数组元素；</li><li><code>index</code>————当前索引；</li><li><code>arr</code>————数组本身。</li></ul><p>应用函数时，上一个函数调用的结果将作为第一个参数传递到下一个函数。因此，第一个函数本质上是累加器，用于存储所有先前执行的组合结果，最后，成为 <code>reduce</code> 的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> result = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, current</span>) =&gt;</span> sum + current, <span class="hljs-number">0</span>);<br><span class="hljs-title function_">alert</span>(result);      <span class="hljs-comment">// 15</span><br></code></pre></td></tr></table></figure><p>传递给 <code>reduce</code> 的函数仅使用了 2 个参数，看看到底发生哪些事情。</p><ol><li>第一次运行时，<code>sum</code> 的值为初始值 <code>initial</code>（<code>reduce</code> 的最后一个参数），等于 <code>0</code>，<code>current</code> 是第一个数组元素，等于 <code>1</code>。所以函数运行的结果是 <code>1</code>；</li><li>第二次运行时，<code>sum = 1</code>，将第二个数组元素（2）与其相加并返回；</li><li>第三次运行时，<code>sum = 3</code>，继续把下一个元素与其相加，以此内推…</li></ol><p><img src="/../image/%E8%BD%AC%E6%8D%A2%E6%95%B0%E7%BB%841.png" alt="转换数组计算流程"></p><p>同样，也可以省略初始值，reduce 会将数组的第一个元素作为初始值，并从第二个元素开始迭代。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> result = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, current</span>) =&gt;</span> sum + current);   <span class="hljs-comment">// 删除 reduce 的初始值（没有 0）</span><br><span class="hljs-title function_">alert</span>( result );        <span class="hljs-comment">// 15</span><br></code></pre></td></tr></table></figure><h2 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a>Array.isArray</h2><p>数组是基于对象的，不构成单独的语言类型，所以 typeof 不能从数组中区分出普通对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>(<span class="hljs-keyword">typeof</span> &#123;&#125;);   <span class="hljs-comment">// object</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-keyword">typeof</span> []);   <span class="hljs-comment">// object</span><br></code></pre></td></tr></table></figure><p>使用一种特殊的方法用于判断：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray">Array.isArray(value)</a>，若 <code>value</code> 是一个数组，则返回 <code>true</code>，否则返回 <code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(&#123;&#125;));   <span class="hljs-comment">// false</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>([]));   <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数组方法：</p><ul><li>添加&#x2F;删除元素<ul><li><code>push(...items)</code>————向尾端添加元素；</li><li><code>pop()</code>————从尾端提取一个元素；</li><li><code>shift</code>————从首端提起一个元素；</li><li><code>unshift(...items)</code>————向首端添加元素；</li><li><code>splice(pos, deleteCount, ...items)</code>————从 <code>pos</code> 开始删除 <code>deleteCount</code> 个元素，并插入 <code>items</code>；</li><li><code>slice(start, end)</code>————创建一个新数组，将从索引 <code>start</code> 到索引 <code>end</code>（但不包括 <code>end</code>）的元素复制进去；</li><li><code>concat(...item)</code>————返回一个新数组：复制当前数组的所有元素，并向其中添加 <code>items</code>，若 <code>item</code> 中的任意一项是一个数组，那么取其元素；</li></ul></li><li>搜索元素<ul><li><code>indexOf/lastIndexOf(item, pos)</code>————从索引 <code>pos</code> 开始搜索 <code>item</code>，搜索到则返回该项的索引，否则返回 <code>-1</code>；</li><li><code>includes(value)</code>————如果数组有 <code>value</code>，则返回 <code>true</code>，否则返回 <code>false</code>；</li><li><code>find/filter(func)</code>————通过 <code>func</code> 过滤元素，返回使 <code>func</code> 返回 <code>true</code> 的第一个值&#x2F;所有值；</li><li><code>findIndex</code>————和 <code>find</code> 类似，但返回索引而不是值；</li></ul></li><li>遍历元素<ul><li><code>forEach(func)</code>————对每个元素都调用 <code>func</code>，不返回任何内容；</li></ul></li><li>转换数组<ul><li><code>map(func)</code>————根据对每个元素调用 <code>func</code> 的结果创建一个新数组；</li><li><code>sort(func)</code>————对数组进行原位（in-place）排序，然后返回它；</li><li><code>reverse()</code>————原位（in-place）反转数组，然后返回它；</li><li><code>split/join</code>————将字符串转换为数组并返回；</li><li><code>reduce/reduceRight(func, initial)</code>————通过对每个元素调用 <code>func</code> 计算数组上的单个值，并在调用之间传递中间结果；</li></ul></li><li>其他<ul><li><code>Array.isArray(value)</code>————检查 <code>value</code> 是否是一个数组，如果是则返回 <code>true</code>，否则返回 <code>false</code>。</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.javascript.info/array-methods">https://zh.javascript.info/array-methods</a></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>将 <code>&#39;my-long-word&#39;</code> 转换成 <code>&#39;myLongWord&#39;</code>，先删除所有短横线，再将除第一个字外的首字母大写，最后拼接起来成为驼峰。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">camelize</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">return</span> str<br>    .<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;-&#x27;</span>)   <span class="hljs-comment">// splits &#x27;my-long-word&#x27; into array [&#x27;my&#x27;, &#x27;long&#x27;, &#x27;word&#x27;]</span><br>    .<span class="hljs-title function_">map</span>(<br>                  <span class="hljs-comment">// capitalizes first letters of all array items except the first one</span><br>                  <span class="hljs-comment">// converts [&#x27;my&#x27;, &#x27;long&#x27;, &#x27;word&#x27;] into [&#x27;my&#x27;, &#x27;Long&#x27;, &#x27;Word&#x27;]</span><br>      <span class="hljs-function">(<span class="hljs-params">word, index</span>) =&gt;</span> index == <span class="hljs-number">0</span> ? word : word[<span class="hljs-number">0</span>].<span class="hljs-title function_">toUpperCase</span>() + word.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<br>    )<br>    .<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>);    <span class="hljs-comment">// joins [&#x27;my&#x27;, &#x27;Long&#x27;, &#x27;Word&#x27;] into &#x27;myLongWord&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指令集和微架构</title>
    <link href="/2023/04/28/%E6%8C%87%E4%BB%A4%E9%9B%86%E5%92%8C%E5%BE%AE%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/04/28/%E6%8C%87%E4%BB%A4%E9%9B%86%E5%92%8C%E5%BE%AE%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>指令集架构（<a href="https://en.wikipedia.org/wiki/Instruction_set_architecture">ISA</a>）是一款 CPU 处理指令及数据的规范，当我们输入指定格式的指令才能操作计算机，面向程序员和用户层面。</p><p>微架构（<a href="https://zh.wikipedia.org/zh-hans/%E5%BE%AE%E6%9E%B6%E6%A7%8B">MicroArchitecture</a>）通过设计处理器的指令执行单元，使得指令集架构（ISA）可以在处理器上被执行，面向 CPU 设计人员。</p><p>举个简单例子，小学老师教学一元二次方程，教学完成后，需要做很多一元二次方程题目，因此需要通过解题方法来解决实际问题，这里“解题方法”就是指令集，“具体题目”就是微架构。</p><h3 id="指令集分类"><a href="#指令集分类" class="headerlink" title="指令集分类"></a>指令集分类</h3><p>常见的指令集分类有两种，一种是复杂指令集（<a href="https://zh.wikipedia.org/zh-hans/%E8%A4%87%E9%9B%9C%E6%8C%87%E4%BB%A4%E9%9B%86%E9%9B%BB%E8%85%A6">CISC</a>），一种是精简指令集（<a href="https://zh.wikipedia.org/wiki/%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E9%9B%86%E8%AE%A1%E7%AE%97%E6%9C%BA">RISC</a>），其中 X86 属于复杂指令集，ARM、RISC-V、MIPS 等属于精简指令集。目前主流的指令集有三种，分别为 X86、ARM、RISC-V，形成了三分天下的局面。 </p><h3 id="指令集和微架构的关系"><a href="#指令集和微架构的关系" class="headerlink" title="指令集和微架构的关系"></a>指令集和微架构的关系</h3><p>微架构是指 CPU 为实现功能，对内部进行模块划分和逻辑设计，同一个指令集可以被实现为各种微架构，同时指令集会影响微架构的设计。</p><p>微架构的复杂程度和先进程度决定了 CPU 的性能。</p><h2 id="微架构"><a href="#微架构" class="headerlink" title="微架构"></a>微架构</h2><p>CPU 架构是指 <strong>接受和处理信号</strong> 的方式，换句话说，CPU 是一个工厂，不断的接受到信号，并且处理（运算）这些信号，架构就是在工厂里如何布置那些机器，让机器快速处理上面的工序。</p><p>CPU 的基本组成单元即为核心（core），核心的实现方式即被称为微架构。微架构的设计影响核心可以达到的最高频率、核心在一定频率下能执行的运算量、一定工艺下核心的能耗水平。</p><h3 id="微架构的发展历程"><a href="#微架构的发展历程" class="headerlink" title="微架构的发展历程"></a>微架构的发展历程</h3><p>推动计算机性能提升的一个车轮是半导体的微型化，另一个车轮就是微架构的改进，使得单位时间内可以执行更多的指令。</p><h4 id="流水线处理"><a href="#流水线处理" class="headerlink" title="流水线处理"></a>流水线处理</h4><p>假设 CPU 每个 Cycle（时钟周期：一个上升沿和一个下降沿） 可以执行一条指令，传统上执行完上一个完整的指令才能执行下一个完整的指令，CPU 性能难以提升，若想要提高性能，只能加快 CPU 的运行速度。若将一个完整的指令切分成多个分指令，<strong>流水式</strong>执行，这样每个周期做的事情会更少，CPU 可以运行的更快。所以流水切分的越多，CPU 频率就能跑的越快。</p><blockquote><p>举个栗子，若厨房只有一个厨师，需要做洗菜、切菜、炒菜、上菜四个步骤，则他每做一道完整的菜都需要经历这四个步骤，若厨房有四位厨师，分别负责洗菜、切菜、炒菜、上菜四个步骤，则从第一道菜完成后，整条流水线就能顺利运转起来。</p></blockquote><p><img src="/../image/%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt="流水线"></p><h4 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h4><blockquote><p>在上述栗子中，若客人点菜没有接上，则会出现一个问题，洗菜师傅洗好菜后，空闲下来了，接着切菜师傅切好菜后，也空闲下来了，若此时菜单又进来，则洗菜师傅开始洗菜，切菜师傅等待切菜，流水线得以重新运转起来。若有分支预测器，预测没菜单进来后，调度洗菜师傅洗完菜后再准备其他的菜品（菜馆热销榜前三），这样能够改善流水线上的功能。</p></blockquote><p>在计算机体系结构中，<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%94%AF%E9%A0%90%E6%B8%AC%E5%99%A8">分支预测器</a>是一种数字电路，在分支指令执行结束之前猜测哪一路分支将会被执行，已提高处理器的指令流水线的性能。</p><p>若没有分支预测器，处理器将会等待分支指令通过了指令流水线的执行阶段，才把下一条指令送入流水线的第一个阶段————取指令阶段（Fetch Stage），或者将后续流水线全部清空。这种技术叫做流水线停顿（Pipeline Stalled）或者流水线冒泡（Pipeline Bubbling）或者分支延迟间隙。</p><p><img src="/../image/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B.png" alt="分支预测"></p><p>如果绿色指令是跳转指令，则绿色指令没有执行时，紫色指令不能开始译码，这时流水线产生了空泡。同样，流水线级数越多，则分支导致空泡带来的影响也会越大。</p><p>分支预测器对一个未执行的分支指令进行判断，预测其是否跳转，若预测为跳转还要预测跳转的目标，然后以预测的结果去取值执行，分支预测可以缓解由控制依赖导致的流水线空泡。</p><h4 id="超标量"><a href="#超标量" class="headerlink" title="超标量"></a>超标量</h4><p>超标量（Super Scalar）是指具有两条或两条以上并行的流水线结构，亦称为“超标量流水线”，与之相对，之前的流水线则称为“标量流水线”。使用超标量结构的处理器称为<strong>超标量处理器</strong>。</p><blockquote><p>举个栗子，之前构建的一条流水线为洗菜、切菜、炒菜、上菜，若仍觉得吞吐率还不够高，其中一个改进的方向就是加深流水线，与之相对另一个改进的方向就是拓宽流水线。拓宽流水线的方案称为超标量。为满足更多客人的需求，需要把这条做菜的流水线进行拓宽，首先洗菜池扩大一倍，可以同时洗两道菜，对应后续各个环节都进行加倍。</p></blockquote><p><img src="/../image/%E8%B6%85%E6%A0%87%E9%87%8F1.png" alt="超标量"></p><p>上述栗子中每一个环节都有两道菜在同时的并行向前，对于处理器，这也称为双发射的结构，如果照着这个方式再扩展一条流水线就变成三发射，以此内推…</p><p><img src="/../image/Corei7%E7%9A%84%E8%B6%85%E6%A0%87%E9%87%8F%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt="Corei7的超标量流水线"></p><p>Core i7 的超标量流水线为 4 发射 16 级流水线，指令高度缓存（L1 Instruction Cache）相当于指令存储器，每个周期从指令存储器当中取回 128 比特（16 字节）指令，因 x86 指令长度不固定，所以先经过一个指令长度的译码器（ILD），分解出到底哪几个字节是一条指令。在译码器当中通过硬件会将 x86 的指令转换为更简单的指令，这些指令被称为微操作。从指令译码器（ID）中可以看出有三个简单的译码器（simple），用于对那些比较简单的 x86 指令进行转换，每条指令对应一个微操作，而那些非常复杂的指令则会通过复杂的译码器（complex）转换成多条微操作，而这些微操作都是类似于 RISC 指令的格式，在流水线后半部分看到的都是 RISC 格式的简单指令。在图右侧，可以看到多条并行的流水线（Port 0~5），而且在这个流水线当中运行的是微操作，都采用 RISC 的编码风格，因此这里也可以充分运用大量面向 RISC 处理器研发的高级流水线技术。这也是现在经常所说的 x86 虽然是一个 CISC 的指令系统，实际上是用 RISC 的方式去实现。</p><p>标量流水线和超标量流水线：</p><ul><li>单周期-&gt;标量流水线：<strong>时间并行性</strong>的优化，主要是对现有硬件的切分；</li><li>标量流水线-&gt;超标量流水线：<strong>空间并行性</strong>的优化，需城北增加硬件资源。</li></ul><p>从单周期处理器到流水线处理器主要考虑的是<strong>时间并行性</strong>上的优化，通过对现有硬件进行切分，只是增加了少量流水线寄存器以及部分的控制信号的改动，原本串行执行的指令在一定程度上并行起来。而从标量流水线到超标量流水线则是考虑了<strong>空间并行性</strong>上的优化，这是让不同的指令同时在不同的流水线上运行，简单来看，每增加一个发射数就需要增加一条流水线的硬件资源。</p><p><img src="/../image/%E8%B6%85%E6%A0%87%E9%87%8F%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%92%8C%E5%A4%9A%E6%A0%B8CPU.png" alt="超标量流水线和多核 CPU"></p><p>超标量流水线和多核 CPU 的关系从原理上来看，都是在空间并行性方面寻求的优化。处理器核除了上面的数据通路控制信号，还需要包含指令和数据的高度缓存（I-Cache 和 D-Cache），对应原理结构当中的指令存储器（Instruction Memory）和数据存储器（Data Memory），为了提高性能在处理器中还配备二级的高速缓存（L2 Cache）等，通常将这一部分称为一个处理器核。</p><p>上面的 4 发射 16 级流水线的结构图就是在一个处理器核内部的结构（图中最左边虚线内的框图），可以说一个处理器核就是一个超标量流水线的处理器核。在单核时代这部分结构会单独制造出一个芯片，称为单核 CPU。若将这样的结构复制多份，再加上一些共享的存储部件，就构成了一个多核的 CPU，这里面有四个核那就是一个四核的 CPU，每一个核内部就是一个超标量流水线的结构，因此这也是通常所说的多核 CPU 和超标量流水线之间的关系。</p><h3 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h3><p>乱序执行（Out-of-Order Execuction）是一种应用在高性能微处理器中来利用指令周期以避免特定类型的延迟消耗的范式，在这种范式中，处理器根据输入数据的可用性确定执行指令的顺序，而不是根据程序的原始数据决定。在这种方式下，可以避免因为获取下一条程序指令所引起的处理器等待，取而代之的处理下一条可以立即执行的指令。</p><p>在顺序 CPU 中，每条指令的流水都是一样长，先取值的指令先写回，这样可以保证程序的顺序性。但实际上，每条指令的执行复杂度是不一样的，有可能排在后面的指令先执行完，但先前执行的指令迟迟没有写回。</p><p>乱序执行是把结果先写入 ROB（Re Order Buffer）中，执行单元空出来提前执行后面的指令，乱序执行属于投机行为，更加依赖于分支预测的正确性，若分支预测失败导致流水线排空，会带来效率和能效上的浪费。</p><p><img src="/../image/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C.png" alt="乱序执行"></p><h2 id="架构识别"><a href="#架构识别" class="headerlink" title="架构识别"></a>架构识别</h2><p><img src="/../image/ARM%20A75%20%E5%BE%AE%E6%9E%B6%E6%9E%84.png" alt="ARM A75 微架构"></p><p>11 级流水线、三发、乱序、超标量处理器。</p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>ISA（Instruction Set Architecture）：指令集架构<br>CISC（Complex Instruction Set Computer）：复杂指令集<br>RISC（Reduced Instruction Set Computer）：精简指令集<br>Branch Predictor：分支预测器<br>ILD（Instruction Length Decoder）：指令长度译码器<br>OOE&#x2F;OoOE（Out of Order Execuction）：乱序执行</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><p><a href="https://zh.wikipedia.org/zh-hans/%E8%A4%87%E9%9B%9C%E6%8C%87%E4%BB%A4%E9%9B%86%E9%9B%BB%E8%85%A6">https://zh.wikipedia.org/zh-hans/%E8%A4%87%E9%9B%9C%E6%8C%87%E4%BB%A4%E9%9B%86%E9%9B%BB%E8%85%A6</a></p><p><a href="https://zh.wikipedia.org/wiki/%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E9%9B%86%E8%AE%A1%E7%AE%97%E6%9C%BA">https://zh.wikipedia.org/wiki/%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E9%9B%86%E8%AE%A1%E7%AE%97%E6%9C%BA</a></p><p><a href="https://zh.wikipedia.org/zh-hans/%E5%BE%AE%E6%9E%B6%E6%A7%8B">https://zh.wikipedia.org/zh-hans/%E5%BE%AE%E6%9E%B6%E6%A7%8B</a></p><p><a href="https://en.wikipedia.org/wiki/Instruction_set_architecture">https://en.wikipedia.org/wiki/Instruction_set_architecture</a></p><p><a href="https://www.zhihu.com/question/21827164">https://www.zhihu.com/question/21827164</a></p><p><a href="https://www.jianshu.com/p/fa7e11321cd8">https://www.jianshu.com/p/fa7e11321cd8</a></p><p><a href="https://www.jianshu.com/p/be389eeba589">https://www.jianshu.com/p/be389eeba589</a></p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS 数组</title>
    <link href="/2023/04/25/JS%20%E6%95%B0%E7%BB%84/"/>
    <url>/2023/04/25/JS%20%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>很多时候需要存储一些列表，如用户、商品及 HTML 元素等信息，需要数据（<code>Array</code>）类型的数据结构，能够存储有序的集合。</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>创建一个空数组有两种语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();<br><span class="hljs-keyword">let</span> arr = [];<br></code></pre></td></tr></table></figure><p>大部分情况下使用第二种语法，并且可在方框号中添加初始元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Plum&quot;</span>];<br></code></pre></td></tr></table></figure><p>JS 与 C 语言或其他语言一样，数组元素从 0 开始编号，这使得我们可以通过方括号中的数字获取元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Plum&quot;</span>];<br><br><span class="hljs-title function_">alert</span>(fruits[<span class="hljs-number">0</span>]);   <span class="hljs-comment">// Apple</span><br><span class="hljs-title function_">alert</span>(fruits[<span class="hljs-number">1</span>]);   <span class="hljs-comment">// Orange</span><br><span class="hljs-title function_">alert</span>(fruits[<span class="hljs-number">2</span>]);   <span class="hljs-comment">// Plum</span><br></code></pre></td></tr></table></figure><p>同时还能通过元素写入的方式进行值替换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">fruits[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;Peach&#x27;</span>;    <span class="hljs-comment">// [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Peach&quot;]</span><br></code></pre></td></tr></table></figure><p>同时还能通过通过元素写入的方式进行值添加。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">fruits[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;Lemon&#x27;</span>;    <span class="hljs-comment">// 现在变成 [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Peach&quot;, &quot;Lemon&quot;]</span><br></code></pre></td></tr></table></figure><p><code>length</code> 属性的值是数组中元素的总个数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Peach&quot;</span>, <span class="hljs-string">&quot;Lemon&quot;</span>];<br><span class="hljs-title function_">alert</span>(fruits.<span class="hljs-property">length</span>);   <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>同时数组名还可以显示整个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>(fruits);          <span class="hljs-comment">// [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Peach&quot;, &quot;Lemon&quot;]</span><br></code></pre></td></tr></table></figure><p>数组可以存储任何类型的元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 混合值</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;Apple&#x27;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>&#125;, <span class="hljs-literal">true</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hello&#x27;</span>); &#125; ]<br><span class="hljs-comment">// 获取索引为 1 的对象然后显示 name</span><br><span class="hljs-title function_">alert</span>( arr[<span class="hljs-number">1</span>].<span class="hljs-property">name</span> );   <span class="hljs-comment">// John</span><br><br><span class="hljs-comment">// 获取索引为 3 的函数并执行</span><br>arr[<span class="hljs-number">3</span>]();               <span class="hljs-comment">// hello</span><br></code></pre></td></tr></table></figure><p>数组与对象相似，可以以逗号结尾。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> fruits = [<br>    <span class="hljs-string">&quot;Apple&quot;</span>,<br>    <span class="hljs-string">&quot;Orange&quot;</span>,<br>    <span class="hljs-string">&quot;Plum&quot;</span>,<br>];<br></code></pre></td></tr></table></figure><h2 id="使用-“at”-获取最后一个元素"><a href="#使用-“at”-获取最后一个元素" class="headerlink" title="使用 “at” 获取最后一个元素"></a>使用 “at” 获取最后一个元素</h2><p>若想要数组中最后一个元素，其他语言允许使用负数索引来实现，如 <code>fruits[-1]</code>。对于 JavaScript 行不通，结果将会是 <code>undefined</code>，方括号中的索引会按照字面意思处理。</p><p>可以采取显示计算最后一个元素的索引，如 <code>fruits[fruits.length -1]</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Plum&quot;</span>];<br><span class="hljs-title function_">alert</span>( fruits[fruits.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>] );   <span class="hljs-comment">// Plum</span><br></code></pre></td></tr></table></figure><p>同样，可以采取更简短的语法 <code>fruits.at(-1)</code> 来实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Plum&quot;</span>];<br><br><span class="hljs-comment">// 与 fruits[fruits.length-1] 相同</span><br><span class="hljs-title function_">alert</span>( fruits.<span class="hljs-title function_">at</span>(-<span class="hljs-number">1</span>) );             <span class="hljs-comment">// Plum</span><br></code></pre></td></tr></table></figure><p>对于 <code>arr.at(i)</code> 来说，</p><ul><li>若 <code>i &gt;= 0</code> 时，则与 <code>arr[i]</code> 完全相同；</li><li>若 <code>i</code> 为负数，则从数组的尾部向前数。</li></ul><h2 id="pop-x2F-push-shift-x2F-unshift-方法"><a href="#pop-x2F-push-shift-x2F-unshift-方法" class="headerlink" title="pop&#x2F;push, shift&#x2F;unshift 方法"></a>pop&#x2F;push, shift&#x2F;unshift 方法</h2><p><a href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)">队列（queue）</a> 是最常用的使用数组的方法之一，表示支持两个操作的一个有序元素的集合。</p><ul><li><code>push</code> 在末端添加一个元素；</li><li><code>shift</code> 取出队列首端的一个元素，整个队列往前移，这样原先排在第二的元素现在排在了第一。</li></ul><p><img src="/../image/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%AF%94%E5%96%BB%E5%9B%BE10.png" alt="键值对比喻图"></p><p>这两种操作数组都支持，队列的应用在实践中也经常会碰到，如在屏幕上显示消息队列。</p><p>同时数组还有另一个用例，就是数据结构 [栈]。(<a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type))%E3%80%82">https://en.wikipedia.org/wiki/Stack_(abstract_data_type))。</a></p><p>它支持两种操作：</p><ul><li><code>push</code> 在末端添加一个元素；</li><li><code>pop</code> 从末端取出一个元素。</li></ul><p>所以新元素的添加和取出都是从“末端”开始，栈通常被形容为一叠卡片，要么在最上面添加卡片，要么在最上面拿走卡片。</p><p><img src="/../image/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%AF%94%E5%96%BB%E5%9B%BE11.png" alt="键值对比喻"></p><p>对于栈来说，最后放进去的内容最先接收，也叫作 LIFO（Last-In-First_Out），即后进先出法则。而队列对应的恰恰相反，叫做 FIFO（First-In-First-Out），即先进先出法则。</p><p>JS 中的数组既可以用作队列，也可以用作栈，允许从首端&#x2F;末端来添加&#x2F;删除元素。允许这样的操作的数据结构也被称为<a href="https://en.wikipedia.org/wiki/Double-ended_queue">双端队列</a>。</p><h3 id="作用在数组末端的方法"><a href="#作用在数组末端的方法" class="headerlink" title="作用在数组末端的方法"></a>作用在数组末端的方法</h3><h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><p><code>pop</code> 取出并返回数组的最后一个元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>];<br><br><span class="hljs-title function_">alert</span>( fruits.<span class="hljs-title function_">pop</span>() );  <span class="hljs-comment">// 移除 &quot;Pear&quot;</span><br><span class="hljs-title function_">alert</span>( fruits );        <span class="hljs-comment">// Apple, Orange</span><br></code></pre></td></tr></table></figure><p><code>fruits.pop</code> 和 <code>fruits.at(-1)</code> 都返回数组的最后一个元素，但 <code>fruits.pop()</code> 同时也删除数组的最后一个元素，进而修改了原数组。</p><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p><code>push</code> 在数组末端添加元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>];<br>fruits.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;Pear&quot;</span>);<br><span class="hljs-title function_">alert</span>( fruits );        <span class="hljs-comment">// Apple, Orange, Pear</span><br></code></pre></td></tr></table></figure><p>调用 <code>fruits.push(...)</code> 和 <code>fruits[fruits.length] = ...</code> 是一样的。</p><h3 id="作用在数组首端的方法"><a href="#作用在数组首端的方法" class="headerlink" title="作用在数组首端的方法"></a>作用在数组首端的方法</h3><h4 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h4><p><code>shift</code> 取出数组的第一个元素并返回它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>];<br><br><span class="hljs-title function_">alert</span>( fruits.<span class="hljs-title function_">shift</span>() );    <span class="hljs-comment">// 移除 Apple</span><br><span class="hljs-title function_">alert</span>( fruits );            <span class="hljs-comment">// Orange, Pear</span><br></code></pre></td></tr></table></figure><h4 id="unshift"><a href="#unshift" class="headerlink" title="unshift"></a>unshift</h4><p><code>unshift</code> 在数组的首端添加元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>];<br>fruits.<span class="hljs-title function_">unshift</span>(<span class="hljs-string">&#x27;Apple&#x27;</span>);    <br><span class="hljs-title function_">alert</span>( fruits );            <span class="hljs-comment">// Apple, Orange, Pear</span><br></code></pre></td></tr></table></figure><p><code>push</code> 和 <code>unshift</code> 方法都可以一次性添加多个元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Apple&quot;</span>];<br><br>fruits.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Peach&quot;</span>);<br>fruits.<span class="hljs-title function_">unshift</span>(<span class="hljs-string">&quot;Pineapple&quot;</span>, <span class="hljs-string">&quot;Lemon&quot;</span>);<br><span class="hljs-title function_">alert</span>( fruits );            <span class="hljs-comment">// [&quot;Pineapple&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Orange&quot;, &quot;Peach&quot;]</span><br></code></pre></td></tr></table></figure><h2 id="内部机制"><a href="#内部机制" class="headerlink" title="内部机制"></a>内部机制</h2><p>数组是一种特殊的对象，使用方括号来访问属性 <code>arr[0]</code> 实际上是来自于对象的语法，其实与 <code>obj[key]</code> 相同，其中 <code>arr</code> 是对象，而数字用作键（key）。其拓展了对象，提供了特殊的方法来处理有序的数据集合以及 <code>length</code> 属性，但从本质上讲，其仍然为一个对象。</p><p>数组是一个对象，其行为也像一个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>]<br><br><span class="hljs-keyword">let</span> arr = fruits;           <span class="hljs-comment">// 通过引用复制（两个变量引用的是相同的数组）</span><br><span class="hljs-title function_">alert</span>( arr === fruit );     <span class="hljs-comment">// true    </span><br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;Pear&quot;</span>);           <span class="hljs-comment">// 通过引用修改数组</span><br><span class="hljs-title function_">alert</span>( fruits );            <span class="hljs-comment">// Banana, Pear</span><br></code></pre></td></tr></table></figure><p>数组真正特殊的是内部实现，JS 尝试将这些元素一个接一个存储在连续的内存区域，而且还包含着一些其他的优化，使得数组运行的更快。</p><p>若不想“有序集合”那样使用数组，而像常规对象那样使用数组，这些就都不生效。</p><p>例如，从技术上，可以实现以下操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> fruits = [];    <span class="hljs-comment">// 创建一个数组</span><br><br>fruits[<span class="hljs-number">99999</span>] = <span class="hljs-number">5</span>;  <span class="hljs-comment">// 分配索引远大于数组长度的属性</span><br><br>fruits.<span class="hljs-property">age</span> = <span class="hljs-number">27</span>;    <span class="hljs-comment">// 创建一个具有任意名称的属性</span><br></code></pre></td></tr></table></figure><p>但 JS 会发现，若像使用常规对象一样使用数组，那么针对数组的优化就不再适用，然后对应的优化就会关闭。</p><p>数组误用的几种方式：</p><ul><li>添加一个非数字的属性；如：<code>arr.test = 5</code>；    </li><li>制造空洞；如：添加 <code>arr[0]</code>，然后添加 <code>arr[1000]</code>，但中间什么都没有；</li><li>以倒序填充数组；如 <code>arr[1000]</code>，<code>arr[999]</code> 等。</li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p><code>push/pop</code> 方法运行的比较快，而 <code>shift/unshift</code> 比较慢。</p><p><img src="/../image/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%AF%94%E5%96%BB%E5%9B%BE12.png" alt="键值对比喻图"></p><p>为什么作用于数组的末端会比首端快？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">fruits.<span class="hljs-title function_">shift</span>();         <span class="hljs-comment">// 从首端取出一个元素</span><br></code></pre></td></tr></table></figure><p>只获取并移除索引 <code>0</code> 对应的元素不够，其他元素也需要被重新编号。</p><p><code>shift</code> 操作必须做三件事：</p><ol><li>移除索引为 <code>0</code> 的元素；</li><li>把所有的元素向左移动，把索引 <code>1</code> 改为 <code>0</code>，<code>2</code> 改为 <code>1</code>，以此类推，对齐重新编号；</li><li>更新 <code>length</code> 属性。</li></ol><p>数组里的元素越多，移动它们就需要花费更多的时间，也就意味着越多的内存操作。</p><p><code>unshift</code> 也是一样：为了在数组的首端添加元素，首先需要将现有的元素向右移动，增加它们的索引值。</p><p><code>push/pop</code> 则不需要移动任何东西。若从末端移除一个元素，<code>pop</code> 方法只需要清理索引值并缩短 <code>length</code> 就行。</p><p>pop 操作的行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">fruits.<span class="hljs-title function_">pop</span>();       <span class="hljs-comment">// 从末端取走一个元素</span><br></code></pre></td></tr></table></figure><p><img src="/../image/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%AF%94%E5%96%BB%E5%9B%BE14.png" alt="键值对比喻图"></p><p><code>pop</code> <strong>方法不需要移动任何东西，因此其他元素都保留了各自的索引</strong>，这就是为什么 <code>pop</code> 会特别快。<code>push</code> 方法也是一样。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>遍历数组最古老的方式就是 for 循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>]<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-title function_">alert</span>( arr[i] );<br>&#125;<br></code></pre></td></tr></table></figure><p>对于数组来说还有另一种循环方式，<code>for...of</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Plum&quot;</span>];<br><span class="hljs-comment">// 遍历数组元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> fruit <span class="hljs-keyword">of</span> fruits) &#123;<br>    <span class="hljs-title function_">alert</span>( fruit );<br>&#125;<br></code></pre></td></tr></table></figure><p><code>for...of</code> 不能获取当前元素的索引，只是获取元素值，但大多数情况是够用的，而且这样写更短。</p><h2 id="关于“length”"><a href="#关于“length”" class="headerlink" title="关于“length”"></a>关于“length”</h2><p>当修改数组时，<code>length</code> 属性会自动更新，准确的说，实际上不是数组里元素的个数，而是最大的数字索引值加一。</p><p>例如，一个数组只有一个元素，但这个元素的索引值很大，那么这个数组的 <code>length</code> 也会很大。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> fruits = [];<br>fruits[<span class="hljs-number">123</span>] = <span class="hljs-string">&quot;Apple&quot;</span>;<br><br><span class="hljs-title function_">alert</span>( fruits.<span class="hljs-property">length</span> );     <span class="hljs-comment">// 124</span><br></code></pre></td></tr></table></figure><p><code>length</code> 属性会可写，若手动增加，则不会发生任何有趣的事情，若想减少它，数组就会被截断，该过程不可逆。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>arr.<span class="hljs-property">length</span> = <span class="hljs-number">2</span>;             <span class="hljs-comment">// 截断到只剩 2 个元素</span><br><span class="hljs-title function_">alert</span>(arr);                 <span class="hljs-comment">// [1, 2]</span><br><br>arr.<span class="hljs-property">length</span> = <span class="hljs-number">5</span>;             <span class="hljs-comment">// 又把 length 加回来</span><br><span class="hljs-title function_">alert</span>( arr[<span class="hljs-number">3</span>] );            <span class="hljs-comment">// undefined：被截断的那些数值并没有回来</span><br></code></pre></td></tr></table></figure><p>清空数组最简单的方法：<code>arr.length = 0;</code></p><h2 id="new-Array"><a href="#new-Array" class="headerlink" title="new Array()"></a>new Array()</h2><p><code>new Array()</code> 是创建数组的另一种语法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>, <span class="hljs-string">&quot;etc&quot;</span>);<br></code></pre></td></tr></table></figure><p>但这种方式很少被使用，因为方括号 [] 更短更简洁，而且还会有一个棘手的特性。若使用单个参数（即数字）调用 new Array，那么会创建一个<strong>指定了长度，却没有任何项</strong>的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">2</span>);     <span class="hljs-comment">// 会创建一个 [2] 的数组吗？</span><br><br><span class="hljs-title function_">alert</span>( arr[<span class="hljs-number">0</span>] );            <span class="hljs-comment">// undefined！没有元素。</span><br><br><span class="hljs-title function_">alert</span>( arr.<span class="hljs-property">length</span> );        <span class="hljs-comment">// length 2</span><br></code></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>数组里的项也可以是数组。可以将其用于多维数组，例如存储矩阵。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> matrix = [<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>    [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>],<br>    [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br>];<br><br><span class="hljs-title function_">alert</span>( matrix[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] );  <span class="hljs-comment">// 最中间的那个数</span><br></code></pre></td></tr></table></figure><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><p>数组有自己的 <code>toString</code> 方法的实现，会返回以逗号隔开的元素列表。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-title function_">alert</span>( arr );<br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">String</span>(arr) === <span class="hljs-string">&#x27;1, 2, 3&#x27;</span> );     <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( [] + <span class="hljs-number">1</span> );        <span class="hljs-comment">// &quot;1&quot;</span><br><span class="hljs-title function_">alert</span>( [<span class="hljs-number">1</span>] + <span class="hljs-number">1</span> );       <span class="hljs-comment">// &quot;11&quot;</span><br><span class="hljs-title function_">alert</span>( [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] + <span class="hljs-number">1</span> );    <span class="hljs-comment">// &quot;1,21&quot;</span><br></code></pre></td></tr></table></figure><p>数组没有 <code>symbol.toPrimitive</code>，也没有 <code>valueOf</code>，它们只能执行 <code>toString</code> 进行转换，所以这里 <code>[]</code> 就变成一个空字符串，<code>[1]</code> 变成 <code>&quot;1&quot;</code>，<code>[1, 2]</code> 变成了 <code>&quot;1, 2&quot;</code>。</p><p>当 <code>&quot;+&quot;</code> 运算符把一些项加到字符串后面时，加号后面的项也会被转换为字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;&quot;</span> + <span class="hljs-number">1</span> );        <span class="hljs-comment">// &quot;1&quot;</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;1&quot;</span> + <span class="hljs-number">1</span> );       <span class="hljs-comment">// &quot;11&quot;</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;1,2&quot;</span> + <span class="hljs-number">1</span> );     <span class="hljs-comment">// &quot;1,21&quot;</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数组是一种特殊的对象，适用于存储和管理有序的数据项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 方括号 (常见用法)</span><br><span class="hljs-keyword">let</span> arr = [item1, item2...];<br><br><span class="hljs-comment">// new Array (极其少见)</span><br><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(item1, item2...);<br></code></pre></td></tr></table></figure><p>调用 <code>new Array（number）</code> 会创建一个给定长度的数组，但不含有任何项。</p><ul><li><code>length</code> 属性是数组的长度，准确说，它是数组最后一个数字索引值加一，由数组方法自动调整；</li><li>若手动缩短 <code>length</code>，数组就会被截断。</li></ul><p>获取元素：</p><ul><li>通过元素的索引获取元素，如 <code>arr[0]</code>;</li><li>通过使用允许负索引的 <code>at(i)</code> 方法，对于负值的 i，会从数组的末尾往回数，若 <code>i &gt;= 0</code>，工作方式与 <code>arr[i]</code> 相同。</li></ul><p>通过下列操作以双端队列的方式使用数组：</p><ul><li><code>push(...items)</code> 在末端添加 <code>items</code> 项；</li><li><code>pop()</code> 从末端移除并返回该元素；</li><li><code>shift()</code> 从首端移除并返回该元素；</li><li><code>unshift(...items)</code> 从首端添加 <code>items</code> 项。</li></ul><p>遍历数组的元素：</p><ul><li><code>for (let i=0; i&lt;arr.length; i++)</code>  运行得最快</li><li><code>for (let item of arr)</code>             只能访问 items</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.javascript.info/array#duo-wei-shu-zu">https://zh.javascript.info/array#duo-wei-shu-zu</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>父子组件引用</title>
    <link href="/2023/04/24/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%BC%95%E7%94%A8/"/>
    <url>/2023/04/24/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>进行项目开发时，根据角色登录信息的不同，显示页面略微会有差异，但显示页面中大部分内容都是相同的，因此想把差异化的部分抽象成组件，在共同页面中引用，利用传递的状态值，控制差异化部分的内容是否可见。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>这里以 Element 中 <a href="https://element.eleme.cn/2.0/#/zh-CN/component/transfer">Transfer 穿梭框</a> 为例进行差异化引用。</p><h3 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;template&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-transfer</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;value&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">filterable</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">:titles</span>=<span class="hljs-string">&quot;[&#x27;Source&#x27;, &#x27;Target&#x27;]&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">:button-texts</span>=<span class="hljs-string">&quot;[&#x27;向左去&#x27;, &#x27;向右去&#x27;]&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">:props</span>=<span class="hljs-string">&quot;&#123;</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            key: &#x27;id&#x27;,</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            label: &#x27;name&#x27;</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">        &#125;&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">:data</span>=<span class="hljs-string">&quot;data&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;transfer&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;handleChange&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;&#123; option &#125;&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;float:left&quot;</span>&gt;</span>&#123;&#123; option.name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;float:left&quot;</span>&gt;</span>&#123;&#123; option.fileType &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">el-transfer</span>&gt;</span></span><br>&lt;/template&gt;<br>  <br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">data</span>: [],       <span class="hljs-comment">// 数据源</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">value</span>: [],      <span class="hljs-comment">// 页面显示右边已选择的数据</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">option</span>: <span class="hljs-string">&quot;&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">    created () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">load</span>()</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        handleChange () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;func&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;this.value&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">        load () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;请求接口&#x27;</span>, &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">params</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-comment">/* 请求参数 */</span></span></span><br><span class="language-javascript"><span class="language-xml">                &#125;</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-comment">/* 请求回来的参数 */</span></span></span><br><span class="language-javascript"><span class="language-xml">            &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml">    &#123;<span class="hljs-comment">/* 穿梭框外框的高宽度  */</span>&#125;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-selector-class">.el-transfer-panel</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span></span><br><span class="language-css"><span class="language-xml">    &#125;</span></span><br><span class="language-css"><span class="language-xml">    &#123;<span class="hljs-comment">/* 穿梭框内部展示列表的高宽度 */</span>&#125;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-selector-class">.el-transfer-panel__list</span><span class="hljs-selector-class">.is-filterable</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span></span><br><span class="language-css"><span class="language-xml">    &#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="子组件功能"><a href="#子组件功能" class="headerlink" title="子组件功能"></a>子组件功能</h4><p>子组件中常用的属性参数如下：</p><ul><li><code>data</code>：Transfer 的数据源；</li><li><code>filterable</code>：是否可以搜索；</li><li><code>titles</code>：自定义列表标题；</li><li><code>button-texts</code>：自定义按钮文案；</li><li><code>props</code>：数据源的字段别名；</li></ul><p>子组件中常用的时间参数如下：</p><ul><li><code>change</code>：右侧列表元素变化时触发；</li></ul><p>load 函数中 <code>this.request.get</code> 通过参数请求后端数据，并将后端数据给到 <code>this.data</code>，</p><p><code>handleChange</code> 函数中的 <code>this.$emit(&#39;func&#39;,this.value)</code> 可将 <code>this.value</code> 中的数据传递给父组件。</p><ul><li><code>func</code>: 是父组件指定的传数据绑定的函数；</li><li><code>this.value</code>：子组件给父组件传递的数据；</li></ul><h3 id="父组件"><a href="#父组件" class="headerlink" title="父组件"></a>父组件</h3><p>在前端页面中需要显示的位置上加入以下代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;div @change=handleTransfer&gt;&lt;/div&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;transferInfo&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 30px; margin-top: 50px;&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-weight: bold&quot;</span>&gt;</span>xxx列表<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin-top: 10px&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">transfer</span> <span class="hljs-attr">:state</span>=<span class="hljs-string">&quot;true&quot;</span> @<span class="hljs-attr">func</span>=<span class="hljs-string">&quot;getMsgFormTransfer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">transfer</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在脚本中引用需要配置好的组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;srcipt&gt;<br><span class="hljs-keyword">import</span> transfer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./transfer.vue&#x27;</span>;      <span class="hljs-comment">// 同文件夹下引用组件</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">components</span>: &#123;                           <span class="hljs-comment">// 组件中声明</span><br>        transfer,                             <br>    &#125;,<br>    data () &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">transferInfo</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-attr">transferMsg</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        &#125;<br>    &#125;,<br>    handleTransfer () &#123;<br>        <span class="hljs-keyword">let</span> reviewStatus = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-comment">/* 判断每一次循环对象的值 */</span><br>            reviewStatus &amp;= <span class="hljs-comment">/* 对每一次循环的值做与运算 */</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (reviewStatus == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">transferInfo</span> = <span class="hljs-literal">true</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">transferInfo</span> = <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-comment">//------------------ 选择三级评审员 ----------------------</span><br>    <span class="hljs-title function_">getMsgFormTransfer</span>(<span class="hljs-params">data</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">transferMsg</span> = data<br>    &#125;,<br>&#125;,<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><img src="/../image/transfer.png" alt="Transfer 穿梭框"></p><h4 id="父组件功能"><a href="#父组件功能" class="headerlink" title="父组件功能"></a>父组件功能</h4><p>在父组件中想要实现满足所有条件后显示子组件中的内容，所以使用 <code>v-if</code> 判断语句来实现。</p><ul><li><code>transferInfo</code>：先给定默认布尔值为 <code>false</code>，等到所有条件满足后，对结果赋值为 <code>true</code>；</li><li><code>handleTransfer</code>：处理判断的所有条件，并对所有条件的结果，赋对应布尔值；</li><li><code>getMsgFormTransfer</code>：定义变量，接收来自子组件传递的数据。</li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>Vue 使用 <code>import...from...</code> 来导入组件、库、变量等，<code>from</code> 后的来源可以是 js，vue，json。引入文件可以在<br><code>webpack.base.conf.js</code> 中设置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">resolve</span>: &#123;<br>        <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;.js&#x27;</span>, <span class="hljs-string">&#x27;.vue&#x27;</span>, <span class="hljs-string">&#x27;.json&#x27;</span>],<br>        <span class="hljs-attr">alias</span>: &#123;<br>            <span class="hljs-string">&#x27;@&#x27;</span>: <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;src&#x27;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br>...<br></code></pre></td></tr></table></figure><h3 id="引用文件"><a href="#引用文件" class="headerlink" title="引用文件"></a>引用文件</h3><p>extensions 指定了 from 后可导入的文件类型。上面定义的 3 类文件，js 和 vue 可以省略后缀。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> test <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test.vue&#x27;</span>   <span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">import</span> test <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test&#x27;</span><br><br><span class="hljs-keyword">import</span> test <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test.js&#x27;</span>    <span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">import</span> test <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test&#x27;</span><br><br><span class="hljs-comment">// json不可以省略后缀</span><br><br><span class="hljs-keyword">import</span> test <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test.json&#x27;</span><br></code></pre></td></tr></table></figure><p>若 <code>test.vue</code> 和 <code>test.js</code> 同时存在于同一个文件夹下，则 import 引入优先级为 <code>js &gt; vue</code>。</p><h3 id="引入文件夹"><a href="#引入文件夹" class="headerlink" title="引入文件夹"></a>引入文件夹</h3><p><code>import test from &#39;./components&#39;</code> 在该情况下的逻辑是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">if</span>(package.<span class="hljs-property">json</span> 存在 &amp;&amp; package.<span class="hljs-property">main</span> 字段存在 &amp;&amp; package.<span class="hljs-property">main</span> 指定的 js 存在) &#123;<br>    取 package.<span class="hljs-property">main</span> 指定的 js 作为 <span class="hljs-keyword">from</span> 的来源，即使该 js 可能格式或内容错误<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( index.<span class="hljs-property">js</span> 存在)&#123;<br>    取 index.<span class="hljs-property">js</span> 作为 <span class="hljs-keyword">from</span> 的来源<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    取 index.<span class="hljs-property">vue</span> 作为 <span class="hljs-keyword">from</span> 的来源<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，若 from 的来源是文件夹，那么在 <code>package.json</code> 存在且设置正确的情况下，会默认加载 <code>package.json</code>；若不满足，则加载 <code>index.js</code>；若不满足，则加载 <code>index.vue</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/jin-zhe/p/9268602.html">https://www.cnblogs.com/jin-zhe/p/9268602.html</a></p><p><a href="https://blog.51cto.com/BADAOLIUMANGQZ/6116184">https://blog.51cto.com/BADAOLIUMANGQZ/6116184</a></p><p><a href="https://blog.csdn.net/fyyyr/article/details/83657828">https://blog.csdn.net/fyyyr/article/details/83657828</a></p><p><a href="https://v2.cn.vuejs.org/v2/guide/components-registration.html#%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F">https://v2.cn.vuejs.org/v2/guide/components-registration.html#%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F</a></p><p><a href="https://zh.javascript.info/import-export">https://zh.javascript.info/import-export</a></p><p><a href="https://blog.csdn.net/hongyuancao/article/details/88077749">https://blog.csdn.net/hongyuancao/article/details/88077749</a></p><p><a href="https://www.cainiaojc.com/note/qa36lm.html">https://www.cainiaojc.com/note/qa36lm.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECharts X轴坐标文字显示不全</title>
    <link href="/2023/04/20/X%E8%BD%B4%E5%9D%90%E6%A0%87%E6%96%87%E5%AD%97%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%85%A8/"/>
    <url>/2023/04/20/X%E8%BD%B4%E5%9D%90%E6%A0%87%E6%96%87%E5%AD%97%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在 ECharts 中应用柱状图或折线图时，当数据量过多时，X 轴坐标信息就会显示不全。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="旋转属性"><a href="#旋转属性" class="headerlink" title="旋转属性"></a>旋转属性</h3><p>ECharts 图表组件内部有一个机制，用于统计 xAxis 坐标刻度的个数和图表宽度，从而会自动调整刻度间隔个数以此达到刻度互相之间不至于很拥挤而影响图表欣赏性。</p><p><code> xAxis.axisLabel. interval</code>：坐标轴刻度标签的显示间隔</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">interval = <span class="hljs-string">&#x27;auto&#x27;</span>,  <span class="hljs-comment">// 采用标签不重叠的策略间隔显示标签</span><br>interval = <span class="hljs-number">0</span>,       <span class="hljs-comment">// 强制显示所有标签</span><br>interval = <span class="hljs-number">1</span>,       <span class="hljs-comment">// 隔一个标签显示一个标签</span><br>interval = <span class="hljs-number">2</span>,       <span class="hljs-comment">// 隔两个标签显示一个标签</span><br></code></pre></td></tr></table></figure><p><code>xAxis.axisLabel. rotate</code>：刻度标签旋转的角度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">rotate = <span class="hljs-number">30</span>,        <span class="hljs-comment">// 旋转角度从 -90° 到 90°</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-attr">xAxis</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;category&#x27;</span>,<br>    <span class="hljs-attr">axisTick</span>: &#123;<br>        <span class="hljs-attr">alignWithLabel</span>: <span class="hljs-literal">true</span><br>    &#125;,<br>    <span class="hljs-attr">data</span>: [],<br>    <span class="hljs-attr">axisLabel</span>: &#123;<br>        <span class="hljs-attr">interval</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">rotate</span>: <span class="hljs-number">0</span>,<br>    &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="dataZoom"><a href="#dataZoom" class="headerlink" title="dataZoom"></a>dataZoom</h3><p>dataZoom 组件用于区域缩放，从而能自由关注细节的数据信息，或者概览数据整体，或者去除离群点的影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-attr">dataZoom</span>: [&#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;slider&#x27;</span>,<br>    <span class="hljs-attr">orient</span>: <span class="hljs-string">&quot;horizontal&quot;</span>,<br>    <span class="hljs-attr">show</span>: <span class="hljs-literal">true</span>,     <span class="hljs-comment">// 控制滚动条显示隐藏</span><br>    <span class="hljs-attr">realtime</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 拖动滚动条时是否动态的更新图表数据</span><br>    <span class="hljs-attr">height</span>: <span class="hljs-number">20</span>,     <span class="hljs-comment">// 滚动条高度</span><br>    <span class="hljs-attr">startValue</span>: <span class="hljs-number">0</span>,  <span class="hljs-comment">// 数据窗口范围的起始数值</span><br>    <span class="hljs-attr">endValue</span>: <span class="hljs-number">6</span>,    <span class="hljs-comment">// 数据窗口范围的结束数值</span><br>    <span class="hljs-attr">bottom</span>: <span class="hljs-string">&#x27;3%&#x27;</span>,   <span class="hljs-comment">// 滚动条距边距离</span><br>    <span class="hljs-attr">zoomLock</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 控制面板是否进行缩放</span><br>&#125;],<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://echarts.apache.org/zh/option.html#xAxis.axisLabel.interval">https://echarts.apache.org/zh/option.html#xAxis.axisLabel.interval</a></p><p><a href="https://my.oschina.net/u/4307631/blog/4012684">https://my.oschina.net/u/4307631/blog/4012684</a></p>]]></content>
    
    
    <categories>
      
      <category>ECharts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈 OTP</title>
    <link href="/2023/04/18/OTP/"/>
    <url>/2023/04/18/OTP/</url>
    
    <content type="html"><![CDATA[<h2 id="OTP-定义"><a href="#OTP-定义" class="headerlink" title="OTP 定义"></a>OTP 定义</h2><p><a href="https://en.wikipedia.org/wiki/Programmable_ROM">OTP</a>（One Time Programmable）是一种非易失性存储器（<a href="https://en.wikipedia.org/wiki/Non-volatile_memory">NVM</a>），有两种不同的实现方式：基于熔丝（<a href="https://en.wikipedia.org/wiki/EFuse">eFuse</a>）实现方式和基于反熔丝（<a href="https://en.wikipedia.org/wiki/Antifuse">AntiFuse</a>）实现方式，两种方式均可以实现一次编程后无法修改数据的目的。</p><p>与 EEPROM 和 Flash Memory 等多次可编程存储器（MTP）相比，OTP 存储器优势在于面积更小，且无需额外的晶圆加工步骤。同时，随着各种安全芯片、安全 SOC 设计的提出，OTP 中能够储存公私钥、加解密等私密数据，一旦经过编程或熔断，内容将无法更改，断电后内容将保留，且支持在制造后进行编程。</p><h2 id="eFuse-和-AntiFuse-区别和联系"><a href="#eFuse-和-AntiFuse-区别和联系" class="headerlink" title="eFuse 和 AntiFuse 区别和联系"></a>eFuse 和 AntiFuse 区别和联系</h2><p>eFuse 和 AntiFuse 存在差异，主要为：编程机制、安全性和功耗等方面。</p><table><thead><tr><th></th><th align="left">Efuse</th><th align="left">AntiFuse</th></tr></thead><tbody><tr><td>熔丝构成</td><td align="left">多晶硅栅极&#x2F;金属栅</td><td align="left">两层金属电极和金属电极间的反熔丝介质层构成</td></tr><tr><td>编程原理</td><td align="left">I&#x2F;O电压施加高密度电流，Efuse<br/>中的低电阻金属由于高密度电流通过<br/>窄金属或多晶硅而被电迁移熔断</td><td align="left">薄栅氧施加高电压，使栅极氧化物击穿</td></tr><tr><td>读取特点</td><td align="left">可读次数较少</td><td align="left">可读次数较多</td></tr><tr><td>阻值变化</td><td align="left">阻值变大</td><td align="left">阻值变小</td></tr><tr><td>安全性</td><td align="left">易被破解，安全性较差，可靠性相对较低</td><td align="left">安全性较高，可靠性较高</td></tr><tr><td>功耗</td><td align="left">功耗较高</td><td align="left">功耗较低</td></tr><tr><td>初始值</td><td align="left">0</td><td align="left">1</td></tr><tr><td></td><td align="left"></td><td align="left"></td></tr></tbody></table><h3 id="编程机制"><a href="#编程机制" class="headerlink" title="编程机制"></a>编程机制</h3><ul><li><p>eFuse</p><p>  eFuse 通过使用 I&#x2F;O 电压以高密度电流流过电熔断金属条或多晶硅类进行编程。当高密度电流流过狭窄的金属或多晶硅时，eFuse 中的低电阻金属因电迁移而熔断。</p><p>  <img src="/../image/%E5%B7%B2%E7%BC%96%E7%A8%8B%E7%9A%84%E5%A4%9A%E6%99%B6%E7%A1%85%20eFuse.png" alt="已编程的多晶硅 eFuse，资料来源：MA-Tek"></p><p>  在烧写过程中，eFuse 两端宽度较大的区域比 eFuse 中间宽度较窄的区域散热效果更好，因此，eFuse 的熔断部分始终位于 eFuse 中间的窄宽度区域。此外，要对一个位（Bit）进行编程需要一对 eFuse 布局，其中一个用于编程，另一个用于差分感应放大器的参考电阻器。同样，eFuse 只能编程一次 “1”，如果编程后 eFuse 无法读取 “1”，则编程失败，这意味着良率损失。</p></li><li><p>AntiFuse</p><p>  AntiFuse 通过雪崩击穿晶体管的栅极和源极电短路进行编程。</p></li></ul><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><ul><li><p>eFuse</p><p>  传统的多晶硅栅极 CMOS 逻辑工艺中，多晶 eFuse 非常流行（如图 1 所示），且 EM 发生在硅化物层。为降低 MOSFET 漏电而开发的新一代高<br>  K 金属栅极（HKMG）CMOS 逻辑工艺中，没有多晶硅层用作 eFuse。因此，英特尔生产的一种不同类型的 eFuse 被实现为金属 1 迹线（如图 2 所示）。</p><p>  <img src="/../image/%E8%8B%B1%E7%89%B9%E5%B0%94%E7%94%9F%E4%BA%A7%E7%9A%84%20Westmere/Clarkdale%20%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A8%8B%20eFuse.png" alt="英特尔生产的 Westmere/Clarkdale 处理器中的编程 eFuse。资料来源：[Intel Westmere Clarkdale 32nm 处理器中使用的 eFUSE 结构的自定义分析](https://www.techinsights.com/reports-and-subscriptions/open-market-reports/Report-Profile/?ReportKey=6907)，TechInsights"></p><p>  在图 2 中，金属 1 形成了四对 eFuse，有两个熔断的 eFuse 和六个完好无损的 eFuse，以及与底层驱动晶体管的互连。值得注意的是，eFuse 的熔断部分形状不规则很容易看到。</p><p>  <img src="/../image/TSMC%20eFuse%2020%20nm%20%E5%B9%B3%E9%9D%A2%20HKMG%20%E5%B7%A5%E8%89%BA%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A8%8B%20eFuse.png" alt="TSMC eFuse 20 nm 平面 HKMG 工艺中的编程 eFuse。资料来源：Qualcomm Gobi MDM9235 调制解调器 20 nm HKMG 逻辑详细结构分析，TechInsights。"></p><p>  如图 3 所示，金属 2 形成了四对 eFuse，有两个熔断的 eFuse。</p><p>  <img src="/../image/%E5%B7%B2%E7%BC%96%E7%A8%8B%E7%9A%84%20TSMC%20eFuse%20%E7%9A%84%E6%94%BE%E5%A4%A7%E5%9B%BE.png" alt="已编程的 TSMC eFuse 的放大图。资料来源：Qualcomm Gobi MDM9235 调制解调器 20 nm HKMG 逻辑详细结构分析，TechInsights。"></p><p>  如图 4 所示，显示了两个熔断的 eFuse。</p><p>  从上述图中可以看出，熔断（或编程后）的 eFuse 很容易被检测到。</p></li><li><p>AntiFuse</p><p>  <img src="/../image/eFuse.png" alt="反熔丝结构图"></p><p>  <img src="/../image/%E5%B7%B2%E7%BC%96%E7%A8%8B%E7%9A%84%E5%8F%8D%E7%86%94%E4%B8%9D.png" alt="已编程的反熔丝。资料来源：http://archive.eettaiwan.com/www.eettaiwan.com/emag/1302_15_DC.html，Kilopass。"></p><p>  如图 5 和 图 6 所示，已编程的反熔丝，其横截面或俯视图中没有熔断部分，电压对比 FIB 也没有热点，这能够保证未经授权的用户很难获得存储在反熔丝存储器中的数据内容。</p></li></ul><h3 id="功耗"><a href="#功耗" class="headerlink" title="功耗"></a>功耗</h3><ul><li><p>eFuse</p><p>  未编程的 eFuse 的典型电阻值约为 50 至 100 欧姆，而已编程的 eFuse 的典型电阻值约为 10K 欧姆 至 100K 欧姆。eFuse 中存储的 “0” 越多，消耗的电量就越多。此外，eFuse 的待机功率或泄漏比反熔丝高得多。</p></li><li><p>AntiFuse</p><p>  反熔丝在未编程状态下使用的功率更少，且反熔丝的电阻在未编程状态下更高。未编程位（Bit）的默认值为“0”，因此只需对为“1”的位进行编程。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>采用 AntiFuse 实现方式的 OTP 存储器具有更好的编程良率、更低的未编程位功耗以及总体上更出色的安全性。因此，具有 AntiFuse 的 OTP 存储器比具有 eFuse 的 OTP 存储器更适合移动支付、物联网 (IoT) 和其他应用。</p><h2 id="OTP-基本-Feature"><a href="#OTP-基本-Feature" class="headerlink" title="OTP 基本 Feature"></a>OTP 基本 Feature</h2><h3 id="读（Read）"><a href="#读（Read）" class="headerlink" title="读（Read）"></a>读（Read）</h3><p>支持重复读取 OTP Memory 内容。</p><h3 id="写（Program）"><a href="#写（Program）" class="headerlink" title="写（Program）"></a>写（Program）</h3><p>若对 OTP Memory 进行烧写，不支持对烧写后的位（Bit）再次烧写。支持一次烧写 1 Byte（8 Bit）数据。</p><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>OTP Memory 可拓展支持 Lock 机制。</p><h3 id="写保护机制"><a href="#写保护机制" class="headerlink" title="写保护机制"></a>写保护机制</h3><p>Mask 和 Program 数据位一一对应。写完后将数据读出来，若两者一致，说明数据成功写入，若两者不一致，找到哪一个比特位写入失败，将其赋值给 Mask。Mask 与 Program 数据进行与运算，再对写失败的位（Bit）进行写入。</p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li>OTP（One Time Programmable）：一次性可编程存储器</li><li>FTP（Few-Time Programmable）：有限次数的可编程储存器</li><li>MTP（Multi Time Programmable）：多次可编程存储器</li><li>eFuse（electronic fuse）：电子保险丝</li><li>NVM（Non-volatile memory）：非易失性存储器</li><li>EM (electro-migration)：电迁移</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://semiengineering.com/knowledge_centers/memory/one-time-programmable-memory/">https://semiengineering.com/knowledge_centers/memory/one-time-programmable-memory/</a></p><p><a href="https://zhuanlan.zhihu.com/p/354196694">https://zhuanlan.zhihu.com/p/354196694</a></p><p><a href="https://semiengineering.com/the-benefits-of-antifuse-otp/">https://semiengineering.com/the-benefits-of-antifuse-otp/</a></p><p><a href="https://zhuanlan.zhihu.com/p/354196694">https://zhuanlan.zhihu.com/p/354196694</a></p><p><a href="https://blog.csdn.net/impossible1224/article/details/122412789">https://blog.csdn.net/impossible1224/article/details/122412789</a></p>]]></content>
    
    
    <categories>
      
      <category>OTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS 字符串</title>
    <link href="/2023/04/18/JS%20%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/04/18/JS%20%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>文本数据被以字符串形式存储，单个字符没有单独的类型。字符串的内部格式始终是 UTF-16，不依赖于页面编码。</p><h2 id="引号（Quotes）"><a href="#引号（Quotes）" class="headerlink" title="引号（Quotes）"></a>引号（Quotes）</h2><p>字符串可以包含在单引号、双引号或反引号中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> single = <span class="hljs-string">&#x27;single-quoted&#x27;</span><br><span class="hljs-keyword">let</span> double = <span class="hljs-string">&quot;double-quoted&quot;</span><br><br><span class="hljs-keyword">let</span> backticks = <span class="hljs-string">`backticks`</span><br></code></pre></td></tr></table></figure><p>单引号和双引号基本相同，但反引号允许通过 <code>$&#123;...&#125;</code> 将任何表达式嵌入到字符串中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">`1 + 2 = <span class="hljs-subst">$&#123;sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)&#125;</span>`</span>);  <span class="hljs-comment">// 1 + 2 = 3</span><br></code></pre></td></tr></table></figure><p>使用反引号的另一个优点：允许字符串跨行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> guestList = <span class="hljs-string">`Guests:</span><br><span class="hljs-string">    * A</span><br><span class="hljs-string">    * B</span><br><span class="hljs-string">    * C</span><br><span class="hljs-string">`</span>;<br><span class="hljs-title function_">alert</span>(guestList);   <span class="hljs-comment">// 客人清单，多行</span><br></code></pre></td></tr></table></figure><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>上述换行中，也可通过使用“换行符 <code>\n</code>”支持单引号和双引号来创建跨行字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> guestList = <span class="hljs-string">&quot;Guests:\n * A\n * B\n * C&quot;</span>;<br><span class="hljs-title function_">alert</span>(guestList);   <span class="hljs-comment">// 客人清单，多行</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str1 = <span class="hljs-string">&quot;Hello\nWorld&quot;</span>;  <span class="hljs-comment">// 使用“换行符”创建的两行字符串</span><br><br><span class="hljs-comment">// 使用反引号和普通的换行创建的两行字符串</span><br><span class="hljs-keyword">let</span> str2 = <span class="hljs-string">`Hello           </span><br><span class="hljs-string">World`</span>;<br><br><span class="hljs-title function_">alert</span>(str1 == str2); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>不常见“特殊”字符表。</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>\n</code></td><td>换行</td></tr><tr><td><code>\r</code></td><td>在非 Windows OS 上，等同于 <code>\n</code></td></tr><tr><td><code>\&#39;</code>, <code>\&quot;</code></td><td>引号</td></tr><tr><td><code>\\</code></td><td>反斜线</td></tr><tr><td><code>\t</code></td><td>制表符</td></tr><tr><td><code>\xXX</code></td><td>具有给定十六进制 Unicode <code>xx</code> 的 Unicode 字符，例如：<code>\x7A</code> 和 <code>z</code> 相同</td></tr><tr><td><code>\uXXXX</code></td><td>以 UTF-16 编码的十六进制代码 <code>XXXX</code> 的 Unicode 字符，例如 <code>\u00A9</code> —— 是版权符号 © 的 Unicode。它必须正好是 4 个十六进制数字</td></tr><tr><td><code>\u&#123;X...XXXXXX&#125;</code>（1到6个十六进制字符）</td><td>具有给定 UTF-32 编码的 Unicode 符号。一些罕见的字符用两个 Unicode 符号编码，占用 4 个字节</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>所有特殊符号都以反斜杠字符 <code>\</code> 开始。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;\u00A9&quot;</span>);        <span class="hljs-comment">// ©</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;\u&#123;20331&#125;&quot;</span>);     <span class="hljs-comment">// 佫，罕见的中国象形文字（长 Unicode）</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;\u&#123;1F60D&#125;&quot;</span> );   <span class="hljs-comment">// 😍，笑脸符号（另一个长 Unicode）</span><br></code></pre></td></tr></table></figure><p>如果想要在字符串中插入一个引号，用来表示引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;I\&#x27;m George!&#x27;</span>);  <span class="hljs-comment">// I&#x27;m George!</span><br></code></pre></td></tr></table></figure><p>上面单引号 <code>&#39;&#39;</code> 示例中必须要在内部引号前加上反斜杠 <code>\&#39;</code>，否则将表示字符串结束。</p><p>还可改用双引号或反引号来实现相同效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">`I&#x27;m the George!`</span> ); <span class="hljs-comment">// I&#x27;m the George!</span><br></code></pre></td></tr></table></figure><p>如果要在字符串中显示一个实际的反斜杠 <code>\</code>，只需要书写两次 <code>\\</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">`The Burberry: \\`</span> ); <span class="hljs-comment">// The Burberry: \</span><br></code></pre></td></tr></table></figure><h2 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h2><p><code>length</code> 表示字符串长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">` My\n`</span>.<span class="hljs-property">length</span>);  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>注：<code>\n</code> 是一个单独的“特殊”字符，长度确实是 3。</p><blockquote><p><code>length</code> 是一个属性。</p><p><code>str.length</code> 是一个数字属性，而不是函数，后面不需要添加括号。</p></blockquote><h2 id="访问字符"><a href="#访问字符" class="headerlink" title="访问字符"></a>访问字符</h2><p>若要获取 <code>pos</code> 位置的一个字符，可以使用方括号 <code>[pos]</code> 或者调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/charAt">str.charAt(pos)</a> 方法。第一个字符从零位置开始：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;<br><br><span class="hljs-comment">// 第一个字符</span><br><span class="hljs-title function_">alert</span>( str[<span class="hljs-number">0</span>] );        <span class="hljs-comment">// H</span><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>) ); <span class="hljs-comment">// H</span><br><br><span class="hljs-comment">// 最后一个字符</span><br><span class="hljs-title function_">alert</span>( str[str.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] );   <span class="hljs-comment">// o</span><br></code></pre></td></tr></table></figure><p><code>[]</code> 和 <code>charAt</code> 区别：</p><ul><li>方括号是获取字符的一种现代化方法；<code>charAt</code> 是历史原因才存在；</li><li>唯一区别在于，若没有找到字符，<code>[]</code> 返回 <code>undefined</code>，而 <code>charAt</code>返回一个空字符串。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">`Hello`</span>;<br><br><span class="hljs-title function_">alert</span>( str[<span class="hljs-number">1000</span>] );         <span class="hljs-comment">// undefined</span><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">1000</span>) );  <span class="hljs-comment">// &#x27;&#x27;（空字符串）</span><br></code></pre></td></tr></table></figure><p>同样，可以使用 <code>for...of</code> 遍历字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> <span class="hljs-string">&quot;Hello&quot;</span>) &#123;<br>    <span class="hljs-title function_">alert</span>(char);            <span class="hljs-comment">// H,e,l,l,o（char 变成&quot;H&quot;，然后是&quot;e&quot;...）</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串不可变"><a href="#字符串不可变" class="headerlink" title="字符串不可变"></a>字符串不可变</h2><p>在 JavaScript 中，字符串不可更改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hi&#x27;</span>;<br><br>str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;h&#x27;</span>;       <span class="hljs-comment">// error</span><br><span class="hljs-title function_">alert</span>( str[<span class="hljs-number">0</span>] );    <span class="hljs-comment">// 无法运行</span><br></code></pre></td></tr></table></figure><p>常见的解决方法是创建一个新的字符串，并将其分配给 <code>str</code> 而不是以前的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hi&#x27;</span>;<br><br>str = <span class="hljs-string">&#x27;h&#x27;</span> + str[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 替换字符串</span><br><span class="hljs-title function_">alert</span>( str );       <span class="hljs-comment">// hi</span><br></code></pre></td></tr></table></figure><h2 id="改变大小写"><a href="#改变大小写" class="headerlink" title="改变大小写"></a>改变大小写</h2><h3 id="toLowerCase-和-toUpperCase"><a href="#toLowerCase-和-toUpperCase" class="headerlink" title="toLowerCase() 和 toUpperCase()"></a>toLowerCase() 和 toUpperCase()</h3><p>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase">toLowerCase()</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase">toUpperCase()</a> 方法可以改变大小写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">&#x27;Interface&#x27;</span>.<span class="hljs-title function_">toUpperCase</span>() ); <span class="hljs-comment">// INTERFACE</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&#x27;Interface&#x27;</span>.<span class="hljs-title function_">toLowerCase</span>() ); <span class="hljs-comment">// interface</span><br></code></pre></td></tr></table></figure><p>也可使一个字符变成小写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">&#x27;Interface&#x27;</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">toLowerCase</span>() );  <span class="hljs-comment">// i</span><br></code></pre></td></tr></table></figure><h2 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h2><p>在字符串中查找子字符串的方法。</p><h3 id="str-indexOf"><a href="#str-indexOf" class="headerlink" title="str.indexOf"></a>str.indexOf</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf">str.indexOf(substr, pos)</a> 从给定位置 <code>pos</code> 开始，在 <code>str</code> 中查找 <code>substr</code>，若没有找到，则返回 <code>-1</code>，否则返回匹配成功的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Widget with id&#x27;</span>;<br><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;Widget&#x27;</span>) ); <span class="hljs-comment">// 0，因为 &#x27;Widget&#x27; 一开始就被找到</span><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;widget&#x27;</span>) ); <span class="hljs-comment">// -1，没有找到，检索是大小写敏感的</span><br><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;id&quot;</span>) );     <span class="hljs-comment">// 1，&quot;id&quot; 在位置 1 处（……idget 和 id）</span><br></code></pre></td></tr></table></figure><p>可选的第二个参数允许从一个给定的位置开始检索。例如，<code>id</code> 第一次出现的位置是 <code>1</code>，查询到下一个存在的位置时，从 2 开始检索。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Widget with id&#x27;</span>;<br><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-number">2</span>) ) <span class="hljs-comment">// 12</span><br></code></pre></td></tr></table></figure><p>若对所有存在的位置都感兴趣，可以在一个循环中使用 <code>indexOf</code>。每一次新的调用都发生在上一匹配位置之后。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;As sly as a fox, as strong as an ox&#x27;</span>;<br><span class="hljs-keyword">let</span> target = <span class="hljs-string">&#x27;as&#x27;</span>;  <span class="hljs-comment">// 这是我们要查找的目标</span><br><br><span class="hljs-keyword">let</span> pos = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">let</span> foundPos = str.<span class="hljs-title function_">indexOf</span>(target, pos);<br>    <span class="hljs-keyword">if</span>(foundPos == -<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-title function_">alert</span>( <span class="hljs-string">`Found at <span class="hljs-subst">$&#123;foundPos&#125;</span>`</span> );<br>    pos = foundPos + <span class="hljs-number">1</span>; <span class="hljs-comment">// 继续从下一位置查找</span><br>&#125;<br>---------- 算法简写 ---------<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;As sly as a fox, as strong as an ox&quot;</span>;<br><span class="hljs-keyword">let</span> target = <span class="hljs-string">&quot;as&quot;</span>;<br><br><span class="hljs-keyword">let</span> pos = -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>((pos = str.<span class="hljs-title function_">indexOf</span>(target, pos + <span class="hljs-number">1</span>)) != -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-title function_">alert</span>( pos );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="str-lastIndexOf-substr-pos"><a href="#str-lastIndexOf-substr-pos" class="headerlink" title="str.lastIndexOf(substr, pos)"></a>str.lastIndexOf(substr, pos)</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf">str.lastIndexOf(substr, position)</a>，它从字符串的末尾开始搜索到开头，将会以相反的顺序列出这些事件。</p><h2 id="按位（bitwise）NOT技巧"><a href="#按位（bitwise）NOT技巧" class="headerlink" title="按位（bitwise）NOT技巧"></a>按位（bitwise）NOT技巧</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_NOT">bitwise NOT</a> <code>~</code> 运算符，能将数字转化为 32-bit 整数，（若存在小数部分，则删除小数部分），然后对其二进制表示形式中的所有位取反。</p><p>对于 32-bit 整数，<code>~n</code> 等于 <code>-(n+1)</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( ~<span class="hljs-number">2</span> );    <span class="hljs-comment">// -3，和 -(2+1) 相同</span><br><span class="hljs-title function_">alert</span>( ~<span class="hljs-number">1</span> );    <span class="hljs-comment">// -2，和 -(1+1) 相同</span><br><span class="hljs-title function_">alert</span>( ~<span class="hljs-number">0</span> );    <span class="hljs-comment">// -1，和 -(0+1) 相同</span><br><span class="hljs-title function_">alert</span>( ~-<span class="hljs-number">1</span> );   <span class="hljs-comment">// 0，和 -(-1+1) 相同</span><br></code></pre></td></tr></table></figure><p>只有当 <code>n == -1</code> 时，<code>~n</code> 才为零。</p><h2 id="includes-startWith-endsWith"><a href="#includes-startWith-endsWith" class="headerlink" title="includes, startWith, endsWith"></a>includes, startWith, endsWith</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/includes">str.includes(substr, pos)</a>方法根据 <code>str</code> 中是否包含 <code>substr</code> 来返回 <code>true/false</code>。</p><p>如果需要检测匹配，则不需要第二个位置参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Widget with id&quot;</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;Widget&quot;</span>) );   <span class="hljs-comment">// true</span><br><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Hello&quot;</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;Bye&quot;</span>) );               <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><code>str.includes</code> 的第二个可选参数是开始搜索的起始位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Widget&quot;</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;id&quot;</span>) );       <span class="hljs-comment">// true</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Widget&quot;</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">3</span>) );    <span class="hljs-comment">// false, 从位置 3 开始没有 &quot;id&quot;</span><br></code></pre></td></tr></table></figure><p>方法 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith">str.startsWith</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith">str.endsWith</a> 的功能与其名称所表示的意思相同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Widget&quot;</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;Wid&quot;</span>) );    <span class="hljs-comment">// true，&quot;Widget&quot; 以 &quot;Wid&quot; 开始</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Widget&quot;</span>.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&quot;get&quot;</span>) );      <span class="hljs-comment">// true，&quot;Widget&quot; 以 &quot;get&quot; 结束</span><br></code></pre></td></tr></table></figure><h2 id="获取子字符串"><a href="#获取子字符串" class="headerlink" title="获取子字符串"></a>获取子字符串</h2><p>JavaScript 中有三种获取字符串的方法：<code>substring</code>、<code>substr</code>、<code>slice</code>。</p><h3 id="str-slice-start-end"><a href="#str-slice-start-end" class="headerlink" title="str.slice(start [, end])"></a>str.slice(start [, end])</h3><p><code>str.slice(start [, end])</code> 返回字符串从 <code>start</code> 到（但不包括） end 的部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;stringify&quot;</span>;<br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>) );   <span class="hljs-comment">// &#x27;strin&#x27;，从 0 到 5 的子字符串（不包括 5）</span><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) );   <span class="hljs-comment">// &#x27;s&#x27;，从 0 到 1，但不包括 1，所以只有在 0 处的字符</span><br></code></pre></td></tr></table></figure><p>若没有第二个参数，slice 会一直运行到字符串末尾。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;stringify&quot;</span>;<br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>) );      <span class="hljs-comment">// 从第二个位置直到结束</span><br></code></pre></td></tr></table></figure><p><code>start/end</code> 也有可能是负值，意思为起始位置从字符串结尾计算。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;stringify&quot;</span>;<br><br><span class="hljs-comment">// 从右边的第四个位置开始，在右边的第一个位置结束</span><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">slice</span>(-<span class="hljs-number">4</span>, -<span class="hljs-number">1</span>) ); <span class="hljs-comment">// &#x27;gif&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="str-substring-start-end"><a href="#str-substring-start-end" class="headerlink" title="str.substring(start [, end])"></a>str.substring(start [, end])</h3><p><code>str.substring(start [, end])</code> 方法与 <code>slice</code> 几乎相同，但其允许 <code>start</code> 大于 <code>end</code>，将返回字符串从 <code>start</code> 到（但不包括）<code>end</code> 的部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;stringify&quot;</span>;<br><br><span class="hljs-comment">// 这些对于 substring 是相同的</span><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>) );   <span class="hljs-comment">// &quot;ring&quot;</span><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">6</span>, <span class="hljs-number">2</span>) );   <span class="hljs-comment">// &quot;ring&quot;</span><br><br><span class="hljs-comment">// ……但对 slice 是不同的：</span><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>) );       <span class="hljs-comment">// &quot;ring&quot;（一样）</span><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">6</span>, <span class="hljs-number">2</span>) );       <span class="hljs-comment">// &quot;&quot;（空字符串）</span><br></code></pre></td></tr></table></figure><h3 id="str-substr-start-length"><a href="#str-substr-start-length" class="headerlink" title="str.substr(start [, length])"></a>str.substr(start [, length])</h3><p><code>str.substr(start [, length])</code> 方法允许指定 length 而不是结束位置，返回字符串从 <code>start</code> 开始的给定 <code>length</code> 的部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;stringify&quot;</span>;<br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">substr</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>) );  <span class="hljs-comment">// &#x27;ring&#x27;，从位置 2 开始，获取 4 个字符</span><br></code></pre></td></tr></table></figure><p>若第一个参数为负数，则从结尾算起。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;stringify&quot;</span>;<br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">substr</span>(-<span class="hljs-number">4</span>, <span class="hljs-number">2</span>) ); <span class="hljs-comment">// &#x27;gi&#x27;，从第 4 位获取 2 个字符</span><br></code></pre></td></tr></table></figure><h2 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h2><p>字符串按照字母顺序逐字比较，但总存在一些问题。</p><ol><li><p>小写字母总大于大写字母。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">&#x27;a&#x27;</span> &gt; <span class="hljs-string">&#x27;Z&#x27;</span> ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p>带变音符号的字母存在“乱序”的情况。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">&#x27;Österreich&#x27;</span> &gt; <span class="hljs-string">&#x27;Zealand&#x27;</span> ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ol><p>上述两种情况原因为，所有的字符串都使用 UTF-16 编码。即：每个字符都有对应的数字代码。有特殊的方法可以获取代码表示的字符，以及字符对应的代码。</p><h3 id="str-codePointAt-pos"><a href="#str-codePointAt-pos" class="headerlink" title="str.codePointAt(pos)"></a>str.codePointAt(pos)</h3><p><code>str.codePointAt(pos)</code> 方法返回在 <code>pos</code> 位置的字符代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 不同的字母有不同的代码</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;z&quot;</span>.<span class="hljs-title function_">codePointAt</span>(<span class="hljs-number">0</span>) );    <span class="hljs-comment">// 122</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Z&quot;</span>.<span class="hljs-title function_">codePointAt</span>(<span class="hljs-number">0</span>) );    <span class="hljs-comment">// 90</span><br></code></pre></td></tr></table></figure><h3 id="String-fromCodePoint-code"><a href="#String-fromCodePoint-code" class="headerlink" title="String.fromCodePoint(code)"></a>String.fromCodePoint(code)</h3><p><code>String.fromCodePoint(code)</code> 方法通过数字 <code>code</code> 创建字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCodePoint</span>(<span class="hljs-number">90</span>) );  <span class="hljs-comment">// Z</span><br></code></pre></td></tr></table></figure><p>还可以用 <code>\u</code> 后跟十六进制代码，通过这些代码添加 Unicode 字符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 在十六进制系统中 90 为 5a</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&#x27;\u005a&#x27;</span> );  <span class="hljs-comment">// Z</span><br></code></pre></td></tr></table></figure><p>代码为 65..220 的字符（拉丁字母和一些额外的字符），方法是创建一个字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#x27;</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">65</span>; i &lt;= <span class="hljs-number">220</span>; i++) &#123;<br>  str += <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCodePoint</span>(i);<br>&#125;<br><span class="hljs-title function_">alert</span>( str );<br><span class="hljs-comment">// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz&#123;|&#125;~</span><br><span class="hljs-comment">// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ</span><br></code></pre></td></tr></table></figure><p>字符通过数字代码进行比较。越大的代码意味着字符越大。<code>a</code>（97）的代码大于 <code>Z</code>（90）的代码。</p><ul><li>所有小写字母追随在大写字母之后，因为它们的代码更大；</li><li>一些像 <code>Ö</code> 的字母与主要字母表不同。这里，它的代码比任何从 <code>a</code> 到 <code>z</code> 的代码都要大。</li></ul><h2 id="正确的比较"><a href="#正确的比较" class="headerlink" title="正确的比较"></a>正确的比较</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare">String.prototype.localeCompare()</a> 方法会根据语言规则返回一个整数，这个整数能指示字符串 <code>str</code> 在排序顺序中排在字符串 <code>str2</code> 前面、后面、还是相同。</p><ul><li>如果 <code>str</code> 排在 <code>str2</code> 前面，则返回负数；</li><li>如果 <code>str</code> 排在 <code>str2</code> 后面，则返回正数；</li><li>如果他们在相同位置，则返回 <code>0</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">&#x27;Österreich&#x27;</span>.<span class="hljs-title function_">localeCompare</span>(<span class="hljs-string">&#x27;Zealand&#x27;</span>) ); <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>有 3 种类型的引号。反引号允许字符串跨越多行并可以使用 <code>$&#123;…&#125;</code> 在字符串中嵌入表达式；</li><li>JavaScript 中的字符串使用的是 UTF-16 编码；</li><li>我们可以使用像 <code>\n</code> 这样的特殊字符或通过使用 <code>\u...</code> 来操作它们的 Unicode 进行字符插入；</li><li>获取字符时，使用 <code>[]</code>；</li><li>获取子字符串，使用 <code>slice</code> 或 <code>substring</code>；</li><li>字符串的大&#x2F;小写转换，使用：<code>toLowerCase/toUpperCase</code>；</li><li>查找子字符串时，使用 <code>indexOf</code> 或 <code>includes/startsWith/endsWith</code> 进行简单检查；</li><li>根据语言比较字符串时使用 <code>localeCompare</code>，否则将按字符代码进行比较。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.javascript.info/string">https://zh.javascript.info/string</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字类型</title>
    <link href="/2023/04/17/%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/04/17/%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>JavaScript 中 数字（number）有两种类型：</p><ol><li>常规类型，常规数字以 64 位的格式存储，也被称为“双精度浮点数”；</li><li>特殊类型，<code>BigInt</code> 用于表示任意长度的整数。</li></ol><h2 id="编写数字的更多方法"><a href="#编写数字的更多方法" class="headerlink" title="编写数字的更多方法"></a>编写数字的更多方法</h2><p>例如，10 亿的常规表示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> billion = <span class="hljs-number">1000000000</span>;<br></code></pre></td></tr></table></figure><p>同样，也可使用下划线 <code>_</code> 作为分隔符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> billion = <span class="hljs-number">1_000_000_000</span>;<br></code></pre></td></tr></table></figure><p>下划线扮演“语法糖”的角色，使得数字具有更强的可读性。</p><p>同样，也可通过数字后面附加字母 <code>e</code> 并指定零的个数来缩短数字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> billion = <span class="hljs-number">1e9</span>;  <span class="hljs-comment">// 1o亿，字面意思：数字 1 后面跟 9 个 0</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-number">7.3e9</span>);       <span class="hljs-comment">// 73亿，（与 7300000000 和 7_300_000_000 相同）</span><br>-----------------------<br><span class="hljs-number">1e3</span> === <span class="hljs-number">1</span> * <span class="hljs-number">1000</span>;   <span class="hljs-comment">// e3 表示 *1000</span><br><span class="hljs-number">1.23e6</span> === <span class="hljs-number">1.23</span> * <span class="hljs-number">1000000</span>;  <span class="hljs-comment">// e6 表示 *1000000</span><br>-----------------------<br><span class="hljs-keyword">let</span> mcs = <span class="hljs-number">0.000001</span>;<br><span class="hljs-keyword">let</span> mcs = <span class="hljs-number">1e-6</span>;     <span class="hljs-comment">// 1 的左边有 6 个 0</span><br>-----------------------<br><span class="hljs-number">1e-3</span> === <span class="hljs-number">1</span> / <span class="hljs-number">1000</span>;  <span class="hljs-comment">// 0.001</span><br><span class="hljs-number">1.23e-6</span> === <span class="hljs-number">1.23</span> / <span class="hljs-number">1000000</span>; <span class="hljs-comment">// 0.00000123</span><br><span class="hljs-number">1234e-2</span> === <span class="hljs-number">1234</span> / <span class="hljs-number">100</span>;     <span class="hljs-comment">// 12.34，小数点移动两次</span><br></code></pre></td></tr></table></figure><h2 id="十六进制、二进制和八进制"><a href="#十六进制、二进制和八进制" class="headerlink" title="十六进制、二进制和八进制"></a>十六进制、二进制和八进制</h2><ul><li>十六进制（0x）：常用于表示颜色、编码字符等；</li><li>八进制（0o）</li><li>二进制（0b）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-number">0xff</span> );      <span class="hljs-comment">// 255</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-number">0xFF</span> );      <span class="hljs-comment">// 255（一样，大小写没影响）</span><br>-----------------------<br><span class="hljs-keyword">let</span> a = <span class="hljs-number">0b11111111</span>; <span class="hljs-comment">// 二进制形式的 255</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">0o377</span>;      <span class="hljs-comment">// 八进制形式的 255</span><br><br><span class="hljs-title function_">alert</span>( a == b );    <span class="hljs-comment">// true，两边是相同的数字，都是 255</span><br></code></pre></td></tr></table></figure><h3 id="toString-base"><a href="#toString-base" class="headerlink" title="toString(base)"></a>toString(base)</h3><p>字符串方法 <code>num.toString(base)</code> 返回在给定 <code>base</code> 进制数字系统中 <code>num</code> 的字符串表示形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">255</span>;<br><span class="hljs-title function_">alert</span>( num.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>) );  <span class="hljs-comment">// ff</span><br><span class="hljs-title function_">alert</span>( num.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>) );   <span class="hljs-comment">// 11111111</span><br></code></pre></td></tr></table></figure><p>base 的范围可以从 2 到 36，默认情况为 10.</p><ul><li>base&#x3D;16，用于十六进制颜色，字符编码等，数字可以是 0..9 或 A..F。</li><li>base&#x3D;2，主要用于调试按位操作，数字可以是 0 或 1。</li><li>base&#x3D;36，是最大进制，数字可以是 0..9 或 A..Z。所有拉丁字母都被用于了表示数字。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-number">123456.</span>.<span class="hljs-title function_">toString</span>(<span class="hljs-number">36</span>) ); <span class="hljs-comment">// 2n9c</span><br></code></pre></td></tr></table></figure><h2 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h2><p>舍入（rounding）是使用数字时最常用的操作之一。</p><h3 id="Math-floor"><a href="#Math-floor" class="headerlink" title="Math.floor"></a>Math.floor</h3><p>向下舍入：<code>3.1</code> 变成 <code>3</code>，<code>-1.1</code> 变成 <code>-2</code>。</p><h3 id="Math-ceil"><a href="#Math-ceil" class="headerlink" title="Math.ceil"></a>Math.ceil</h3><p>向上舍入：<code>3.1</code> 变成 <code>4</code>，<code>-1.1</code> 变成 <code>-1</code>。</p><h3 id="Math-round"><a href="#Math-round" class="headerlink" title="Math.round"></a>Math.round</h3><p>向最近的整数舍入：<code>3.1</code> 变成 <code>3</code>，<code>3.6</code> 变成 <code>4</code>，中间值 <code>3.5</code> 变成 <code>4</code>。</p><h3 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc"></a>Math.trunc</h3><p>移除小数点后的所有内容而没有舍入：<code>3.1</code> 变成 <code>3</code>，<code>-1.1</code> 变成 <code>-1</code>。</p><h3 id="parseInt-和-parseFloat"><a href="#parseInt-和-parseFloat" class="headerlink" title="parseInt 和 parseFloat"></a>parseInt 和 parseFloat</h3><p><code>parseInt</code>、<code>parseFloat</code>： 从 <code>100px</code>、<code>19€</code> 带有单位的值中提取出一个数值，可以从字符串中“读取”数字，直到无法读取为止，若发生 error，则返回收集到的数字。</p><ul><li><code>parseInt</code>：返回一个整数；</li><li><code>parseFloat</code>：返回一个浮点数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;100px&#x27;</span>) );     <span class="hljs-comment">// 100</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;12.5em&#x27;</span>) );  <span class="hljs-comment">// 12.5</span><br><br><span class="hljs-title function_">alert</span>( <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;12.3&#x27;</span>) );      <span class="hljs-comment">// 12，只有整数部分被返回了</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;12.3.4&#x27;</span>) );  <span class="hljs-comment">// 12.3，在第二个点出停止了读取</span><br></code></pre></td></tr></table></figure><p>在某种情况下，当没有数据可读时，<code>parseInt/parseFloat</code> 会返回 <code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;a123&#x27;</span>) );      <span class="hljs-comment">// NaN，第一个符号停止了读取</span><br></code></pre></td></tr></table></figure><p><strong>parseInt(str, radix) 的第二个参数</strong></p><p><code>parseInt()</code> 函数具有可选的第二个参数。它指定了数字系统的基数，因此 <code>parseInt</code> 还可以解析十六进制数字、二进制数字等的字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;0xff&#x27;</span>, <span class="hljs-number">16</span>) );  <span class="hljs-comment">// 255</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;ff&#x27;</span>, <span class="hljs-number">16</span>) );    <span class="hljs-comment">// 255，没有 0x 仍然有效</span><br><br><span class="hljs-title function_">alert</span>( <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;2n9c&#x27;</span>, <span class="hljs-number">36</span>) );  <span class="hljs-comment">// 123456</span><br></code></pre></td></tr></table></figure><h2 id="其他数学函数"><a href="#其他数学函数" class="headerlink" title="其他数学函数"></a>其他数学函数</h2><p>JavaScript 有一个内建的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math">Math</a> 对象，它包含了一个小型的数学函数和常量库。</p><h3 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h3><p>返回一个从 0 到 1 的随机数（不包括 1）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() );     <span class="hljs-comment">// 0.1234567894322</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() );     <span class="hljs-comment">// 0.5435252343232</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() );     <span class="hljs-comment">// ... (任何随机数)</span><br></code></pre></td></tr></table></figure><h3 id="Math-max-a-b-c…-和-Math-min-a-b-c…"><a href="#Math-max-a-b-c…-和-Math-min-a-b-c…" class="headerlink" title="Math.max(a, b, c…) 和 Math.min(a, b, c…)"></a>Math.max(a, b, c…) 和 Math.min(a, b, c…)</h3><p>从任意数量的参数中返回最大值和最小值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, -<span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) ); <span class="hljs-comment">// 5</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) );            <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h3 id="Math-pow-n-power"><a href="#Math-pow-n-power" class="headerlink" title="Math.pow(n, power)"></a>Math.pow(n, power)</h3><p>返回 n 的给定（power）次幂。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>) );   <span class="hljs-comment">// 2 的 10 次幂 = 1024</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>带有很多零的数字</p><ul><li>将 “e” 和 0 的数量附加到数字后。就像：123e6 与 123 后面接 6 个 0 相同；</li><li>“e” 后面的负数将使数字除以 1 后面接着给定数量的零的数字。例如 123e-6 表示 0.000123（123 的百万分之一）。</li></ul><p>对于不同的数字系统：</p><ul><li>可以直接在十六进制（<code>0x</code>），八进制（<code>0o</code>）和二进制（<code>0b</code>）系统中写入数字；</li><li><code>parseInt(str, base)</code> 将字符串 <code>str</code> 解析为在给定的 base 数字系统中的整数，<code>2 ≤ base ≤ 36</code>；</li><li><code>num.toString(base)</code> 将数字转换为在给定的 base 数字系统中的字符串。</li></ul><p>小数：</p><ul><li>使用 <code>Math.floor</code>，<code>Math.ceil</code>，<code>Math.trunc</code>，<code>Math.round</code> 或 <code>num.toFixed(precision)</code> 进行舍入；</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.javascript.info/number">https://zh.javascript.info/number</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原始类型的方法</title>
    <link href="/2023/04/17/%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2023/04/17/%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="原始类型和对象区别"><a href="#原始类型和对象区别" class="headerlink" title="原始类型和对象区别"></a>原始类型和对象区别</h2><p>一个原始值：</p><ul><li>是原始类型中的一种值；</li><li>在 JavaScript 中有7中原始类型：<code>string</code>、<code>number</code>、<code>bigint</code>、<code>boolean</code>、<code>symbol</code>、<code>null</code> 和 <code>undefined</code>。</li></ul><p>一个对象：</p><ul><li>能够存储多个值作为属性；</li><li>可以使用大括号 <code>&#123;&#125;</code> 创建对象，例如：<code>&#123;name：&quot;John&quot;, age: 30&#125;</code>。函数也是对象。</li></ul><p>例如：将一个函数作为对象的属性存储到对象中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> john = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>    <span class="hljs-attr">syaHi</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>    &#125;<br>&#125;;<br><br>john.<span class="hljs-title function_">sayHi</span>();   <span class="hljs-comment">// Hello World!</span><br></code></pre></td></tr></table></figure><p>上述创建了一个包含 <code>sayHi</code> 方法的对象 <code>john</code>，但对象比原始类型“更重”，需要额外的资源来支持运作。</p><h2 id="当做对象的原始类型"><a href="#当做对象的原始类型" class="headerlink" title="当做对象的原始类型"></a>当做对象的原始类型</h2><p>为解决如下两个问题：</p><ol><li>想对诸如字符串或数字之类的原始类型执行操作；</li><li>原始类型必须尽可能的简单轻量。</li></ol><p>提出如下的解决方法：</p><ol><li>原始类型仍然是原始的，与预期相同，提供单个值；</li><li>JavaScript 允许访问字符串、数字、布尔值和 symbol 的方法和属性；</li><li>为使它们起作用，创建了提供额外功能的特殊“对象包装器”，使用后即被销毁。</li></ol><p>“对象包装器”对于每种原始类型都是不同的，其被称为 <code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Symbol</code> 和 <code>Bigint</code>。因此提供了不同的方法。</p><h3 id="str-toUpperCase"><a href="#str-toUpperCase" class="headerlink" title="str.toUpperCase()"></a>str.toUpperCase()</h3><p>字符串方法 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase">str.toUpperCase()</a> 返回一个大写化处理的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-title function_">alert</span>(str.<span class="hljs-title function_">toUpperCase</span>());   <span class="hljs-comment">// HELLO</span><br></code></pre></td></tr></table></figure><p><code>toUpperCase()</code> 中实际发生的情况：</p><ol><li>字符串 str 是一个原始值。在访问其属性时，会创建一个包含字符串字面量的特殊对象，并且具有可用的方法，如 <code>toUpperCase()</code>；</li><li>该方法运行并返回一个新的字符串（由 <code>alert</code> 显示）；</li><li>特殊对象被销毁后，只留下原始值 <code>str</code>。</li></ol><p>所以原始类型可以提供方法，但他们依然是轻量级。</p><h3 id="toFixed-n"><a href="#toFixed-n" class="headerlink" title="toFixed(n)"></a>toFixed(n)</h3><p>数量方法，如 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed">toFixed(n)</a> 将数字舍入到给定的精度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> n = <span class="hljs-number">1.23456</span>;<br><br><span class="hljs-title function_">alert</span>(n.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>));    <span class="hljs-comment">// 1.23</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>除 null 和 undefined 以外的原始类型都提供了许多有用的方法；</li><li>从形式上看，这些方法通过临时对象工作，但 JavaScript 引擎可以很好的调整，以在内部对齐进行优化，因此调用并不需要太高的成本。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.javascript.info/primitives-methods">https://zh.javascript.info/primitives-methods</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构造器和操作符“new”</title>
    <link href="/2023/04/17/%E6%9E%84%E9%80%A0%E5%99%A8/"/>
    <url>/2023/04/17/%E6%9E%84%E9%80%A0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数一般为常规函数，在构造时通常有以下两个约定：</p><ul><li>命名以答谢字母开始；</li><li>只能由 <code>new</code> 操作符来执行；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Jack&quot;</span>);<br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>);       <span class="hljs-comment">// Jack</span><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">isAdmin</span>);    <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>当一个函数被使用 <code>new</code> 操作符执行时，会执行如下步骤：</p><ul><li>一个新的空对象会被创建并分配给 <code>this</code>；</li><li>函数体执行，通常会修改 <code>this</code>，为其添加新的属性；</li><li>返回 <code>this</code> 的值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-comment">// this = &#123;&#125;; 隐式创建</span><br><br>    <span class="hljs-comment">// 添加属性到 this</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// return this； 隐式返回</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>new User(&quot;Jack&quot;)</code> 的结果与上面为同样的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">User</span> =  &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="构造器模式测试"><a href="#构造器模式测试" class="headerlink" title="构造器模式测试"></a>构造器模式测试</h2><p>在函数内部，可使用 <code>new.target</code> 属性来检查是否被 <code>new</code> 调用。对于常规调用，结果为 <code>undefined</code>，对于使用 <code>new</code> 的调用，则等于该函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span>  <span class="hljs-title function_">User</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>);<br>&#125;<br><br><span class="hljs-comment">// 不带 new</span><br><span class="hljs-title class_">User</span>();     <span class="hljs-comment">// undefined</span><br><br><span class="hljs-comment">// 带 new</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(); <span class="hljs-comment">// function User &#123;...&#125;</span><br></code></pre></td></tr></table></figure><p><code>new.target</code> 属性可被用在函数内部，来判断该函数是被通过 <code>new</code> 调用的“构造器模式”，还是没被通过 <code>new</code> 调用的“常规模式”。</p><p>同时，也可让 new 调用和常规调用做相同的工作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>) &#123;           <span class="hljs-comment">// 若没有通过 new 运行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(name);  <span class="hljs-comment">// 将会添加 new</span><br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-keyword">let</span> john = <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;John&quot;</span>);    <span class="hljs-comment">// 将调用重定向到新用户</span><br><span class="hljs-title function_">alert</span>(john.<span class="hljs-property">name</span>);           <span class="hljs-comment">// John</span><br></code></pre></td></tr></table></figure><h2 id="构造器的-return"><a href="#构造器的-return" class="headerlink" title="构造器的 return"></a>构造器的 return</h2><p>通常，构造器没有 return 语句，其任务是将所有必要的东西写入 this，并自动转化为结果。</p><p>但如果这有一个 return 语句，规则就简单：</p><ul><li>若 return 返回值是一个对象，则返回这个对虾干，而不是 this；</li><li>若 return 返回的是一个原始类型，则忽略；</li></ul><p>换句话说，带有对象的 return 返回该对象，在所有其他情况下返回 this。</p><p>例如，<code>return</code> 通过返回一个对象覆盖 <code>this</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">BigUser</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;John&quot;</span>;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;George&quot;</span>&#125;;    <span class="hljs-comment">// 返回这个对象</span><br>&#125;<br><br><span class="hljs-title function_">alert</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUser</span>().<span class="hljs-property">name</span>);      <span class="hljs-comment">// George，得到那个对象</span><br></code></pre></td></tr></table></figure><p>例如，有一个 return 为空的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SmallUser</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;John&quot;</span>;<br>    <span class="hljs-keyword">return</span>;                     <span class="hljs-comment">// 返回 this</span><br>&#125;<br><br><span class="hljs-title function_">alert</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SmallUser</span>().<span class="hljs-property">name</span>);    <span class="hljs-comment">// John</span><br></code></pre></td></tr></table></figure><h2 id="构造器中的方法"><a href="#构造器中的方法" class="headerlink" title="构造器中的方法"></a>构造器中的方法</h2><p>使用构造函数来创建对象会带来很大的灵活性。既可以将属性添加到 this 中，还可以添加方法。</p><p>例如，下面的 <code>new User(name)</code> 用给定的 <code>name</code> 和方法 <code>sayHi</code> 创建了一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;My name is:&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;John&quot;</span>);<br>john.<span class="hljs-title function_">sayHi</span>();   <span class="hljs-comment">// My name is: John</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>构造函数，简称构造器，就是常规函数；</li><li>构造函数只能使用 <code>new</code> 来调用，这样调用意味着在开始时创建了空的 <code>this</code>，并在最后返回填充了值得 <code>this</code>。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.javascript.info/constructor-new">https://zh.javascript.info/constructor-new</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对象方法</title>
    <link href="/2023/04/14/%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/"/>
    <url>/2023/04/14/%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="对象方法，“this”"><a href="#对象方法，“this”" class="headerlink" title="对象方法，“this”"></a>对象方法，“this”</h2><p>在 JavaScript 中，行为（action）由属性中的函数来表示。行为可以理解为各种动作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br>user.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello!&quot;</span>)<br>&#125;;<br><br>user.<span class="hljs-title function_">sayHi</span>();   <span class="hljs-comment">// Hello!</span><br></code></pre></td></tr></table></figure><p>使用函数表达式创建了一个函数，并将其指定给对象的 <code>user.sayHi</code> 属性，随后使用 <code>user.say</code> 调用，这种作为对象属性的函数被称为 <strong>方法</strong>。</p><p>也可以使用预先声明的函数作为方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><span class="hljs-comment">// 首先，声明函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 然后，将其作为一个方法添加</span><br>user.<span class="hljs-property">sayHi</span> = sayHi;<br>user.<span class="hljs-title function_">sayHi</span>();   <span class="hljs-comment">// Hello!</span><br></code></pre></td></tr></table></figure><blockquote><p>OOP（Object-oriented programming）：<a href="https://en.wikipedia.org/wiki/Object-oriented_programming">面向对象编程</a>，指的是用对象表示实体。</p></blockquote><h2 id="方法简写"><a href="#方法简写" class="headerlink" title="方法简写"></a>方法简写</h2><p>在对象字面量中，有一种更短的（声明）方法的语法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">user = &#123;<br>    <span class="hljs-attr">sayHi</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>    &#125;<br>&#125;;<br>-----------------------------------<br><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;   <span class="hljs-comment">// 与 &quot;sayHi: function()&#123;...&#125;&quot; 一样</span><br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="方法中的”this”"><a href="#方法中的”this”" class="headerlink" title="方法中的”this”"></a>方法中的”this”</h2><p>对象方法需要访问对象中存储的信息才能完成其工作。如 <code>user.sayHi()</code> 中的代码可能需要用到 <code>user</code> 的 name 属性。</p><p><strong>为访问该对象，方法中可使用 <code>this</code> 关键字。</strong><code>this</code> 的值就是在点之前的这个对象，即调用该方法的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br><br>    <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// this 指的是 “当前的对象”</span><br>        <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;；<br>user.<span class="hljs-title function_">sayHi</span>();   <span class="hljs-comment">// John</span><br>-----------------------------------<br><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br><br>    <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;user&quot; 替代 &quot;this&quot;</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="“this”不受限制"><a href="#“this”不受限制" class="headerlink" title="“this”不受限制"></a>“this”不受限制</h2><p><code>this</code> 可用于任何函数，即使它不是对象的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> ); <span class="hljs-comment">// 不会报错</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>this</code> 的值取决于代码上下文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><span class="hljs-keyword">let</span> admin = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Admin&quot;</span> &#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> );<br>&#125;<br><br><span class="hljs-comment">// 在两个对象中使用相同的函数</span><br>user.<span class="hljs-property">f</span> = sayHi;<br>admin.<span class="hljs-property">f</span> = sayHi;<br><br><span class="hljs-comment">// 这两个调用有不同的 this 值</span><br><span class="hljs-comment">// 函数内部的 &quot;this&quot; 是“点符号前面”的那个对象</span><br>user.<span class="hljs-title function_">f</span>();       <span class="hljs-comment">// John（this == user）</span><br>admin.<span class="hljs-title function_">f</span>();      <span class="hljs-comment">// Admin（this == admin）</span><br>admin[<span class="hljs-string">&#x27;f&#x27;</span>]();   <span class="hljs-comment">// Admin（使用点符号或方括号语法来访问这个方法，都没有关系。）</span><br></code></pre></td></tr></table></figure><p>在没有对象的情况下调用：<code>this == undefined</code>。</p><h2 id="箭头函数没有自己的”this”"><a href="#箭头函数没有自己的”this”" class="headerlink" title="箭头函数没有自己的”this”"></a>箭头函数没有自己的”this”</h2><p>箭头函数没有自己的 <code>this</code>，若在函数中引用 <code>this</code>，<code>this</code> 值取决于外部 “正常的” 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Ilya&quot;</span>,<br>    <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-title function_">arrow</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span>);<br>        <span class="hljs-title function_">arrow</span>();<br>    &#125;<br>&#125;;<br><br>user.<span class="hljs-title function_">sayHi</span>();   <span class="hljs-comment">// Ilya</span><br><span class="hljs-comment">// arrow() 使用的 this 来自于外部的 user.sayHi() 方法</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>存储在对象属性中的函数被称为“方法”；</li><li>方法允许对象进行像 <code>object.doSomething()</code> 这样的“操作”；</li><li>方法可以将对象引用为 <code>this</code>。</li></ul><p><code>this</code> 的值是在程序运行时得到的。</p><ul><li>一个函数在声明时，可能就使用了 <code>this</code>，但是这个 <code>this</code> 只有在函数被调用时才会有值。</li><li>可以在对象之间复制函数。</li><li>以“方法”的语法调用函数时：<code>object.method()</code>，调用过程中的 <code>this</code> 值是 <code>object</code>。</li></ul><p>请注意箭头函数有些特别：它们没有 <code>this</code>。在箭头函数内部访问到的 <code>this</code> 都是从外部获取的。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSON Object 对象 &lt;二&gt;</title>
    <link href="/2023/04/13/JSON%20Object%20%E5%AF%B9%E8%B1%A1(2)/"/>
    <url>/2023/04/13/JSON%20Object%20%E5%AF%B9%E8%B1%A1(2)/</url>
    
    <content type="html"><![CDATA[<h2 id="对象引用和复制"><a href="#对象引用和复制" class="headerlink" title="对象引用和复制"></a>对象引用和复制</h2><p>对象与原始类型的根本区别之一是，对象是“通过引用”存储和复制的，而原始类型：字符串、数字、布尔值等是“作为一个整体复制”。</p><ul><li>原始类型复制值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-keyword">let</span> phrase = message    <span class="hljs-comment">// 两个独立变量，每个中都存储着字符串 &quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/../image/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%AF%94%E5%96%BB%E5%9B%BE7.png" alt="键值对比喻图"></p><ul><li>对象复制值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>赋值了对象的变量存储的不是对象本身，而是该对象“在内存中的地址”，就是对该对象的“引用”。</p><p><img src="/../image/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%AF%94%E5%96%BB%E5%9B%BE8.png" alt="键值对比喻图"></p><p>上图表示该对象被存储在内存中的某个位置（在图片的右侧），而变量 <code>user</code> (在左侧)保存的是对其的“引用”。</p><p>可以将一个对象变量（如 <code>user</code> ）想象成一张写有对象的地址的纸，当对对象执行操作时，例如获取一个属性 <code>user.name</code>，JavaScript 引擎会查看该地址中的内容，并在实际对象上执行操作。</p><p><strong>当一个对象变量被复制，则引用被复制，而该对象本身并未被复制。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><span class="hljs-keyword">let</span> admin = user;   <span class="hljs-comment">// 复制引用</span><br></code></pre></td></tr></table></figure><p><img src="/../image/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%AF%94%E5%96%BB%E5%9B%BE9.png" alt="键值对比喻图"></p><p>变量 <code>user</code> 和 <code>admin</code> 都保存着对同一个对象的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br><span class="hljs-keyword">let</span> admin = user;<br>admin.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Pete&#x27;</span>; <span class="hljs-comment">// 通过 &quot;admin&quot; 引用来修改</span><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;Pete&#x27;，修改能通过 &quot;user&quot; 引用看到</span><br></code></pre></td></tr></table></figure><p>可以通过其中任意一个变量来访问该对象并修改它的内容。这就像有一个带有两把钥匙的柜子，使用其中一把钥匙（<code>admin</code>）打开柜子并更改了里面的东西。那么，如果我们稍后用另一把钥匙（<code>user</code>），我们仍然可以打开同一个柜子并且可以访问更改的内容。</p><h2 id="通过引用来比较"><a href="#通过引用来比较" class="headerlink" title="通过引用来比较"></a>通过引用来比较</h2><p>仅当两个对象为同一对象时，两者才相等。例如，这里的 <code>a</code> 和 <code>b</code> 两个变量都引用同一个对象，所以两者相等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> a = &#123;&#125;;<br><span class="hljs-keyword">let</span> b = a;      <span class="hljs-comment">// 复制引用</span><br><span class="hljs-title function_">alert</span>(a == b);  <span class="hljs-comment">// true，都引用同一对象</span><br><span class="hljs-title function_">alert</span>(a === b); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>但两个独立的对象并不相等，即使两者看起来很像（都为空）；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> a = &#123;&#125;;<br><span class="hljs-keyword">let</span> b = &#123;&#125;;         <span class="hljs-comment">// 两个独立的对象</span><br><span class="hljs-title function_">alert</span>( a == b );    <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="克隆与合并，Object-assign"><a href="#克隆与合并，Object-assign" class="headerlink" title="克隆与合并，Object.assign"></a>克隆与合并，Object.assign</h2><p>如上所述，复制一个对象变量会创建一个对相同对象的引用。若想要复制一个对象，需要如下做法。</p><p>创建一个新对象，通过遍历已有对象的属性，并在原始类性值的层面复制它们，以实现对已有对象结构的复制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;George&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">27</span><br>&#125;;<br><span class="hljs-keyword">let</span> clone = &#123;&#125;;             <span class="hljs-comment">// 创建一个新的空对象</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) &#123;     <span class="hljs-comment">// 将 user 中所有的属性拷贝到其中</span><br>    clone[key] = user[key];<br>&#125;<br><br><span class="hljs-comment">// 现在 clone 是带有相同内容的完全独立的对象</span><br>clone.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Pete&quot;</span>; <span class="hljs-comment">// 改变了其中的数据</span><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">name</span> ); <span class="hljs-comment">// 原来的对象中的 name 属性依然是 George</span><br></code></pre></td></tr></table></figure><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(dest, [src1, src2, src3...])<br></code></pre></td></tr></table></figure><ul><li>第一个参数 <code>dest</code> 是指目标对象；</li><li>后面的参数 <code>src1, ..., srcN</code> （可按需传递多个参数）是源对象；</li><li>该方法将所有源对象的属性拷贝到目标对象 <code>dest</code> 中。换句话说，从第二个开始的所有参数的属性都被拷贝到第一个参数的对象中；</li><li>调用结果返回 dest。</li></ul><p>使用 <code>Object.assign</code> 来合并多个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><br><span class="hljs-keyword">let</span> permissions1 = &#123; <span class="hljs-attr">canView</span>: <span class="hljs-literal">true</span> &#125;;<br><span class="hljs-keyword">let</span> permissions2 = &#123; <span class="hljs-attr">canEdit</span>: <span class="hljs-literal">true</span> &#125;;<br><br><span class="hljs-comment">// 将 permission1 和 permission2 中的所有属性都拷贝到 user 中</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(user, permission1, permission2);<br><span class="hljs-comment">// 现在 user = &#123; name: &quot;John&quot;, canView: true, canEdit: true &#125;</span><br></code></pre></td></tr></table></figure><p>如果被拷贝的属性的属性名已经存在，那该属性名会被覆盖。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(user, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span> &#125;);<br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>);   <span class="hljs-comment">// 现在 user = &#123; name: &quot;Pete&quot; &#125;</span><br></code></pre></td></tr></table></figure><p>也可使用 <code>Object.assign</code> 代替 <code>for..in</code> 循环来进行简单克隆。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, user);<br><span class="hljs-comment">// 将 user 中的所有属性拷贝到了一个空对象中，并返回这个新的对象。</span><br></code></pre></td></tr></table></figure><h2 id="深层克隆"><a href="#深层克隆" class="headerlink" title="深层克隆"></a>深层克隆</h2><p>上述例子中，均假设 <code>user</code> 的所有属性均为原始类型，但属性也可以是对其他对象的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br>------------------------------------------<br><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>    <span class="hljs-attr">sizes</span>: &#123;            <span class="hljs-comment">// 对其他对象的引用</span><br>        <span class="hljs-attr">height</span>: <span class="hljs-number">182</span>,<br>        <span class="hljs-attr">width</span>: <span class="hljs-number">50</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>    <span class="hljs-attr">sizes</span>: &#123;            <span class="hljs-comment">// 对其他对象的引用</span><br>        <span class="hljs-attr">height</span>: <span class="hljs-number">182</span>,<br>        <span class="hljs-attr">width</span>: <span class="hljs-number">50</span><br>    &#125;<br>&#125;;<br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">sizes</span>.<span class="hljs-property">height</span> ); <span class="hljs-comment">// 182</span><br><br><span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, user);<br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">sizes</span> === clone.<span class="hljs-property">sizes</span> );    <span class="hljs-comment">// true,同为一个对象</span><br><br><span class="hljs-comment">// user 和 clone 分享同一个 sizes</span><br>user.<span class="hljs-property">sizes</span>.<span class="hljs-property">width</span>++;         <span class="hljs-comment">// 通过 user 改变属性值</span><br><span class="hljs-title function_">alert</span>(clone.<span class="hljs-property">sizes</span>.<span class="hljs-property">width</span>);   <span class="hljs-comment">// 51,能从clone中获取到变更后的结果</span><br></code></pre></td></tr></table></figure><p>深拷贝：为使 <code>user</code> 和 <code>clone</code> 成为两个真正独立的对象，可使用一个拷贝循环来检查 <code>user[key]</code> 的每个值，如果 <code>user[key]</code> 是一个对象，也复制其结构。</p><p>可使用递归来实现，或采用现有的实现，例如 <code>lodash</code> 库的 <code>_.cloneDeep(obj)</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对象通过引用被赋值和拷贝。一个变量存储的不是 “对象的值”，而是一个对值的 “引用”（内存地址），因此拷贝此类变量或将其作为函数参数传递时，所拷贝是引用，而不是对象本身。</p><p>所有通过被拷贝的引用的操作（如添加、删除属性）都作用在同一对象上。</p><p>创建 “真正的拷贝”（一个克隆），可使用 <code>Object.assign</code> 实现 “浅拷贝”（嵌套对象被通过引用进行拷贝），或使用 “深拷贝” 函数，如 <code>_.cloneDeep(obj)</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.javascript.info/object-copy">https://zh.javascript.info/object-copy</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSON Object 对象 &lt;一&gt;</title>
    <link href="/2023/04/11/JSON%20Object%20%E5%AF%B9%E8%B1%A1(1)/"/>
    <url>/2023/04/11/JSON%20Object%20%E5%AF%B9%E8%B1%A1(1)/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Object（对象）是用来存储键值对和更复杂的实体。通过使用带有可选 <strong>属性列表</strong> 的花括号 <code>&#123;...&#125;</code> 创建对象。一个属性就是一个键值对 （”key:value”），其中键（key）是一个字符串，值（value）可以是任何值。</p><p>可以把对象想象成一个带有签名文件的文件柜，每条数据都基于键（key）存储在文件中，这样可根据文件名（也就是“键”）添加&#x2F;删除&#x2F;查找文件。</p><p><img src="/../image/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%AF%94%E5%96%BB%E5%9B%BE1.png" alt="键值对比喻图"></p><p>创建一个空的对象（“空柜子”）方法：构造函数或者字面量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();    <span class="hljs-comment">// &quot;构造函数&quot;</span><br><span class="hljs-keyword">let</span> user = &#123;&#125;;              <span class="hljs-comment">// &quot;字面量&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/../image/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%AF%94%E5%96%BB%E5%9B%BE2.png" alt="键值对比喻图"></p><h2 id="文本和属性"><a href="#文本和属性" class="headerlink" title="文本和属性"></a>文本和属性</h2><p>创建对象时，可以立即将一些属性以键值对的形式放入 <code>&#123;...&#125;</code> 中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> usr = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;George&quot;</span>,     <span class="hljs-comment">// 键 &quot;name&quot;，值 &quot;George&quot;</span><br>    <span class="hljs-attr">age</span>: <span class="hljs-number">27</span>             <span class="hljs-comment">// 键 &quot;age&quot;，值 27</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>user</code> 对象中，有两个属性：</p><ol><li>第一个的键是 <code>&quot;name&quot;</code>，值是 <code>&quot;George&quot;</code>;</li><li>第一个的键是 <code>&quot;age&quot;</code>，值是 <code>&quot;27&quot;</code>。</li></ol><p>生成的 <code>user</code> 对象可以被想象为一个放置着两个标记有 <code>“name”</code> 和 <code>“age”</code> 的文件的柜子，能够随时添加、删除和读取文件。</p><p><img src="/../image/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%AF%94%E5%96%BB%E5%9B%BE3.png" alt="键值对比喻图"></p><ul><li><p>使用 <code>.</code> 点符号访问属性值；</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>);   <span class="hljs-comment">// George</span><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">age</span>);    <span class="hljs-comment">// 27</span><br></code></pre></td></tr></table></figure><p>  属性值可以是任意类型。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javaScript">user.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>  <img src="/../image/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%AF%94%E5%96%BB%E5%9B%BE4.png" alt="键值对比喻图"></p></li><li><p>使用 <code>delete</code> 操作符移除属性；</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">delete</span> user.<span class="hljs-property">age</span><br></code></pre></td></tr></table></figure><p>  <img src="/../image/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%AF%94%E5%96%BB%E5%9B%BE5.png" alt="键值对比喻图"></p></li><li><p>使用多字词语来作为属性名，但必须给它们加上引号；</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;George&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">27</span>,<br>    <span class="hljs-string">&quot;likes birds&quot;</span>: <span class="hljs-literal">true</span>  <span class="hljs-comment">// 多词属性名必须加引号</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>  <img src="/../image/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%AF%94%E5%96%BB%E5%9B%BE6.png" alt="键值对比喻图">   </p></li><li><p>列表中最后一个属性应以逗号结尾；</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;George&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">27</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="点符号与方括号"><a href="#点符号与方括号" class="headerlink" title="点符号与方括号"></a>点符号与方括号</h2><p>点操作不能用于多次属性。</p><ul><li>点符号：要求 <code>key</code> 是有效的变量标识符，不能包含空格，不以数字开头，不包含特殊符号（允许使用 <code>$</code> 和 <code>_</code>）</li><li>方括号：可用于任何字符串，方括号中的字符串需要放在引号中，单&#x2F;双引号均可；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javaScript">user.<span class="hljs-property">likes</span> birds = <span class="hljs-literal">true</span>     <span class="hljs-comment">// 误以为处理 user.likes，遇到 birds 时会报语法错误</span><br>-----------------------<br><span class="hljs-keyword">let</span> user = &#123;&#125;<br>user[<span class="hljs-string">&quot;likes birds&quot;</span>] = <span class="hljs-literal">true</span>  <span class="hljs-comment">// 设置</span><br><span class="hljs-title function_">alert</span>(user[<span class="hljs-string">&quot;likes birds&quot;</span>]); <span class="hljs-comment">// 读取，true</span><br><span class="hljs-keyword">delete</span> user[<span class="hljs-string">&quot;likes birds&quot;</span>]; <span class="hljs-comment">// 删除</span><br></code></pre></td></tr></table></figure><p>同时，方括号提供了一种可以通过任意表达式来获取属性名的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> key = <span class="hljs-string">&quot;likes birds&quot;</span>;<br>user[key] = <span class="hljs-literal">true</span>;<br>-----------------------<br>user[<span class="hljs-string">&quot;likes birds&quot;</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 与上面等同</span><br></code></pre></td></tr></table></figure><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>计算属性：当创建一个对象时，可以在对象字面量中使用方括号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> fruit = <span class="hljs-string">&#x27;apple&#x27;</span>;<br><span class="hljs-keyword">let</span> bag = &#123;<br>    [fruit]: <span class="hljs-number">5</span>,     <span class="hljs-comment">// 属性名从 fruit 变量中得到，此时 bag 变为 &#123;apple：5&#125;</span><br>&#125;<br><span class="hljs-title function_">alert</span>(bag.<span class="hljs-property">apple</span>);   <span class="hljs-comment">// 5</span><br>-----------------------<br><span class="hljs-keyword">let</span> fruit = <span class="hljs-string">&#x27;apple&#x27;</span>;<br><span class="hljs-keyword">let</span> bag = &#123;&#125;;<br>bag[fruit] = <span class="hljs-number">5</span>;     <span class="hljs-comment">// 与上面等同</span><br></code></pre></td></tr></table></figure><p>计算属性含义为：<code>[fruit]</code> 含义是属性名从 <code>fruit</code> 变量中获取。</p><p>方括号可用于更复杂的表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> fruit = <span class="hljs-string">&#x27;apple&#x27;</span>;<br><span class="hljs-keyword">let</span> bag = &#123;<br>    [fruit + <span class="hljs-string">&#x27;Computers&#x27;</span>]: <span class="hljs-number">5</span>    <span class="hljs-comment">// bag.appleComputers = 5</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="属性值简写"><a href="#属性值简写" class="headerlink" title="属性值简写"></a>属性值简写</h2><p>使用已经存在的变量当作属性名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeUser</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">name</span>: name,<br>        <span class="hljs-attr">age</span>: age,<br>        <span class="hljs-comment">// ……其他的属性</span><br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-title function_">makeUser</span>(<span class="hljs-string">&quot;George&quot;</span>, <span class="hljs-number">27</span>);<br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>);   <span class="hljs-comment">// George</span><br></code></pre></td></tr></table></figure><h2 id="属性名称限制"><a href="#属性名称限制" class="headerlink" title="属性名称限制"></a>属性名称限制</h2><p>变量名不能是某个保留字，如 <code>&quot;for&quot;</code>、<code>&quot;let&quot;</code>、<code>&quot;return&quot;</code>，但对象的属性名不受限制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">for</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">let</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">return</span>: <span class="hljs-number">3</span><br>&#125;;<br><span class="hljs-title function_">alert</span>( obj.<span class="hljs-property">for</span> + obj.<span class="hljs-property">let</span> + obj.<span class="hljs-property">return</span> );    <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure><h2 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for..in 循环"></a>for..in 循环</h2><p><code>for..in</code> 可以遍历一个对象中的所有键（key）.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">for</span>(key <span class="hljs-keyword">in</span> object)&#123;<br>    <span class="hljs-comment">// </span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;George&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">27</span>,<br>    <span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">true</span><br>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user)&#123;<br>    <span class="hljs-title function_">alert</span>(key);         <span class="hljs-comment">// name，age，isAdmin</span><br>    <span class="hljs-title function_">alert</span>(user[key]);   <span class="hljs-comment">// George，27，true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>所有 “for” 结构体都允许在循环体中定义变量，例如 <code>let key</code>；</li><li>可以使用其他属性名来替代 <code>key</code>，例如 <code>for(let prop in obj)</code>。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对象是具有一些特殊特性的关联数组，存储属性（键值对），其中：</p><p>属性的键必须是字符串或者 symbol（通常是字符串），值可以是任何类型。可以用下面的方法访问属性：</p><ul><li>点符号: obj.property；</li><li>方括号：obj[“property”]，方括号允许从变量中获取键，例如 obj[varWithKey]。</li></ul><p>其他操作：</p><ul><li>删除属性：delete obj.prop；</li><li>检查是否存在给定键的属性：”key” in obj；</li><li>遍历对象：for(let key in obj) 循环。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.javascript.info/object#shu-xing-cun-zai-xing-ce-shi-in-cao-zuo-fu">https://zh.javascript.info/object#shu-xing-cun-zai-xing-ce-shi-in-cao-zuo-fu</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端未响应</title>
    <link href="/2023/04/07/%E5%89%8D%E7%AB%AF%E6%9C%AA%E5%93%8D%E5%BA%94/"/>
    <url>/2023/04/07/%E5%89%8D%E7%AB%AF%E6%9C%AA%E5%93%8D%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<h2 id="前端未响应"><a href="#前端未响应" class="headerlink" title="前端未响应"></a>前端未响应</h2><p>前端未响应，显示连接不上 <code>localhost:8092</code> (自己的端口号)，可以尝试使用以下命令解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsof -i:8092    // 查看占用的 pid，比如查出来是 1221<br><span class="hljs-built_in">kill</span> 1221<br>ctrl+<span class="hljs-built_in">shift</span>+p    // 输入 reloadwindow  重新加载vscode<br></code></pre></td></tr></table></figure><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><p><a href="https://en.wikipedia.org/wiki/Lsof">lsof</a>（list open files）意为列出打开的文件，主要用作查看类 Unix 系统中所有打开的文件和打开它们进度的列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsof -i -n -P | grep sendmail<br>sendmail  31649    root    4u  IPv4 521738       TCP *:25 (LISTEN)<br></code></pre></td></tr></table></figure><p>从上面可以看出，“sendmail”正在监听其标准端口“25”。</p><ul><li><code>-i</code><br>  Lists IP sockets.</li><li><code>-n</code><br>  Do not resolve hostnames (no DNS).</li><li><code>-P</code><br>  Do not resolve port names (list port number instead of its name).</li></ul><pre><code class="hljs"></code></pre>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>element 日期选择器</title>
    <link href="/2023/04/07/element%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <url>/2023/04/07/element%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="日期范围选择器"><a href="#日期范围选择器" class="headerlink" title="日期范围选择器"></a>日期范围选择器</h2><p>日期范围选择器限制只选择今天及以前的日期。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;el-date-picker <br>    style=&quot;margin-left: 5px;&quot; <br>    v-model=&quot;valueTime&quot; <br>    type=&quot;daterange&quot; <br>    format=&quot;yyyy-MM-dd&quot; <br>    unlink-panels<br>    value-format=&quot;yyyy-MM-dd&quot;<br>    range-separator=&quot;至&quot;<br>    start-placeholder=&quot;开始日期&quot;<br>    end-placeholder=&quot;结束日期&quot;<br>    :picker-options=&quot;pickerOptions&quot;&gt;<br>&lt;/el-date-picker&gt;<br></code></pre></td></tr></table></figure><ul><li><code>unlink-panels</code>: 在范围选择器里取消两个日期面板之间的联动。</li></ul><p>在组件中需进行如下设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>    valueTime: &quot;&quot;,<br>    pickerOptions: &#123;<br>        disabledDate (time) &#123;<br>            return time.getTime() &gt; Date.now();<br>        &#125;<br>    &#125;,<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>实际效果如下：</p><p><img src="/../image/element%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%E5%99%A8_1.1.png" alt="element日期选择器1"></p><p><img src="/../image/element%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%E5%99%A8_1.2.png" alt="element日期选择器2"></p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>其他几种常见日期设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>    pickerOptions: &#123;<br>        disabledDate(time) &#123;<br>            // 设置选择今天以及今天之后的日期<br>            return time.getTime() &lt; Date.now() - 8.64e7<br>            // 设置选择今天以及今天以前的日期<br>            return time.getTime() &gt; Date.now();<br>            // 设置选择今天之后的日期（不能选择当天时间）<br>            return time.getTime() &lt; Date.now();        <br>            // 设置选择今天之前的日期（不能选择当天）<br>            return time.getTime() &gt; Date.now() - 8.64e7 <br>            // 设置当天23：59：59可选<br>            let currentTime = this.getNowMonthDay() + ` 23:59:59`<br>                return time.getTime() &gt; new Date(currentTime).getTime()<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://element.eleme.cn/2.0/#/zh-CN/component/date-picker">https://element.eleme.cn/2.0/#/zh-CN/component/date-picker</a></p><p><a href="https://segmentfault.com/q/1010000037421298">https://segmentfault.com/q/1010000037421298</a></p>]]></content>
    
    
    <categories>
      
      <category>Element</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
