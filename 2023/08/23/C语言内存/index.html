

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="GeorgyKwe">
  <meta name="keywords" content="">
  
    <meta name="description" content="C语言内存 C 语言中使用的地址为什么是假的，计算机又是如何通过假的地址访问到真实的物理内存的？  一个 C 语言程序在内存中是如何分布的？函数放在哪里？变量放在哪里？字符串放在哪里？  为什么全局变量在整个程序中都可以使用，而局部变量只能在函数内部使用？  一个 C 语言程序可以使用多大的内存？  操作系统和用户程序之间是如何协作的？  堆和栈都是什么？它们在程序运行过程中起到什么作用？为什么栈">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言内存">
<meta property="og:url" content="http://example.com/2023/08/23/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98/index.html">
<meta property="og:site_name" content="我与我斗争">
<meta property="og:description" content="C语言内存 C 语言中使用的地址为什么是假的，计算机又是如何通过假的地址访问到真实的物理内存的？  一个 C 语言程序在内存中是如何分布的？函数放在哪里？变量放在哪里？字符串放在哪里？  为什么全局变量在整个程序中都可以使用，而局部变量只能在函数内部使用？  一个 C 语言程序可以使用多大的内存？  操作系统和用户程序之间是如何协作的？  堆和栈都是什么？它们在程序运行过程中起到什么作用？为什么栈">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/c_pic/%E5%9B%BE1.1.png">
<meta property="og:image" content="http://example.com/image/c_pic/%E5%9B%BE2.1.png">
<meta property="og:image" content="http://example.com/image/c_pic/%E5%9B%BE4.1.png">
<meta property="og:image" content="http://example.com/image/c_pic/%E5%9B%BE4.2.png">
<meta property="og:image" content="http://example.com/image/c_pic/%E5%9B%BE13.1.png">
<meta property="og:image" content="http://example.com/image/c_pic/%E5%9B%BE13.2.png">
<meta property="og:image" content="http://example.com/image/c_pic/%E5%9B%BE13.3.png">
<meta property="og:image" content="http://example.com/image/c_pic/%E5%9B%BE13.4.png">
<meta property="og:image" content="http://example.com/image/c_pic/%E5%9B%BE13.5.png">
<meta property="og:image" content="http://example.com/image/c_pic/%E5%9B%BE13.6.png">
<meta property="og:image" content="http://example.com/image/c_pic/%E5%9B%BE5.1.png">
<meta property="og:image" content="http://example.com/2023/08/23/image/c_pic/%E5%9B%BE5.2.png">
<meta property="og:image" content="http://example.com/image/c_pic/%E5%9B%BE6.1.png">
<meta property="og:image" content="http://example.com/image/c_pic/%E5%9B%BE6.2.png">
<meta property="og:image" content="http://example.com/image/c_pic/%E5%9B%BE7.2.png">
<meta property="og:image" content="http://example.com/image/c_pic/%E5%9B%BE9.1.png">
<meta property="og:image" content="http://example.com/image/c_pic/%E5%9B%BE9.2.png">
<meta property="og:image" content="http://example.com/image/c_pic/%E5%9B%BE9.3.png">
<meta property="og:image" content="http://example.com/image/c_pic/%E5%9B%BE9.4.png">
<meta property="og:image" content="http://example.com/image/c_pic/%E5%9B%BE9.5.png">
<meta property="og:image" content="http://example.com/image/c_pic/%E5%9B%BE9.6.png">
<meta property="og:image" content="http://example.com/image/c_pic/%E5%9B%BE11.1.gif">
<meta property="article:published_time" content="2023-08-23T09:23:28.000Z">
<meta property="article:modified_time" content="2023-09-06T06:36:29.319Z">
<meta property="article:author" content="GeorgyKwe">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/image/c_pic/%E5%9B%BE1.1.png">
  
  
  
  <title>C语言内存 - 我与我斗争</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>我与我斗争</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C语言内存"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-08-23 17:23" pubdate>
          2023年8月23日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          31k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          259 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C语言内存</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="C语言内存"><a href="#C语言内存" class="headerlink" title="C语言内存"></a>C语言内存</h1><ul>
<li><p><strong>C</strong> 语言中使用的地址为什么是假的，计算机又是如何通过假的地址访问到真实的物理内存的？</p>
</li>
<li><p>一个 <strong>C</strong> 语言程序在内存中是如何分布的？函数放在哪里？变量放在哪里？字符串放在哪里？</p>
</li>
<li><p>为什么全局变量在整个程序中都可以使用，而局部变量只能在函数内部使用？</p>
</li>
<li><p>一个 <strong>C</strong> 语言程序可以使用多大的内存？</p>
</li>
<li><p>操作系统和用户程序之间是如何协作的？</p>
</li>
<li><p>堆和栈都是什么？它们在程序运行过程中起到什么作用？为什么栈内存的分配效率要高于堆？</p>
</li>
<li><p>栈溢出是怎么回事，如何利用栈溢出进行攻击？</p>
</li>
<li><p>内存泄漏、野指针、非法内存访问、段错误都是怎么产生的？</p>
</li>
<li><p>内存池、线程池、连接池等这些莫名其妙的“池子”是怎么回事？</p>
</li>
</ul>
<p>程序是保存在硬盘中的，要载入内存才能运行，<strong>CPU</strong> 也被设计为只能从内存中读取数据和指令。</p>
<h2 id="1-程序在内存运行"><a href="#1-程序在内存运行" class="headerlink" title="1 程序在内存运行"></a>1 程序在内存运行</h2><p>对于 <strong>CPU</strong> 来说，内存仅仅是一个存放指令和数据的地方，并不能在内存中完成计算功能，例如要计算 <code>a = b + c</code>，必须将 <code>a、b、c</code> 都读取到 <strong>CPU</strong> 内部才能进行加法运算。为了了解具体的运算过程，先来看下 <strong>CPU</strong> 的结构。</p>
<p><strong>CPU</strong> 是一个复杂的计算机部件，它内部又包含很多小零件，如下图所示：</p>
<p><img src="/../image/c_pic/%E5%9B%BE1.1.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>运算单元是 <strong>CPU</strong> 的大脑，负责加减乘除、比较、位移等运算工作，每种运算都有对应的电路支持，速度很快。</p>
</li>
<li><p>寄存器（<strong>Register</strong>）是 <strong>CPU</strong> 内部非常小、非常快速的存储部件，它的容量很有限，对于 <strong>32</strong> 位的 <strong>CPU</strong>，每个寄存器一般能存储 <strong>32</strong> 位（<strong>4</strong> 个字节）的数据，对于 <strong>64</strong> 位的 <strong>CPU</strong>，每个寄存器一般能存储 <strong>64</strong> 位（ <strong>8</strong> 个字节）的数据。为了完成各种复杂的功能，现代 <strong>CPU</strong> 都内置了几十个甚至上百个的寄存器，嵌入式系统功能单一，寄存器数量较少。</p>
<ul>
<li>所谓多少位的 <strong>CPU</strong>，指的就是寄存器的的位数。<strong>PC</strong> 使用的 <strong>CPU</strong> 已经进入了 <strong>64</strong> 位时代，例如 <strong>Intel</strong> 的 <strong>Core i3、i5、i7</strong> 等。</li>
<li>寄存器在程序的执行过程中至关重要，不可或缺，它们可以用来完成数学运算、控制循环次数、控制程序的执行流程、标记 <strong>CPU</strong> 运行状态等。<ul>
<li><strong>EIP（Extern Instruction Pointer）</strong> 寄存器的值是下一条指令的地址，<strong>CPU</strong> 执行完当前指令后，会根据 <strong>EIP</strong> 的值找到下一条指令，改变 <strong>EIP</strong> 的值，就会改变程序的执行流程；</li>
<li><strong>CR3</strong> 寄存器保存着当前进程页目录的物理地址，切换进程就会改变 <strong>CR3</strong> 的值；</li>
<li><strong>EBP、ESP</strong> 寄存器用来指向栈的底部和顶部，函数调用会改变 <strong>EBP</strong> 和 <strong>ESP</strong> 的值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-1-为何-CPU-内部为什么要设置缓存呢？"><a href="#1-1-为何-CPU-内部为什么要设置缓存呢？" class="headerlink" title="1.1 为何 CPU 内部为什么要设置缓存呢？"></a>1.1 为何 CPU 内部为什么要设置缓存呢？</h3><p>虽然内存的读取速度已经很快了，但是和 <strong>CPU</strong> 比起来，还是有很大差距的，不是一个数量级的，如果每次都从内存中读取数据，会严重拖慢 <strong>CPU</strong> 的运行速度，<strong>CPU</strong> 经常处于等待状态，无事可做。在 <strong>CPU</strong> 内部设置一个缓存，可以将使用频繁的数据暂时读取到缓存，需要同一地址上的数据时，就不用大老远地再去访问内存，直接从缓存中读取即可。</p>
<blockquote>
<p>在购买 <strong>CPU</strong> 时，也会经常关心缓存容量，例如 <strong>Intel Core i7 3770K</strong> 的三级缓存为 <strong>8MB</strong>，二级缓存为 <strong>256KB</strong>，一级缓存为 <strong>32KB</strong>。容量越大，<strong>CPU</strong> 越强悍。</p>
</blockquote>
<h3 id="1-2-CPU指令"><a href="#1-2-CPU指令" class="headerlink" title="1.2 CPU指令"></a>1.2 CPU指令</h3><p>要想让 <strong>CPU</strong> 工作，必须借助特定的指令，例如 <strong>add</strong> 用于加法运算，<strong>sub</strong> 用于除法运算，<strong>cmp</strong> 用于比较两个数的大小，这称为 <strong>CPU</strong> 的指令集<strong>（Instruction Set）</strong>。 <strong>C</strong> 语言代码最终也会编译成一条一条的 <strong>CPU</strong> 指令。不同型号的 <strong>CPU</strong> 支持的指令集会有所差异，但绝大部分是相同的。</p>
<p>以 <strong>C</strong> 语言中的加法为例来演示 <strong>CPU</strong> 指令的使用。假设有下面的C语言代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">0X14</span>, b = <span class="hljs-number">0XAE</span>, c;<br>c = a + b;<br></code></pre></td></tr></table></figure>

<p>在 <strong>VS2010 Debug</strong> 模式下生成的 <strong>CPU</strong> 指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov  ptr[a], 0X14<br>mov  ptr[b], 0XAE<br>mov  eax, ptr[a]<br>add  eax, ptr[b]<br>mov  ptr[c], eax<br></code></pre></td></tr></table></figure>

<p><strong>mov</strong> 和 <strong>add</strong> 都是 <strong>CPU</strong> 指令：</p>
<ul>
<li><p><strong>mov</strong> 用来将一个数值移动到一个存储位置。这个数值可以是一个常数，也可以在内存或者寄存器上；这个存储位置可以是寄存器或者内存。</p>
<ul>
<li>第一条指令中，<strong>ptr[a]</strong> 表示变量 <strong>a</strong> 的地址，<strong>0X14</strong> 是一个数值，<code>mov ptr[a], 0X14</code> 表示把数值 <strong>0X14</strong> 移动到 <strong>ptr[a]</strong> 指向的内存，也就是给变量 <strong>a</strong> 赋值。第二条指令与此类似。</li>
<li>第三条指令中，<strong>eax</strong> 是寄存器的名字，该寄存器常用在加法运算中，用来保存某个加数或运算结果，<code>mov eax, ptr[a]</code> 表示把变量 <strong>a</strong> 的值移动到寄存器 <strong>eax</strong> 中。</li>
<li>第五条指令表示把寄存器 <strong>eax</strong> 的值移动到变量 <strong>c</strong> 中，此时 <strong>exa</strong> 中的值为 <strong>a、b</strong> 相加的和。</li>
</ul>
</li>
<li><p><strong>add</strong> 用来将两个数值相加，这两个数值可以在寄存器或者内存中，<strong>add</strong> 会将相加的结果放在第一个数所在的位置。</p>
<ul>
<li>第四条指令 <code>add  eax, ptr[b]</code> 表示把 <strong>eax</strong> 和 <strong>ptr[b]</strong> 中的数值相加，并把结果放在 <strong>eax</strong> 中。</li>
</ul>
</li>
</ul>
<p>总起来讲：第一二条指令给变量 <strong>a、b</strong> 赋值，第三四条指令完成加法运算，第五条指令将运算结果赋值给变量 <strong>c</strong>。</p>
<h2 id="2-虚拟内存到底是什么？为什么看到的地址都是假的？"><a href="#2-虚拟内存到底是什么？为什么看到的地址都是假的？" class="headerlink" title="2 虚拟内存到底是什么？为什么看到的地址都是假的？"></a>2 虚拟内存到底是什么？为什么看到的地址都是假的？</h2><p>在 <strong>C</strong> 语言中，指针变量的值就是一个内存地址，<code>&amp; </code> 的作用也是取变量的内存地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 举个栗子 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <br>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">225</span>;<br>	<span class="hljs-type">int</span>* pa = &amp;a;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pa = %x, &amp;b = %x\n&quot;</span>, pa, &amp;b);<br>	system(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 输出结果 */</span><br>pa = <span class="hljs-number">590f</span>5c4, &amp;b = <span class="hljs-number">590f</span>5e4<br></code></pre></td></tr></table></figure>

<p>代码中的 <strong>a、b</strong> 是全局变量，它们的内存地址在链接时就已经决定，以后再也不能改变，该程序无论在何时运行，结果都是一样的。</p>
<p><strong>Q：</strong>如果物理内存中的这两个地址被其他程序占用了怎么办，此时程序是不是无法运行了？</p>
<p>如下图所示，这些内存地址都是假的，不是真实的物理内存地址，而是虚拟地址。虚拟地址通过 <strong>CPU</strong> 的转换才能对应到物理地址，而且每次程序运行时，操作系统都会重新安排虚拟地址和物理地址的对应关系，哪一段物理内存空闲就使用哪一段。</p>
<p><img src="/../image/c_pic/%E5%9B%BE2.1.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-1-虚拟地址"><a href="#2-1-虚拟地址" class="headerlink" title="2.1 虚拟地址"></a>2.1 虚拟地址</h3><p>把程序给出的地址看做是一种虚拟地址 <strong>（Virtual Address）</strong>，然后通过某些映射的方法，将这个虚拟地址转换成实际的物理地址。只要能够妥善地控制这个虚拟地址到物理地址的映射过程，就可以保证程序每次运行时都可以使用相同的地址。</p>
<p>例如，上面代码中变量 <strong>a</strong> 的地址是 <strong>590f5c4</strong>，第一次运行时它对应的物理内存地址可能是 <strong>0X12ED90AA</strong>，第二次运行时可能又对应 <strong>0XED90</strong>，而程序则不需要关心这些，这些繁杂的内存管理工作交给操作系统处理即可。</p>
<p>回到程序的运行本质上来看，用户程序在运行时不希望介入到这些复杂的内存管理过程中，作为普通的程序，它需要的是一个简单的执行环境，有自己的内存，有自己的 <strong>CPU</strong>，好像整个程序占有整个计算机而不用关心其他的程序。</p>
<p>使用虚拟地址好处：1、编程时可以使用固定的内存地址；2、能够使不同程序的地址空间相互隔离，提高内存使用效率。 </p>
<h4 id="2-1-1-使不同程序的地址空间相互隔离"><a href="#2-1-1-使不同程序的地址空间相互隔离" class="headerlink" title="2.1.1 使不同程序的地址空间相互隔离"></a>2.1.1 使不同程序的地址空间相互隔离</h4><p>如果所有程序都直接使用物理内存，那么程序所使用的地址空间不是相互隔离的。恶意程序可以很容易改写其他程序的内存数据，以达到破坏的目的；有些非恶意、但是有 <strong>Bug</strong> 的程序也可能会不小心修改其他程序的数据，导致其他程序崩溃。</p>
<p>这对于需要安全稳定的计算机环境的用户来说是不能容忍的，用户希望他在使用计算机的时候，其中一个任务失败了，至少不会影响其他任务。</p>
<p>使用了虚拟地址后，程序 <strong>A</strong> 和程序 <strong>B</strong> 虽然都可以访问同一个地址，但它们对应的物理地址是不同的，无论如何操作，都不会修改对方的内存。</p>
<h4 id="2-1-2-提高内存使用效率"><a href="#2-1-2-提高内存使用效率" class="headerlink" title="2.1.2 提高内存使用效率"></a>2.1.2 提高内存使用效率</h4><p>使用虚拟地址后，操作系统会更多地介入到内存管理工作中，这使得控制内存权限成为可能。例如，希望保存数据的内存没有执行权限，保存代码的内存没有修改权限，操作系统占用的内存普通程序没有读取权限等。</p>
<p>另外，当物理内存不足时，操作系统能够更加灵活地控制换入换出的粒度，磁盘 <strong>I&#x2F;O</strong> 是非常耗时的工作，这能够从很大程度上提高程序性能。</p>
<h3 id="2-2-中间层思想"><a href="#2-2-中间层思想" class="headerlink" title="2.2 中间层思想"></a>2.2 中间层思想</h3><p>在计算机中，为了让操作更加直观、易于理解、增强用户体验，开发者经常会使用一件法宝——增加中间层，即使用一种间接的方式来屏蔽复杂的底层细节，只给用户提供简单的接口。虚拟地址是使用中间层的一个典型例子。</p>
<h2 id="3-虚拟地址空间"><a href="#3-虚拟地址空间" class="headerlink" title="3 虚拟地址空间"></a>3 虚拟地址空间</h2><p>虚拟地址空间，就是程序可以使用的虚拟地址的有效范围。虚拟地址和物理地址的映射关系由操作系统决定，相应地，虚拟地址空间的大小也由操作系统决定，但还会受到编译模式的影响。</p>
<h3 id="3-1-CPU的数据处理能力"><a href="#3-1-CPU的数据处理能力" class="headerlink" title="3.1 CPU的数据处理能力"></a>3.1 CPU的数据处理能力</h3><p><strong>CPU</strong> 是计算机的核心，决定了计算机的数据处理能力和寻址能力，也即决定了计算机的性能。<strong>CPU</strong> 一次（一个时钟内）能处理的数据的大小由寄存器的位数和数据总线的宽度（也即有多少根数据总线）决定，通常所说的多少位的 <strong>CPU</strong>，除了可以理解为寄存器的位数，也可以理解数据总线的宽度，通常情况下它们是相等的。</p>
<blockquote>
<p>数据总线位于主板之上，不在 <strong>CPU</strong> 中，也不由 <strong>CPU</strong> 决定，严格来讲，这里应该说CPU能够支持的数据总线的最大根数，也即能够支持的最大数据处理能力。</p>
</blockquote>
<p>数据总线和主频都是 <strong>CPU</strong> 的重要指标：数据总线决定了 <strong>CPU</strong> 单次的数据处理能力，主频决定了 <strong>CPU</strong> 单位时间内的数据处理次数，它们的乘积就是 <strong>CPU</strong> 单位时间内的数据处理量。</p>
<blockquote>
<p><strong>CPU</strong> 主频在计算机的发展过程中飞速提升，从最初的几十 <strong>KHz</strong>，到后来的几百 <strong>MHz</strong>，再到现在的 <strong>4GHz</strong>，终于因为硅晶体的物理特性很难再提升，只能向多核方向发展。在这个过程中，CPU的数据总线宽度也在成倍增长，从早期的 <strong>8</strong> 位、<strong>16</strong> 位，到后来的 <strong>32</strong> 位，现在计算机大部分都在使用 <strong>64</strong> 位 <strong>CPU</strong>。</p>
</blockquote>
<p>需要注意的是，数据总线和地址总线不是一回事，数据总线用于在 <strong>CPU</strong> 和内存之间传输数据，地址总线用于在内存上定位数据，它们之间没有必然的联系，宽度并不一定相等。实际情况是，地址总线的宽度往往随着数据总线的宽度而增长，以访问更大的内存。</p>
<h4 id="3-1-1-16-位-CPU"><a href="#3-1-1-16-位-CPU" class="headerlink" title="3.1.1 16 位 CPU"></a>3.1.1 16 位 CPU</h4><p>早期的 <strong>CPU</strong> 是16 位的，一次能处理 <strong>16Bit</strong>（2个字节）的数据。计算机产业还处在早期，个人电脑也没有进入千家万户，也没有提出虚拟地址的概念，程序还是直接运行在物理内存上，操作系统对内存的管理非常简陋，程序员轻易就能编写一个恶意程序去修改其他程序的内存。</p>
<ul>
<li>典型的<strong>16</strong> 位处理器是 <strong>Intel 8086</strong>，它的数据总线有 <strong>16</strong> 根，地址总线有 <strong>20</strong> 根，寻址能力为 <strong>2^20 &#x3D; 1MB</strong>。</li>
</ul>
<h4 id="3-1-2-32-位-CPU"><a href="#3-1-2-32-位-CPU" class="headerlink" title="3.1.2 32 位 CPU"></a>3.1.2 32 位 CPU</h4><p>随着计算机产业的进步，出现了 <strong>32</strong> 位的 <strong>CPU</strong>，一次能处理 <strong>32Bit</strong>（<strong>4</strong> 个字节）的数据。这个时候就提出了虚拟地址的概念，并被应用到 <strong>CPU</strong> 和操作系统中，由它们共同完成虚拟地址和物理地址的映射，这使得程序编写更加容易，运行更加安全。</p>
<ul>
<li>典型的32位处理器是 <strong>Intel</strong> 的 <strong>80386</strong> 和 <strong>Intel Pentium 4（奔腾4）</strong>：<strong>80386</strong> 的数据总线和地址总线宽度都是 <strong>32</strong> 位，寻址能力达 <strong>4GB</strong>；<strong>Pentium 4</strong> 的地址总线宽度是 <strong>36</strong> 位，理论寻址能力达 <strong>64GB</strong>。</li>
</ul>
<h4 id="3-1-3-64-位-CPU"><a href="#3-1-3-64-位-CPU" class="headerlink" title="3.1.3 64 位 CPU"></a>3.1.3 64 位 CPU</h4><p>现代计算机都使用 <strong>64</strong> 位的 <strong>CPU</strong>，它们一次能处理 <strong>64Bit</strong>（<strong>8</strong> 个字节）的数据。典型的 <strong>64</strong> 位处理器是 <strong>Intel</strong> 的 <strong>Core i3、i5、i7</strong> 等，它们的地址总线宽度为 <strong>40~50</strong> 位左右。<strong>64</strong> 位 <strong>CPU</strong> 的出现使个人电脑再次发生了质的飞跃。</p>
<h3 id="3-2-实际支持的物理内存"><a href="#3-2-实际支持的物理内存" class="headerlink" title="3.2 实际支持的物理内存"></a>3.2 实际支持的物理内存</h3><p><strong>CPU</strong> 支持的物理内存只是理论上的数据，实际应用中还会受到操作系统的限制，例如，<strong>Win7  64</strong> 位家庭版最大仅支持 <strong>8GB</strong> 或 <strong>16GB</strong> 的物理内存，<strong>Win7 64</strong> 位专业版或企业版能够支持到 <strong>192GB</strong> 的物理内存。</p>
<p><strong>Windows Server 2003</strong> 数据中心版专为大型企业或国家机构而设计，可以处理海量数据，分为 <strong>32</strong> 位版和 <strong>64</strong> 位版，<strong>32</strong> 位版最高支持 <strong>512GB</strong> 的物理内存，这显然超出了 <strong>32</strong> 位 <strong>CPU</strong> 的寻址能力，可以通过两次寻址来实现。</p>
<h3 id="3-3-编译模式"><a href="#3-3-编译模式" class="headerlink" title="3.3 编译模式"></a>3.3 编译模式</h3><p>为兼容不同的平台，现代编译器大都提供两种编译模式：<strong>32</strong> 位模式和 <strong>64</strong> 位模式。</p>
<h4 id="3-3-1-32-位编译模式"><a href="#3-3-1-32-位编译模式" class="headerlink" title="3.3.1 32 位编译模式"></a>3.3.1 32 位编译模式</h4><p>在 <strong>32</strong> 位模式下，一个指针或地址占用 <strong>4</strong> 个字节的内存，共有 <strong>32</strong> 位，理论上能够访问的虚拟内存空间大小为 <strong>2^32 &#x3D; 0X100000000 Bytes</strong>，即 <strong>4GB</strong>，有效虚拟地址范围是 <strong>0 ~ 0XFFFFFFFF</strong>。 </p>
<p>对于 <strong>32</strong> 位的编译模式，不管实际物理内存有多大，程序能够访问的有效虚拟地址空间的范围就是 <strong>0 ~ 0XFFFFFFFF</strong>，也即虚拟地址空间的大小是 <strong>4GB</strong>。程序能够使用的最大内存为 <strong>4GB</strong>，跟物理内存没有关系。</p>
<ul>
<li><p>如果程序需要的内存大于物理内存，或者内存中剩余的空间不足以容纳当前程序，那么操作系统会将内存中暂时用不到的一部分数据写入到磁盘，等需要的时候再读取回来。而程序只管使用 <strong>4GB</strong> 的内存，不用关心硬件资源够不够。</p>
</li>
<li><p>如果物理内存大于 <strong>4GB</strong>，例如目前很多 <strong>PC</strong> 机都配备了 <strong>8GB</strong> 的内存，那么程序也无能为力，它只能够使用其中的 <strong>4GB</strong>。</p>
</li>
</ul>
<h4 id="3-3-2-64-位编译模式"><a href="#3-3-2-64-位编译模式" class="headerlink" title="3.3.2 64 位编译模式"></a>3.3.2 64 位编译模式</h4><p>在 <strong>64</strong> 位编译模式下，一个指针或地址占用 <strong>8</strong> 个字节的内存，共有 <strong>64</strong> 位，理论上能够访问的虚拟内存空间大小为 <strong>2^64</strong>。这是一个很大的值，几乎是无限的，就目前的技术来讲，不但物理内存不可能达到这么大，<strong>CPU</strong> 的寻址能力也没有这么大，实现 <strong>64</strong> 位长的虚拟地址只会增加系统的复杂度和地址转换的成本，带不来任何好处，所以 <strong>Windows</strong> 和 <strong>Linux</strong> 都对虚拟地址进行了限制，仅使用虚拟地址的低 <strong>48</strong> 位（<strong>6</strong> 个字节），总的虚拟地址空间大小为 <strong>2^48 &#x3D; 256TB</strong>。</p>
<blockquote>
<p><strong>32</strong> 位的操作系统只能运行 <strong>32</strong> 位的程序（也即以 <strong>32</strong> 位模式编译的程序），<strong>64</strong> 位操作系统可以同时运行 <strong>32</strong> 位的程序（为了向前兼容，保留已有的大量的 <strong>32</strong> 位应用程序）和 <strong>64</strong> 位的程序（也即以 <strong>64</strong> 位模式编译的程序）。<br><strong>64</strong> 位的 <strong>CPU</strong> 运行 <strong>64</strong> 位的程序才能发挥它的最大性能，运行 <strong>32</strong> 位的程序会白白浪费一部分资源。</p>
</blockquote>
<p>目前计算机可以说已经进入了 <strong>64</strong> 位的时代，之所以还要提供 <strong>32</strong> 位编译模式，是为了兼容一些老的硬件平台和操作系统，或者某些场合下 <strong>32</strong> 位的环境已经足够，使用 <strong>64</strong> 位环境会增大成本，例如嵌入式系统、单片机、工控等。</p>
<p>这里所说的 <strong>32</strong> 位环境是指：<strong>32</strong> 位的 <strong>CPU + 32</strong> 位的操作系统 + <strong>32</strong> 位的程序。<br>另外需要说明的是，<strong>32</strong> 位环境拥有非常经典的设计，易于理解，适合教学，现有的很多资料都是以 <strong>32</strong> 位环境为基础进行讲解的。除非特别指明，否则都是针对 <strong>32</strong> 位环境。相比于 <strong>32</strong> 位环境，<strong>64</strong> 位环境的设计思路并没有发生质的变化，理解了 <strong>32</strong> 环境很容易向 <strong>64</strong> 位环境迁移。</p>
<h2 id="4-内存分页机制"><a href="#4-内存分页机制" class="headerlink" title="4 内存分页机制"></a>4 内存分页机制</h2><p>关于虚拟地址和物理地址的映射有很多思路，假设以程序为单位，把一段与程序运行所需要的同等大小的虚拟空间映射到某段物理空间。</p>
<p>例如程序 <strong>A</strong> 需要 <strong>10MB</strong> 内存，虚拟地址的范围是从 <strong>0X00000000</strong> 到 <strong>0X00A00000</strong>，假设它被映射到一段同等大小的物理内存，地址范围从 <strong>0X00100000</strong> 到 <strong>0X00B00000</strong>，即虚拟空间中的每一个字节对应于物理空间中的每一个字节。</p>
<p>程序运行时，它们的对应关系如下图所示：</p>
<p><img src="/../image/c_pic/%E5%9B%BE4.1.png" srcset="/img/loading.gif" lazyload></p>
<p>当程序 <strong>A</strong> 需要访问 <strong>0X00001000</strong> 时，系统会将这个虚拟地址转换成实际的物理地址 <strong>0X00101000</strong>，访问 <strong>0X002E0000</strong> 时，转换成 <strong>0X003E0000</strong>，以此类推。</p>
<p>这种以整个程序为单位的方法很好地解决了不同程序地址不隔离的问题，同时也能够在程序中使用固定的地址。</p>
<ul>
<li>地址隔离</li>
</ul>
<p>如上图所示，程序 <strong>A</strong> 和程序 <strong>B</strong> 分别被映射到了两块不同的物理内存，它们之间没有任何重叠，如果程序 <strong>A</strong> 访问的虚拟地址超出了 <strong>0X00A00000</strong> 这个范围，系统就会判断这是一个非法的访问，拒绝这个请求，并将这个错误报告给用户，通常的做法就是强制关闭程序。</p>
<ul>
<li>程序可以使用固定的内存地址</li>
</ul>
<p>虚拟内存无论被映射到物理内存的哪一个区域，对于程序员来说都是透明的，不需要关心物理地址的变化，只需要按照从地址 <strong>0X00000000</strong> 到 <strong>0X00A00000</strong> 来编写程序、放置变量即可，程序不再需要重定位。</p>
<ul>
<li>内存使用效率问题</li>
</ul>
<p>以程序为单位对虚拟内存进行映射时，如果物理内存不足，被换入换出到磁盘的是整个程序，这样势必会导致大量的磁盘读写操作，严重影响运行速度，所以这种方法还是显得粗糙，粒度比较大。</p>
<h3 id="4-1-内存分页机制"><a href="#4-1-内存分页机制" class="headerlink" title="4.1 内存分页机制"></a>4.1 内存分页机制</h3><p>当一个程序运行时，在某个时间段内，它只是频繁地用到了一小部分数据，也就是说，程序的很多数据其实在一个时间段内都不会被用到。</p>
<p>以整个程序为单位进行映射，不仅会将暂时用不到的数据从磁盘中读取到内存，也会将过多的数据一次性写入磁盘，这会严重降低程序的运行效率。</p>
<p>现代计算机都使用分页（<strong>Paging</strong>）的方式对虚拟地址空间和物理地址空间进行分割和映射，以减小换入换出的粒度，提高程序运行效率。</p>
<p>分页（<strong>Paging</strong>）的思想是指把地址空间人为地分成大小相等（并且固定）的若干份，这样的一份称为一页，就像一本书由很多页面组成，每个页面的大小相等。如此，就能够以页为单位对内存进行换入换出：</p>
<ul>
<li><p>当程序运行时，只需要将必要的数据从磁盘读取到内存，暂时用不到的数据先留在磁盘中，什么时候用到什么时候读取。</p>
</li>
<li><p>当物理内存不足时，只需要将原来程序的部分数据写入磁盘，腾出足够的空间即可，不用把整个程序都写入磁盘。</p>
</li>
</ul>
<h4 id="4-1-1-关于页的大小"><a href="#4-1-1-关于页的大小" class="headerlink" title="4.1.1 关于页的大小"></a>4.1.1 关于页的大小</h4><p>页的大小是固定的，由硬件决定，或硬件支持多种大小的页，由操作系统选择决定页的大小。比如 <strong>Intel Pentium</strong> 系列处理器支持 <strong>4KB</strong> 或 <strong>4MB</strong> 的页大小，那么操作系统可以选择每页大小为 <strong>4KB</strong>，也可以选择每页大小为 <strong>4MB</strong>，但是在同一时刻只能选择一种大小，所以对整个系统来说，也就是固定大小。</p>
<p>目前几乎所有 <strong>PC</strong> 上的操作系统都是用 <strong>4KB</strong> 大小的页。假设使用的 <strong>PC</strong> 机是 <strong>32</strong> 位的，那么虚拟地址空间总共有 <strong>4GB</strong>，按照 <strong>4KB</strong> 每页分的话，总共有 <strong>2^32 &#x2F; 2^12 &#x3D; 2^20 &#x3D; 1M &#x3D; 1048576</strong> 个页；物理内存也是同样的分法。</p>
<h3 id="4-2-根据页进行映射"><a href="#4-2-根据页进行映射" class="headerlink" title="4.2 根据页进行映射"></a>4.2 根据页进行映射</h3><p>下面通过一个简单的例子来说明虚拟地址是如何根据页来映射到物理地址的，(虚拟空间、物理空间和磁盘之间的页映射关系)</p>
<p><img src="/../image/c_pic/%E5%9B%BE4.2.png" srcset="/img/loading.gif" lazyload></p>
<p>程序1和程序2的虚拟空间都有 <strong>8</strong> 个页，为了方便说明问题，假设每页大小为 <strong>1KB</strong>，那么虚拟地址空间就是 <strong>8KB</strong>。假设计算机有 <strong>13</strong> 条地址线，即拥有 <strong>2^13</strong> 的物理寻址能力，那么理论上物理空间可以多达 <strong>8KB</strong>。但是出于种种原因，购买内存的资金不够，只买得起 <strong>6KB</strong> 的内存，所以物理空间真正有效的只是前 <strong>6KB</strong>。</p>
<p>当把程序的虚拟空间按页分隔后，把常用的数据和代码页加载到内存中，把不常用的暂时留在磁盘中，当需要用到的时候再从磁盘中读取。上图中，假设有两个程序 <strong>Program 1</strong> 和 <strong>Program 2</strong>，它们的部分虚拟页面被映射到物理页面，比如 <strong>Program 1</strong> 的 <strong>VP0</strong>、<strong>VP1</strong> 和 <strong>VP7</strong> 分别被映射到 <strong>PP0</strong>、<strong>PP2</strong> 和 <strong>PP3</strong>；而有部分却留在磁盘中，比如 <strong>VP2</strong>、<strong>VP3</strong> 分别位于磁盘的 <strong>DP0</strong>、<strong>DP1</strong>中；另外还有一些页面如 <strong>VP4</strong>、<strong>VP5</strong>、<strong>VP6</strong> 可能尚未被用到或者访问到，它们暂时处于未使用状态。</p>
<blockquote>
<p>这里，把虚拟空间的页叫做虚拟页（<strong>VP，Virtual Page</strong>），把物理内存中的页叫做物理页（<strong>PP，Physical Page</strong>），把磁盘中的页叫做磁盘页（<strong>DP，Disk Page</strong>）。<br>图中的线表示映射关系，可以看到，<strong>Program 1</strong> 和 <strong>Program 2</strong> 中的有些虚拟页被映射到同一个物理页，这样可以实现内存共享。</p>
</blockquote>
<p><strong>Program 1</strong> 的 <strong>VP2</strong>、<strong>VP3</strong> 不在内存中，但是当进程需要用到这两个页的时候，硬件会捕获到这个消息，就是所谓的页错误（<strong>Page Fault</strong>），然后操作系统接管进程，负责将 <strong>VP2</strong> 和 <strong>PV3</strong> 从磁盘中读取出来并且装入内存，然后将内存中的这两个页与 <strong>VP2</strong>、<strong>VP3</strong> 之间建立映射关系。</p>
<h2 id="5-分页机制实现"><a href="#5-分页机制实现" class="headerlink" title="5 分页机制实现"></a>5 分页机制实现</h2><p>现代操作系统都使用分页机制来管理内存，这使得每个程序都拥有自己的地址空间。每当程序使用虚拟地址进行读写时，都必须转换为实际的物理地址，才能真正在内存条上定位数据。如下图所示：</p>
<p><img src="/../image/c_pic/%E5%9B%BE13.1.png" srcset="/img/loading.gif" lazyload></p>
<p>内存地址的转换是通过一种叫做页表（<strong>Page Table</strong>）的机制来完成的，即：</p>
<ul>
<li>页表是什么？为什么要采用页表机制，而不采用其他机制？</li>
<li>虚拟地址如何通过页表转换为物理地址？</li>
</ul>
<h3 id="5-1-直接使用数组转换"><a href="#5-1-直接使用数组转换" class="headerlink" title="5.1 直接使用数组转换"></a>5.1 直接使用数组转换</h3><p>最容易想到的映射方案是使用数组：每个数组元素保存一个物理地址，而把虚拟地址作为数组下标，这样就能够很容易地完成映射，并且效率不低。如下图所示：</p>
<p><img src="/../image/c_pic/%E5%9B%BE13.2.png" srcset="/img/loading.gif" lazyload></p>
<p>但是这样的数组有 <strong>2^32</strong> 个元素，每个元素大小为 <strong>4</strong> 个字节，总共占用 <strong>16GB</strong> 的内存，显现是不现实的！ </p>
<h3 id="5-2-使用一级页表"><a href="#5-2-使用一级页表" class="headerlink" title="5.2 使用一级页表"></a>5.2 使用一级页表</h3><p>既然内存是分页的，能够定位到数据所在的页，以及它在页内的偏移（也就是距离页开头的字节数），就能够转换为物理地址。例如，一个 <strong>int</strong> 类型的值保存在第 <strong>12</strong> 页，页内偏移为 <strong>240</strong>，那么对应的物理地址就是 <code>2^12 * 12 + 240 = 49392</code>。</p>
<blockquote>
<p><strong>2^12</strong> 为一个页的大小，也就是 <strong>4K</strong>。</p>
</blockquote>
<p>虚拟地址空间大小为 <strong>4GB</strong>，总共包含 <code>2^32/2^12 = 2^20 = 1K*1K = 1M = 1048576</code> 个页面，可以定义一个这样的数组：它包含 <strong>2^20 &#x3D; 1M</strong> 个元素，每个元素的值为页面编号（也就是位于第几个页面），长度为 <strong>4</strong> 字节，整个数组共占用 <strong>4MB</strong> 的内存空间。这样的数组就称为页表（<strong>Page Table</strong>），它记录了地址空间中所有页的编号。</p>
<p>虚拟地址长度为 <strong>32</strong> 位，不妨进行一下切割，将高 <strong>20</strong> 位作为页表数组的下标，低 <strong>12</strong> 位作为页内偏移。如下图所示：</p>
<p><img src="/../image/c_pic/%E5%9B%BE13.3.png" srcset="/img/loading.gif" lazyload></p>
<p>为什么要这样切割呢？因为页表数组共有 <code>2^20 = 1M</code> 个元素，使用虚拟地址的高 <strong>20</strong> 位作为下标，正好能够访问数组中的所有元素；并且，一个页面的大小为 <code>2^12 = 4KB</code>，使用虚拟地址的低 <strong>12</strong> 位恰好能够表示所有偏移。</p>
<p>注意，表示页面编号只需要 <strong>20</strong> 位，而页表数组的每个元素的长度却为 <strong>4</strong> 字节，即 <strong>32</strong> 位，多出 <code>32 - 20 = 12</code> 位。这 <strong>12</strong> 位也有很大的用处，可以用来表示当前页的相关属性，例如是否有读写权限、是否已经分配物理内存、是否被换出到硬盘等。</p>
<p>例如一个虚拟地址 <strong>0XA010BA01</strong>，它的高 <strong>20</strong> 位是 <strong>0XA010B</strong>，所以需要访问页表数组的第 <strong>0XA010B</strong> 个元素，才能找到数据所在的物理页面。假设页表数组第 <strong>0XA010B</strong> 个元素的值为 <strong>0X0F70AAA0</strong>，它的高 <strong>20</strong> 位为 <strong>0X0F70A</strong>，那么就可以确定数据位于第 <strong>0X0F70A</strong> 个物理页面。再来看虚拟地址，它的低 <strong>12</strong> 位是 0XA01，所以页内偏移也是 <strong>0XA01</strong>。有了页面索引和页内偏移，就可以算出物理地址了。经过计算，最终的物理地址为 <code>0X0F70A * 2^12 + 0XA01 = 0X0F70A000 + 0XA01 = 0X0F70AA01</code>。</p>
<p>这种思路所形成的映射关系如下图所示：</p>
<p><img src="/../image/c_pic/%E5%9B%BE13.4.png" srcset="/img/loading.gif" lazyload></p>
<p>可以发现，有的页被映射到物理内存，有的被映射到硬盘，不同的映射方式可以由页表数组元素的低 <strong>12</strong> 位来控制。</p>
<p>使用这种方案，不管程序占用多大的内存，都要为页表数组分配 <strong>4M</strong> 的内存空间（页表数组也必须放在物理内存中），因为虚拟地址空间中的高 <strong>1G</strong> 或 <strong>2G</strong> 是被系统占用的，必须保证较大的数组下标有效。</p>
<p>现在硬件很便宜了，内存容量大了，很多电脑都配备 <strong>4G</strong> 或 <strong>8G</strong> 的内存，页表数组占用 <strong>4M</strong> 内存或许不觉得多，但在 <strong>32</strong> 位系统刚刚发布的时候，内存还是很紧缺的资源，很多电脑才配备 <strong>100M</strong> 甚至几十兆的内存，<strong>4M</strong> 内存就显得有点大了，所以还得对上面的方案进行改进，压缩页表数组所占用的内存。</p>
<h3 id="5-3-使用两级页表"><a href="#5-3-使用两级页表" class="headerlink" title="5.3 使用两级页表"></a>5.3 使用两级页表</h3><p>上面的页表共有 <strong>2^20 &#x3D; 2^10 * 2^10</strong> 个元素，为了压缩页表的存储空间，可以将上面的页表分拆成 <strong>2^10 &#x3D; 1K &#x3D; 1024</strong> 个小的页表，这样每个页表只包含 <strong>2^10 &#x3D; 1K &#x3D; 1024</strong> 个元素，占用 <strong>2^10 * 4 &#x3D; 4KB</strong> 的内存，也即一个页面的大小。这 <strong>1024</strong> 个小的页表，可以存储在不同的物理页，它们之间可以是不连续的。</p>
<p>那么问题来了，既然这些小的页表分散存储，位于不同的物理页，该如何定位它们呢？也就是如何记录它们的编号（也即在物理内存中位于第几个页面）。</p>
<p><strong>1024</strong> 个页表有 <strong>1024</strong> 个索引，所以不能用一个指针指向它们，必须将这些索引再保存到一个额外的数组中。这个额外的数组有 <strong>1024</strong> 个元素，每个元素记录一个页表所在物理页的编号，长度为 <strong>4</strong> 个字节，总共占用 <strong>4KB</strong> 的内存。将这个额外的数组称为页目录（<strong>Page Directory</strong>），因为它的每一个元素对应一个页表。</p>
<p>如此，只要使用一个指针来记住页目录的地址即可，等到进行地址转换时，可以根据这个指针找到页目录，再根据页目录找到页表，最后找到物理地址，前后共经过 <strong>3</strong> 次间接转换。</p>
<p>那么，如何根据虚拟地址找到页目录和页表中相应的元素呢？不妨将虚拟地址分割为三分部，高 <strong>10</strong> 位作为页目录中元素的下标，中间 <strong>10</strong> 位作为页表中元素的下标，最后 <strong>12</strong> 位作为页内偏移，如下图所示：</p>
<p><img src="/../image/c_pic/%E5%9B%BE13.5.png" srcset="/img/loading.gif" lazyload></p>
<p>知道了物理页的索引和页内偏移就可以转换为物理地址了，在这种方案中，页内偏移可以从虚拟地址的低 <strong>12</strong> 位得到，但是物理页索引却保存在 <strong>1024</strong> 个分散的小页表中，所以就必须先根据页目录找到对应的页表，再根据页表找到物理页索引。</p>
<p>例如一个虚拟地址 <strong>0011000101  1010001100  111100001010</strong>，它的高10位为 <strong>0011000101</strong>，对应页目录中的第 <strong>0011000101</strong> 个元素，假设该元素的高 <strong>20</strong> 位为 <strong>0XF012A</strong>，也即对应的页表在物理内存中的编号为 <strong>0XF012A</strong>，这样就找到了页表。虚拟地址中间 <strong>10</strong> 位为 <strong>1010001100</strong>，它对应页表中的第 <strong>1010001100</strong> 个元素，假设该元素的高 <strong>20</strong> 位为 <strong>0X00D20</strong>，也即物理页的索引为 <strong>0X00D20</strong>。通过计算，最终的物理地址为 <code>0X00D20 * 2^12 + 111100001010 = 0X00D20F0A</code>。</p>
<p>这种思路所形成的映射关系如下图所示：</p>
<p><img src="/../image/c_pic/%E5%9B%BE13.6.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>图中的点状虚线说明了最终的映射关系。图中没有考虑映射到硬盘的情况。</p>
</blockquote>
<p>采用这样的两级页表的一个明显优点是，如果程序占用的内存较少，分散的小页表的个数就会远远少于 <strong>1024</strong> 个，只会占用很少的一部分存储空间（远远小于<strong>4M</strong>）。</p>
<p>在极少数的情况下，程序占用的内存非常大，布满了 <strong>4G</strong> 的虚拟地址空间，这样小页表的数量可能接近甚至等于 <strong>1024</strong>，再加上页目录占用的存储空间，总共是 <strong>4MB+4KB</strong>，比上面使用一级页表的方案仅仅多出 <strong>4KB</strong> 的内存。这是可以容忍的，因为很少出现如此极端的情况。</p>
<p>也就是说，使用两级页表后，页表占用的内存空间不固定，它和程序本身占用的内存空间成正比，从整体上来看，会比使用一级页表占用的内存少得多。</p>
<h3 id="5-4使用多级页表"><a href="#5-4使用多级页表" class="headerlink" title="5.4使用多级页表"></a>5.4使用多级页表</h3><p>对于 <strong>64</strong> 位环境，虚拟地址空间达到 <strong>256TB</strong>，使用二级页表占用的存储空间依然不小，所以会更加细化，从而使用三级页表甚至多级页表，这样就会有多个页目录，虚拟地址也会被分割成多个部分，思路和上面是一样。</p>
<h2 id="6-内存对齐"><a href="#6-内存对齐" class="headerlink" title="6 内存对齐"></a>6 内存对齐</h2><p>计算机内存是以字节（<strong>Byte</strong>）为单位划分的，理论上 <strong>CPU</strong> 可以访问任意编号的字节，但实际情况并非如此。</p>
<p><strong>CPU</strong> 通过地址总线来访问内存，一次能处理几个字节的数据，就命令地址总线读取几个字节的数据。<strong>32</strong> 位的 <strong>CPU</strong> 一次可以处理 <strong>4</strong> 个字节的数据，那么每次就从内存读取 <strong>4</strong> 个字节的数据；少了浪费主频，多了没有用。<strong>64</strong> 位的处理器也是这个道理，每次读取8个字节。</p>
<p>以 <strong>32</strong> 位的 <strong>CPU</strong> 为例，实际寻址的步长为 <strong>4</strong> 个字节，也就是只对编号为 <strong>4</strong> 的倍数的内存寻址，例如 <strong>0、4、8、12、1000</strong> 等，而不会对编号为 <strong>1、3、11、1001</strong> 的内存寻址。</p>
<p><img src="/../image/c_pic/%E5%9B%BE5.1.png" srcset="/img/loading.gif" lazyload></p>
<p>这样做可以以最快的速度寻址：不遗漏一个字节，也不重复对一个字节寻址。</p>
<p>对程序来说，一个变量最好位于一个寻址步长的范围内，这样一次就可以读取到变量的值；如果跨步长存储，就需要读取两次，然后再拼接数据，效率显然降低。</p>
<p>例如一个 <strong>int</strong> 类型的数据，如果地址为 <strong>8</strong>，那么很好办，对编号为 <strong>8</strong> 的内存寻址一次就可以。如果编号为 <strong>10</strong>，就比较麻烦，<strong>CPU</strong> 需要先对编号为 <strong>8</strong> 的内存寻址，读取 <strong>4</strong> 个字节，得到该数据的前半部分，然后再对编号为 <strong>12</strong> 的内存寻址，读取 <strong>4</strong> 个字节，得到该数据的后半部分，再将这两部分拼接起来，才能取得数据的值。</p>
<p>将一个数据尽量放在一个步长之内，避免跨步长存储，这称为内存对齐。在 <strong>32</strong> 位编译模式下，默认以 <strong>4</strong> 字节对齐；在 <strong>64</strong> 位编译模式下，默认以 <strong>8</strong> 字节对齐。</p>
<p>为了提高存取效率，编译器会自动进行内存对齐，请看下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-type">int</span> a;<br>	<span class="hljs-type">char</span> b;<br>	<span class="hljs-type">int</span> c;<br>&#125;t = &#123;<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-number">20</span>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;length:%d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(t));<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;a: %x\n&amp;b:%x\n&amp;c:%x\n&quot;</span>, &amp;t.a, &amp;t.b, &amp;t.c);<br>	system(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 输出结果 */</span><br>length:<span class="hljs-number">12</span><br>&amp;a:<span class="hljs-number">847</span>dc050<br>&amp;b:<span class="hljs-number">847</span>dc054<br>&amp;c:<span class="hljs-number">847</span>dc058<br></code></pre></td></tr></table></figure>

<p>如果不考虑内存对齐，结构体变量 t 所占内存应该为 <code>4+1+4=9</code> 个字节。考虑到内存对齐，虽然成员 <strong>b</strong> 只占用1个字节，但它所在的寻址步长内还剩下 <strong>3</strong> 个字节的空间，放不下一个 <strong>int</strong> 型的变量了，所以要把成员 <strong>c</strong> 放到下一个寻址步长。剩下的这 <strong>3</strong> 个字节，作为内存填充浪费掉了。</p>
<img src="../image/c_pic/图5.2.png" srcset="/img/loading.gif" lazyload alt="图3.2" style="zoom: 50%;" />

<ul>
<li>编译器之所以要内存对齐，是为了更加高效的存取成员 <strong>c</strong>，而代价就是浪费了 3 个字节的空间。</li>
</ul>
<p>除了结构体，变量也会进行内存对齐。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-type">int</span> m;<br>	<span class="hljs-type">char</span> c;<br>	<span class="hljs-type">int</span> n;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;m:%x\n&amp;c:%x\n&amp;n:%x\n&quot;</span>, &amp;m, &amp;c, &amp;n);<br>	system(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 输出结果 */</span><br>&amp;m:cc35f9b4<br>&amp;c:cc35f9d4<br>&amp;n:cc35f9f4<br></code></pre></td></tr></table></figure>

<ul>
<li>地址都是 <strong>4</strong> 的整数倍，并相互挨着。</li>
</ul>
<h3 id="6-1-改变对齐方式"><a href="#6-1-改变对齐方式" class="headerlink" title="6.1 改变对齐方式"></a>6.1 改变对齐方式</h3><p>对齐方式可以通过编译器参数修改。</p>
<ul>
<li>内存对齐虽然和硬件有关，但是决定对齐方式的是编译器，如果硬件是 <strong>64</strong> 位的，却以 <strong>32</strong> 位的方式编译，那么还是会按照 <strong>4</strong> 个字节对齐。</li>
</ul>
<h2 id="7-栈的定义和栈溢出"><a href="#7-栈的定义和栈溢出" class="headerlink" title="7 栈的定义和栈溢出"></a>7 栈的定义和栈溢出</h2><p>程序的虚拟地址空间分为多个区域，栈（<strong>Stack</strong>）是其中地址较高的一个区域。栈（<strong>Stack</strong>）可以存放函数参数、局部变量、局部数组等作用范围在函数内部的数据，它的用途就是完成函数的调用。</p>
<p>栈内存由系统自动分配和释放：发生函数调用时就为函数运行时用到的数据分配内存，函数调用结束后就将之前分配的内存全部销毁。所以局部变量、参数只在当前函数中有效，不能传递到函数外部。</p>
<h3 id="7-1-栈的概念"><a href="#7-1-栈的概念" class="headerlink" title="7.1 栈的概念"></a>7.1 栈的概念</h3><p>在计算机中，栈可以理解为一个特殊的容器，用户可以将数据依次放入栈中，然后再将数据按照相反的顺序从栈中取出。也就是说，先放入的数据最后才能取出，而最后放入的数据必须先取出。这称为先进后出（<strong>First In Last Out</strong>）原则。</p>
<p>放入数据常称为入栈或压栈（<strong>Push</strong>），取出数据常称为出栈或弹出（<strong>Pop</strong>）。如下图所示：</p>
<p><img src="/../image/c_pic/%E5%9B%BE6.1.png" srcset="/img/loading.gif" lazyload></p>
<p>可以发现，栈底始终不动，出栈入栈只是在移动栈顶，当栈中没有数据时，栈顶和栈底重合。</p>
<blockquote>
<p>从本质上来讲，栈是一段连续的内存，需要同时记录栈底和栈顶，才能对当前的栈进行定位。在现代计算机中，通常使用 <strong>ebp</strong> 寄存器指向栈底，而使用 <strong>esp</strong> 寄存器指向栈顶。随着数据的进栈出栈，<strong>esp</strong> 的值会不断变化，进栈时 <strong>esp</strong> 的值减小，出栈时 <strong>esp</strong> 的值增大。</p>
</blockquote>
<p><strong>ebp</strong> 和 <strong>esp</strong> 都是 <strong>CPU</strong> 中的寄存器：<strong>ebp</strong> 是 <strong>Extend Base Pointer</strong> 的缩写，通常用来指向栈底；<strong>esp</strong> 是 <strong>Extend Stack Pointer</strong> 的缩写，通常用来指向栈顶。<br>如下图所示是一个栈的实例：</p>
<p><img src="/../image/c_pic/%E5%9B%BE6.2.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="7-2-栈的大小以及栈溢出"><a href="#7-2-栈的大小以及栈溢出" class="headerlink" title="7.2 栈的大小以及栈溢出"></a>7.2 栈的大小以及栈溢出</h3><p>对每个程序来说，栈能使用的内存是有限的，一般是 <strong>1M~8M</strong>，这在编译时就已经决定了，程序运行期间不能再改变。如果程序使用的栈内存超出最大值，就会发生栈溢出（<strong>Stack Overflow</strong>）错误。</p>
<blockquote>
<p>一个程序可以包含多个线程，每个线程都有自己的栈，严格来说，栈的最大值是针对线程来说的，而不是针对程序。</p>
</blockquote>
<p>栈内存的大小和编译器有关，编译器会为栈内存指定一个最大值，在 <strong>VC&#x2F;VS</strong> 下，默认是 <strong>1M</strong>，在 <strong>C-Free</strong> 下，默认是 <strong>2M</strong>，在 <strong>Linux GCC</strong> 下，默认是 <strong>8M</strong>。</p>
<p>当程序使用的栈内存大于默认值（或者修改后的值）时，就会发生栈溢出（<strong>Stack Overflow</strong>）错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">char</span> str[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="8-栈溢出攻击的原理"><a href="#8-栈溢出攻击的原理" class="headerlink" title="8 栈溢出攻击的原理"></a>8 栈溢出攻击的原理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>	<span class="hljs-type">char</span> str[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    gets(str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str:%s\n&quot;</span>, str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 <code>main()</code> 函数内部定义一个字符数组，并通过 <code>gets()</code> 为它赋值。</p>
<p>在 <strong>VS2010 Debug</strong> 模式下运行程序，当输入的字符不超过 <strong>10</strong> 个时，可以正确输出，但是当输入的字符过多时，就会出现运行时错误。例如输入 <code>&quot;12345678901234567890&quot;</code>，就会出现下面的错误：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">❌Time check failure.Stack around the variable <span class="hljs-string">&#x27;str&#x27;</span> was corrupted.<br></code></pre></td></tr></table></figure>

<ul>
<li><code>main()</code> 函数的栈:</li>
</ul>
<p><img src="/../image/c_pic/%E5%9B%BE7.2.png" srcset="/img/loading.gif" lazyload></p>
<p>局部数组也是在栈上分配内存，当输入 <code>&quot;12345678901234567890&quot;</code>  时，会发生数组溢出，占用 <code>“4 字节空白内存”</code>、<code>“old ebp”</code> 和 <code>“返回地址”</code> 所在的内存，并将原有的数据覆盖掉，这样当 <code>main()</code> 函数执行完成后，会取得一个错误的返回地址，该地址上的指令是不确定的，或者根本就没有指令，所以程序在返回时出错。</p>
<p><strong>C</strong> 语言不会对数组溢出做检测，这是一个典型的由于数组溢出导致覆盖了函数返回地址的例子，将这样的错误称为 <code>“栈溢出错误”</code>。</p>
<blockquote>
<p>注意：这里所说的 <code>“栈溢出”</code> 是指栈上的某个数据过大，覆盖了其他的数据<br>局部数组在栈上分配内存，并且不对数组溢出做检测，这是导致栈溢出的根源。除了上面讲到的 <code>gets()</code> 函数，<code>strcpy()</code>、<code>scanf()</code> 等能够向数组写入数据的函数都有导致栈溢出的风险。</p>
</blockquote>
<p>下面是使用 <code>strcpy()</code> 函数导致栈溢出的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">char</span> *str1 = <span class="hljs-string">&quot;梓语慕晓梓语慕晓&quot;</span>;<br>    <span class="hljs-type">char</span> str2[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">strcpy</span>(str2, str1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str:%s\n&quot;</span>, str2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将 <strong>str1</strong> 复制到 <strong>str2</strong>，显然超出了 <strong>str2</strong> 的接受范围，会发生溢出，覆盖返回地址，导致 <code>main()</code> 函数返回时出错。</p>
<p>栈溢出一般不会产生严重的后果，但是如果有用户精心构造栈溢出，让返回地址指向恶意代码，那就比较危险了，这就是常说的栈溢出攻击。</p>
<h2 id="9-动态内存分配"><a href="#9-动态内存分配" class="headerlink" title="9 动态内存分配"></a>9 动态内存分配</h2><p>在进程的地址空间中，代码区、常量区、全局数据区的内存在程序启动时就已经分配好了，它们大小固定，不能由程序员分配和释放，只能等到程序运行结束由操作系统回收。这称为<strong>静态内存分配</strong>。</p>
<p>栈区和堆区的内存在程序运行期间可以根据实际需求来分配和释放，不用在程序刚启动时就备足所有内存。这称为<strong>动态内存分配</strong>。</p>
<p>使用静态内存的优点是速度快，省去了向操作系统申请内存的时间，缺点就是不灵活，缺乏表现力，例如不能控制数据的作用范围，不能使用较大的内存。而使用动态内存可以让程序对内存的管理更加灵活和高效，需要内存就立即分配，而且需要多少就分配多少，从几个字节到几个 <strong>GB</strong> 不等；不需要时就立即回收，再分配给其他程序使用。</p>
<h3 id="9-1-栈和堆的区别"><a href="#9-1-栈和堆的区别" class="headerlink" title="9.1 栈和堆的区别"></a>9.1 栈和堆的区别</h3><p>栈区和堆区的管理模式有所不同：栈区内存由系统分配和释放，不受程序员控制；堆区内存完全由程序员掌控，想分配多少就分配多少，想什么时候释放就什么时候释放，非常灵活。</p>
<p>程序启动时会为栈区分配一块大小适当的内存，对于一般的函数调用这已经足够了，函数进栈出栈只是 <strong>ebp</strong>、<strong>esp</strong> 寄存器指向的变换，或者是向已有的内存中写入数据，不涉及内存的分配和释放。当函数中有较大的局部数组时，比如 <code>1024*10</code> 个元素，编译器就会在函数代码中插入针对栈的动态内存分配函数，这样函数被调用时才分配内存，不调用就不分配。</p>
<p>经常听说 <code>“栈内存的分配效率要高于堆”</code> 就是这个道理，因为大部分情况下并没有真的分配栈内存，仅仅是对已有内存的操作。</p>
<h3 id="9-2-动态内存分配函数"><a href="#9-2-动态内存分配函数" class="headerlink" title="9.2 动态内存分配函数"></a>9.2 动态内存分配函数</h3><p>堆（<strong>Heap</strong>）是唯一由程序员控制的内存区域，常说的动态内存分配也是在这个区域。在堆上分配和释放内存需要用到C语言标准库中的几个函数：<code>void指针</code>、<code>malloc()</code>、<code>free()</code>、<code>calloc()</code>、<code>realloc()</code>、<code>restrict 说明符</code>、<code>memcpy()</code>、<code>memmove()</code>、<code>memcmp()</code>。</p>
<h4 id="9-2-1-void-指针"><a href="#9-2-1-void-指针" class="headerlink" title="9.2.1 void 指针"></a>9.2.1 void 指针</h4><p>C语言提供了一种不定类型的指针：void 指针。它只有内存块的地址信息，没有类型信息，等到使用该块内存时，再向编译器补充说明其数据类型。</p>
<p>另一方面，void 指针等同于无类型指针，可以指向任意类型的数据，但不能解读数据。void 指针与其他所有类型指针之间都是互相转换关系，任一类型指针都可以转为 void 指针，void 指针也可以转为任一类型指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br><br><span class="hljs-type">void</span>* p = &amp;x;	<span class="hljs-comment">// 整数指针转为 void 指针</span><br><span class="hljs-type">int</span>* q = p;		<span class="hljs-comment">// void 指针转为整数指针</span><br></code></pre></td></tr></table></figure>

<p>上面示例演示了，整数指针和 void 指针互相转换过程。 <code>&amp;x</code> 是一个整数指针，<code>p</code>是 void 指针，赋值时 <code>&amp;x</code> 的地址会自动改解释为 void 类型。同样 <code>p</code> 再赋值给整数指针 <code>q</code> 时，<code>p</code> 的地址会自动解释为整数指针。</p>
<p>注意，由于不知道 void 指针指向什么类型的值，所以不能用 <code>*</code> 运算符取出它指向的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> a = <span class="hljs-string">&#x27;X&#x27;</span>;<br><span class="hljs-type">void</span>* p = &amp;a;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, *p);		<span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure>

<p>上面示例中，<code>p</code> 是一个 void 指针，所以这时无法用 <code>*p</code> 取出指针指向的值。</p>
<p>void 指针的重要之处在于，很多内存相关函数的返回值就是 void 指针，只给出内存块的地址信息。</p>
<h4 id="9-2-2-malloc"><a href="#9-2-2-malloc" class="headerlink" title="9.2.2 malloc()"></a>9.2.2 malloc()</h4><p><code>malloc()</code> 函数用于分配内存，该函数向系统要求一段内存，系统就在“堆”里面分配一段连续的内存块给它，它的原型定义在头文件 <code>stdlib.h</code>。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在堆区分配 size 字节的内存空间。</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">malloc</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure>

<p>它接受一个非负整数作为参数，表示所要分配的内存字节数，返回一个 void 指针，指向分配好的内存块。因为 <code>malloc()</code> 函数不知道，将要存储在该块内存的数据是什么类型，所以只能返回一个无类型的 void 指针。</p>
<p>可以使用 <code>malloc()</code> 为任意类型的数据分配内存，常见做法是先使用 <code>sizeof()</code> 函数，算出某种数据类型所需的字节长度，然后再讲这个长度传给 <code>malloc()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><br>*p = <span class="hljs-number">12</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, *p);	<span class="hljs-comment">// 12</span><br></code></pre></td></tr></table></figure>

<p>上述示例中，先为整数类型分配一段内存，然后将整数 <code>12</code> 放入这段内存里面。这个例子其实不需要使用 <code>malloc()</code>，因为 C 语言会自动为整数提供内存。</p>
<p>有时为了增加代码的可读性，可以对 <code>malloc()</code> 返回的指针进行一次强制类型转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br></code></pre></td></tr></table></figure>

<p>上述代码将 <code>malloc()</code> 返回的 void 指针，强制转换成了整数指针。由于 <code>sizeof()</code> 的参数可以是变量，所以上面的例子也可以写成下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*p))<br></code></pre></td></tr></table></figure>

<p><code>malloc()</code> 分配内存有可能失败，这是返回常量 <code>NULL</code>。<code>NULL</code> 的值为0，是一个无法读写的内存地址，可以理解成一个不指向任何地方的指针。它在包括 <code>stdlib.h</code> 等多个头文件里面都有定义，所以只要可以使用 <code>malloc()</code>，就可以使用 <code>NULL</code>。由于存在分配失败的可能，所以最好在使用 <code>malloc()</code> 之后检查下，是否分配成功。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><br><span class="hljs-keyword">if</span>(p == Null)&#123;<br>	<span class="hljs-comment">// 内存分配失败</span><br>&#125;<br><br><span class="hljs-comment">// or</span><br><span class="hljs-keyword">if</span>(!p)&#123;<br>	<span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面示例中，通过判断返回的指针 <code>p</code> 是否为 <code>Null</code>，确认 <code>malloc()</code> 是否分配成功。</p>
<p><code>malloc()</code> 最常见的场合，就是为数组和自定义数据结构分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>	p[i] = i * <span class="hljs-number">5</span>;<br>&#125;<br>````<br><br>上面示例中，`p` 是一个整数指针，指向一段可以放置<span class="hljs-number">10</span>个整数的内存，所以可以用作数组。<br><br>`<span class="hljs-built_in">malloc</span>()` 用来创建数组，有一个好处，就是可以创建动态数组，即根据成员数量的不同，而创建长度不同的数组。<br><br>```c<br><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br></code></pre></td></tr></table></figure>

<p>上面示例中，<code>malloc()</code> 可以根据变量 <code>n</code> 的不同，动态为数组分配不同的大小。</p>
<p>注意，<code>malloc()</code> 不会对所分配的内存进行初始化，里面还保存着原来的值。如果没有初始化，就是用这段内存，可能从里面读到以前的值。程序员要自己负责初始化。比如，字符串初始化可以使用 <code>strcpy()</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">4</span>);<br><span class="hljs-built_in">strcpy</span>(p, <span class="hljs-string">&quot;abc&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>上面示例中，字符指针 <code>p</code> 指向一段4个字节的内存，<code>strcpy()</code> 将字符串 <code>&quot;abc&quot;</code> 拷贝放入这段内存，完成了这段内存的初始化。</p>
<h4 id="9-2-3-free"><a href="#9-2-3-free" class="headerlink" title="9.2.3 free()"></a>9.2.3 <code>free()</code></h4><p><code>free()</code> 用于释放 <code>malloc()</code> 函数分配的内存，将这块内存还给系统以便重新使用，否则这个内存块会一直占用到程序运行结束。该函数的原型定义在头文件 <code>stdlib.h</code> 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span>;<br></code></pre></td></tr></table></figure>

<p>功能：释放由 <code>malloc()、calloc()、realloc()</code> 申请的内存空间。</p>
<ul>
<li>几点注意：<ul>
<li>每个内存分配函数必须有相应的 <strong>free</strong> 函数，释放后不能再次使用被释放的内存。</li>
<li>在分配内存时最好不要直接用数字指定内存空间的大小，这样不利于程序的移植。因为在不同的操作系统中，同一数据类型的长度可能不一样。为了解决这个问题，<strong>C</strong> 语言提供了一个判断数据类型长度的操作符，就是 <strong>sizeof</strong>。</li>
<li><code>free(p)</code> 并不能改变指针 <strong>p</strong> 的值，<strong>p</strong> 依然指向以前的内存，为了防止再次使用该内存，建议将 <strong>p</strong> 的值手动置为 <strong>NULL</strong>。</li>
</ul>
</li>
</ul>
<p>上述代码中，<code>free()</code> 的参数是 <code>malloc()</code> 返回的内存地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><br>*p = <span class="hljs-number">12</span>;<br><span class="hljs-built_in">free</span>(p);<br></code></pre></td></tr></table></figure>

<p>注意，分配的内存块一旦释放，就不应该再次操作已经释放的地址，也不应该再次使用 <code>free()</code> 对该地址释放第二次。</p>
<p>一个很常见的错误是，在函数内部分配了内存，但是函数调用结束时，没有使用 <code>free()</code> 释放内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">gobble</span><span class="hljs-params">(<span class="hljs-type">double</span> arr[], <span class="hljs-type">int</span> n)</span>&#123;<br>	<span class="hljs-type">double</span>* temp = (<span class="hljs-type">double</span>*)<span class="hljs-built_in">malloc</span>(n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>));<br>	<span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面示例中，函数 <code>gobble()</code> 内部分配了内存，但是没有写 <code>free(temp)</code>。这会造成函数运行结束后，占用的内存块依然保留，如果多次调用 <code>gobble()</code>，就会留下多个内存块。并且，由于指针 <code>temp</code> 已经消失了，也无法访问这些内存块，再次使用。</p>
<p><strong>sizeof</strong> 是一个单目操作符，不是函数，用以获取数据类型的长度时必须加括号，例如 <code>sizeof(int)、sizeof(char)</code> 等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N  5</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N1 7</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N2 3 </span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>	<span class="hljs-type">int</span> *ip;<br>    <span class="hljs-type">int</span> *large_ip;<br>    <span class="hljs-type">int</span> *small_ip<span class="hljs-number">&#x27;</span><br>    <span class="hljs-keyword">if</span>((ip = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(N * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))) == <span class="hljs-literal">NULL</span>)    <span class="hljs-comment">//if-else</span><br>    &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;memory allocated failed!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;  <br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    &#123;<br>		ip[i] = i;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ip[%d] = %d\t&quot;</span>, i, ip[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span>((large_ip = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">realloc</span>(ip, N1 * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))) == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;memory allocated failed!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i = N; i &lt; N1; i++)<br>    	large_ip[i] = <span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N1; i++)<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;large_ip[%d] = %d\t&quot;</span>, i, large_ip[i]);<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);   <br>    <br>    <span class="hljs-keyword">if</span>((small_ip = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">realloc</span>(large_ip, N2 * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))) == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;memory allocated failed!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; N2; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;small_ip[%d] = %d\t&quot;</span>, i, small_ip[i]);<br> 	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);   <br>	<span class="hljs-built_in">free</span>(small_ip);<br>    small_ip = <span class="hljs-literal">NULL</span>;<br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;	<br><span class="hljs-comment">/* 输出结果 */</span><br>ip[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>    ip[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>    ip[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>    ip[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>    ip[<span class="hljs-number">4</span>] = <span class="hljs-number">4</span><br>large_ip[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>    large_ip[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>    large_ip[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>    large_ip[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>    large_ip[<span class="hljs-number">4</span>] = <span class="hljs-number">4</span>    large_ip[<span class="hljs-number">5</span>] = <span class="hljs-number">9</span>    large_ip[<span class="hljs-number">6</span>] = <span class="hljs-number">9</span><br>small_ip[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>    small_ip[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>    small_ip[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<ul>
<li>首先分配一个包含 <strong>5</strong> 个整型的内存区域，分别赋值 <strong>0</strong> 到 <strong>4</strong>；再用 <strong>realloc</strong> 函数扩大内存区域以容纳 <strong>7</strong> 个整型数，对额外的两个整数赋值为 <strong>9</strong>；最后再用 **realloc **函数缩小内存区域，直接输出结果（因为 <strong>realloc</strong> 函数会自动复制数据）。</li>
<li>这次把分配函数与验证返回值验证写在了一起，为的是书写方便，考虑到优先级问题添加了适当的括号，这种写法较为常用，注意学习使用。</li>
<li>本例 <strong>free</strong> 函数只用释放 <strong>small_ip</strong> 指针即可，如函数介绍中注意里提到的，另外两个指针已被系统回收，不能再次使用。</li>
</ul>
<h4 id="9-2-4-calloc"><a href="#9-2-4-calloc" class="headerlink" title="9.2.4 calloc()"></a>9.2.4 <code>calloc()</code></h4><p><code>calloc()</code> 函数作用与 <code>malloc()</code> 相似，也是分配内存块。该函数原型定义在头文件 <code>stdlib.h</code>。<code>calloc()</code> 函数是对 <code>malloc()</code> 函数的简单封装，参数不同，使用时务必小心，第一参数是第二参数的单元个数，第二参数是单位的字节数。</p>
<p>两者的区别主要有两点：</p>
<p>（1）<code>calloc()</code> 接受两个参数，第一个参数是某种数据类型的值的数量，第二个参数是该数据类型的单位字节长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">calloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure>

<p>功能：在堆区分配 <code>n*size</code> 字节的连续空间。</p>
<p>返回值：成功返回分配的内存地址 void 指针，失败则返回 <strong>NULL</strong>。</p>
<p>（2）<code>calloc()</code> 会将所分配的内存全部初始化为 <code>0</code>。<code>malloc()</code> 不会对内存进行初始化，如果想要初始化为 <code>0</code>，还要额外调用 <code>memset()</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">10</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">10</span>);<br><span class="hljs-built_in">memset</span>(p, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>

<p>上面示例中，<code>calloc()</code> 相当于 <code>malloc() + memset()</code>。<code>calloc()</code> 分配的内存块，也要使用 <code>free()</code> 释放。</p>
<h4 id="9-2-5-realloc"><a href="#9-2-5-realloc" class="headerlink" title="9.2.5 realloc()"></a>9.2.5 <code>realloc()</code></h4><p><code>realloc()</code> 函数用于修改已经分配的内存块的大小，可以放大也可以缩小，返回一个指向新的内存块的指针。如果分配不成功，返回 <code>NULL</code>，该函数原型定义在头文件 <code>stdlib.h</code> 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> *block, <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure>

<p>它接受两个参数。</p>
<ul>
<li><code>block</code>：已经分配好的内存块指针（由 <code>malloc()</code> 或 <code>calloc()</code> 或 <code>realloc()</code> 产生）。</li>
<li><code>size</code>：该内存块的新大小，单位为字节。</li>
</ul>
<p><code>realloc()</code> 可能返回一个全新的地址（数据也会自动复制过去），也可能返回跟原来一样的地址。<code>realloc()</code> 优先在原有内存块上进行缩减，尽量不移动数据，所以通常是返回原先的地址。如果新内存块小于原来的大小，则丢弃超出的部分；如果大于原来的大小，则不对新增的部分进行初始化（程序员可以自动调用 <code>memset()</code>）。</p>
<p>下面示例中，<code>b</code> 是数组指针，<code>realloc()</code> 动态调整它的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* b;<br>b = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">100</span>);<br>b = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">realloc</span>(b, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure>

<p>上面示例中，指针 <code>b</code> 原来指向100个成员的整数数组，使用 <code>realloc()</code> 调整为2000个成员的数组，这就是手动分配数组内存的好处，就可以在运行时随时调整数组的长度。</p>
<p><code>realloc()</code> 第一个参数可以是 <code>NULL</code>，这时相当于新建一个指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* p = <span class="hljs-built_in">realloc</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">3490</span>);<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-type">char</span>* p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">3490</span>);<br></code></pre></td></tr></table></figure>

<p>如果 <code>realloc()</code> 第二个参数是 <code>0</code>，就会释放掉内存块。由于有分配失败的可能，所以调用 <code>realloc()</code> 以后，最好检查返回值是否为 <code>NULL</code>。分配失败时，原有内存块中的数据不会发生变化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span>* new_p = <span class="hljs-built_in">realloc</span>(p, <span class="hljs-keyword">sizeof</span>(*p * <span class="hljs-number">40</span>));<br><br><span class="hljs-keyword">if</span>(new_p == <span class="hljs-literal">NULL</span>)&#123;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR\n&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：<code>realloc()</code> 不会对内存进行初始化。</p>
<h4 id="9-2-6-restrict-说明符"><a href="#9-2-6-restrict-说明符" class="headerlink" title="9.2.6 restrict 说明符"></a>9.2.6 restrict 说明符</h4><p>声明指针变量时。可以使用 <code>restrict</code> 说明符，告诉编译器，该块内存区域只有当前指针一种访问方式，其他指针不能读写该块内存。这种指针称为“受限指针”（restrict pointer）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* <span class="hljs-keyword">restrict</span> p;<br>p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br></code></pre></td></tr></table></figure>

<p>上面示例中，声明指针变量 <code>p</code> 时，加入了 <code>restrict</code> 说明符，使得 <code>p</code> 变成了受限指针。后面，当 <code>p</code> 指向 <code>malloc()</code> 函数返回的一块内存区域，就意味着，该区域只有通过 <code>p</code> 来访问，不存在其他访问方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* <span class="hljs-keyword">restrict</span> p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-type">int</span>* q = p;<br>*p = <span class="hljs-number">0</span>;		<span class="hljs-comment">// 未定义行为</span><br></code></pre></td></tr></table></figure>

<p>上面示例中，另一个指针 <code>q</code> 与受限指针 <code>p</code> 指向同一块内存，现在该内存有 <code>p</code> 和 <code>q</code> 两种访问方式。这就违反了对编译器的承诺，后面通过 <code>*q</code> 对该内存区域赋值，会导致未定义行为。</p>
<h4 id="9-2-7-memcpy"><a href="#9-2-7-memcpy" class="headerlink" title="9.2.7 memcpy()"></a>9.2.7 <code>memcpy()</code></h4><p><code>memcpy()</code> 用于将一块内存拷贝到另一块内存，该函数的原型定义在头文件 <code>string.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">memcpy</span><span class="hljs-params">(</span><br><span class="hljs-params">	<span class="hljs-type">void</span>* <span class="hljs-keyword">restrict</span> dest,</span><br><span class="hljs-params">	<span class="hljs-type">void</span>* <span class="hljs-keyword">restrict</span> source,</span><br><span class="hljs-params">	<span class="hljs-type">size_t</span> n</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>dest</code> 是目标地址，<code>source</code> 是源地址，第三个参数 <code>n</code> 是要拷贝的字节数 <code>n</code>。如果要拷贝10个 double 类型的数组成员，<code>n</code> 就等于 <code>10 * sizeof(double)</code>，而不是 <code>10</code>。该函数会将从 <code>source</code> 开始的 <code>n</code> 个字节，拷贝到 <code>dest</code>。</p>
<p><code>dest</code> 和 <code>source</code> 都是 void 指针，表示这里不限制指针类型，各种类型的内存数据都可以拷贝。两者都有 restrict 关键字，表示这两个内存块不应该有互相重叠的区域。</p>
<p><code>memcpy()</code> 返回值是第一个参数，即目标地址的指针。</p>
<p>因为 <code>memcpy()</code> 只是将一段内存的值，复制到另一段内存，所以不需要知道内存里面的数据是什么类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>	<span class="hljs-type">char</span> s[] = <span class="hljs-string">&quot;happy&quot;</span>;<br>	<span class="hljs-type">char</span> t[<span class="hljs-number">100</span>];<br>	<br>	<span class="hljs-built_in">memcpy</span>(t, s, <span class="hljs-keyword">sizeof</span>(s)); 	<span class="hljs-comment">// 拷贝6个字节，包括string终止符</span><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, t);			<span class="hljs-comment">// happy</span><br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面示例中，字符串 <code>s</code> 所在的内存，被拷贝到字符数组 <code>t</code> 所在的内存。</p>
<p><code>memcpy()</code> 可以取代 <code>strcpy()</code> 进行字符串拷贝，而且是更好的办法，不仅更安全，速度也更快，不检查字符串尾部的 <code>\0</code> 字符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* s = <span class="hljs-string">&quot;hello world&quot;</span>;<br><br><span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(s) + <span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> *c = <span class="hljs-built_in">malloc</span>(len);<br><br><span class="hljs-keyword">if</span>(c) &#123;<br>	<span class="hljs-comment">// strcpy() 的写法</span><br>	<span class="hljs-built_in">strcpy</span>(c, s);<br><br>	<span class="hljs-comment">// memcpy() 的写法</span><br>	<span class="hljs-built_in">memcpy</span>(c, s, len);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面示例中，两种写法效果完全一样，但是 <code>memcpy()</code> 写法要好于 <code>strcpy()</code>。</p>
<p>使用 void 指针，也可以自定义一个复制内存的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">my_memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span>* dest, <span class="hljs-type">void</span>* src, <span class="hljs-type">int</span> byte_count)</span> &#123;<br>	<span class="hljs-type">char</span>* s = src;<br>	<span class="hljs-type">char</span>* d = dest;<br><br>	<span class="hljs-keyword">while</span>(byte_count--) &#123;<br>		*d++ = *s++;<br>	&#125;<br>	<span class="hljs-keyword">return</span> dest;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面示例中，不管传入的 <code>dest</code> 和 <code>src</code> 是什么类型的指针，将它们重新定义成一字节的 Char 指针，就可以逐字节进行复制。<code>*d++ = *s++</code> 语句相当于先执行 <code>*d = *s</code>（源字节的值复制给目标字节），然后各自移动到下一个字节。最后返回复制后的 <code>dest</code> 指针，便于后续使用。</p>
<h4 id="9-2-8-memmove"><a href="#9-2-8-memmove" class="headerlink" title="9.2.8 memmove()"></a>9.2.8 <code>memmove()</code></h4><p><code>memmove()</code> 函数用于将一段内存数据复制到另一段内存。它跟 <code>memcpy</code> 的主要区别是，它允许目标区域与源区域有重叠。如果发生重叠，源区域的内容会被更改；如果没有重叠，与 <code>memcpy</code> 行为相同。该函数原型定义在 <code>string.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">memmove</span> <span class="hljs-params">(</span><br><span class="hljs-params">	<span class="hljs-type">void</span>* dest,</span><br><span class="hljs-params">	<span class="hljs-type">void</span>* source,</span><br><span class="hljs-params">	<span class="hljs-type">size_t</span> n</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure>

<p>上述代码中，<code>dest</code> 是目标地址，<code>source</code> 是源地址，<code>n</code> 是要移动的字节数。<code>dest</code> 和 <code>source</code> 都是 void 指针，表示可以移动任何类型的内存数据，两个内存区域可以有重叠。<code>memmove</code> 返回值是第一个参数，即目标地址的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>];<br><br>memmove(&amp;a[<span class="hljs-number">0</span>], &amp;a[<span class="hljs-number">1</span>], <span class="hljs-number">99</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br></code></pre></td></tr></table></figure>

<p>上述示例中，从数组成员 a[1] 开始的99个成员，都要向前移动一个位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> x[] = <span class="hljs-string">&quot;Home Sweet Home&quot;</span>;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, memmove(x, &amp;x[<span class="hljs-number">5</span>], <span class="hljs-number">10</span>));	<span class="hljs-comment">// 输出 Sweet Home Home</span><br></code></pre></td></tr></table></figure>

<p>上述示例中，从字符串 <code>x</code> 的5号位置开始的10个字节，就是 <code>&quot;Sweet Home&quot;</code>，<code>memmove()</code> 将其前移到0号位置，所以输出为 <code>&quot;Sweet Home Home&quot;</code>。</p>
<h4 id="9-2-9-memcmp"><a href="#9-2-9-memcmp" class="headerlink" title="9.2.9 memcmp()"></a>9.2.9 <code>memcmp()</code></h4><p><code>memcmp()</code> 函数用来比较两个内存区域，函数原型定义在 <code>string.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">memcmp</span><span class="hljs-params">(</span><br><span class="hljs-params">	<span class="hljs-type">const</span> <span class="hljs-type">void</span>* s1;</span><br><span class="hljs-params">	<span class="hljs-type">const</span> <span class="hljs-type">void</span>* s2;</span><br><span class="hljs-params">	<span class="hljs-type">size_t</span> n</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure>

<p><code>memcmp()</code> 有三个参数，前两个参数是用来比较的指针，第三个参数指定比较的字节数。其返回值是一个整数。</p>
<p>两块内存区域的每个字节以字符形式解读，按照字典顺序进行比较，如果两者相同，返回 <code>0</code>；如果 <code>s1</code> 大于 <code>s2</code>，返回大于0的整数；如果 <code>s1</code> 小于 <code>s2</code>，返回小于0的整数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* s1 = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">char</span>* s2 = <span class="hljs-string">&quot;acd&quot;</span>;<br><span class="hljs-type">int</span> r = <span class="hljs-built_in">memcmp</span>(s1, s2, <span class="hljs-number">3</span>);	<span class="hljs-comment">// 小于 0</span><br></code></pre></td></tr></table></figure>

<p>上述示例中，比较 <code>s1</code> 和 <code>s2</code> 的前三个字节，由于 <code>s1</code> 小于 <code>s2</code>，所以 <code>r</code> 是一个小于0的整数，一般为-1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> s1[] = &#123;<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>&#125;;<br><span class="hljs-type">char</span> s2[] = &#123;<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>&#125;;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">memcmp</span>(s1, s2, <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>)	<span class="hljs-comment">// true</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">memcmp</span>(s1, s2, <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>)	<span class="hljs-comment">// true</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">memcmp</span>(s1, s2, <span class="hljs-number">7</span>) == <span class="hljs-number">0</span>)	<span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p><code>memcmp()</code> 可以比较内部带有字符串终止符 <code>\0</code> 的内存区域。</p>
<h2 id="10-malloc-函数背后的实现原理——内存池"><a href="#10-malloc-函数背后的实现原理——内存池" class="headerlink" title="10 malloc 函数背后的实现原理——内存池"></a>10 malloc 函数背后的实现原理——内存池</h2><p>相对于栈而言，堆这片内存面临着一个稍微复杂的行为模式：在任意时刻，程序可能发出请求，要么申请一段内存，要么释放一段已经申请过的内存，而且申请的大小从几个字节到几个 <strong>GB</strong> 都有可能，不能假设程序一次申请多少堆空间，因此，堆的管理显得较为复杂。</p>
<p>那么，使用 <code>malloc()</code> 在堆上分配内存到底是如何实现的呢？</p>
<p>一种做法是把 <code>malloc()</code> 的内存管理交给系统内核去做，既然内核管理着进程的地址空间，那么如果它提供一个系统调用，可以让 <code>malloc()</code> 使用这个系统调用去申请内存，不就可以了吗？当然这是一种理论上的做法，但实际上这样做的性能比较差，因为每次程序申请或者释放堆空间都要进行系统调用。知道系统调用的性能开销是比较大的，当程序对堆的操作比较频繁时，这样做的结果会严重影响程序的性能。</p>
<p>比较好的做法就是 <code>malloc()</code> 向操作系统申请一块适当大小的堆空间，然后由 <code>malloc()</code> 自己管理这块空间。</p>
<p><code>malloc()</code> 相当于向操作系统“批发”了一块较大的内存空间，然后 “零售” 给程序用。当全部 <code>“售完”</code> 或程序有大量的内存需求时，再根据实际需求向操作系统 <code>“进货”</code>。当然 <code>malloc()</code> 在向程序零售堆空间时，必须管理它批发来的堆空间，不能把同一块地址出售两次，导致地址的冲突。于是 <code>malloc()</code> 需要一个算法来管理堆空间，这个算法就是堆的分配算法。</p>
<p><code>malloc()</code> 和 <code>free()</code> 的分配算法<br>在程序运行过程中，堆内存从低地址向高地址连续分配，随着内存的释放，会出现不连续的空闲区域，如下图所示：</p>
<ul>
<li>已分配内存和空闲内存相间出现</li>
</ul>
<p><img src="/../image/c_pic/%E5%9B%BE9.1.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>带阴影的方框是已被分配的内存，白色方框是空闲内存或已被释放的内存。程序需要内存时，<code>malloc()</code> 首先遍历空闲区域，看是否有大小合适的内存块，如果有，就分配，如果没有，就向操作系统申请（发生系统调用）。为了保证分配给程序的内存的连续性，<code>malloc()</code> 只会在一个空闲区域中分配，而不能将多个空闲区域联合起来。</p>
</blockquote>
<p>内存块（包括已分配和空闲的）的结构类似于链表，它们之间通过指针连接在一起。在实际应用中，一个内存块的结构如下图所示：</p>
<p><img src="/../image/c_pic/%E5%9B%BE9.2.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>next</strong> 是指针，指向下一个内存块，<strong>used</strong> 用来表示当前内存块是否已被使用。这样，整个堆区就会形成如下图所示的链表：</p>
<ul>
<li>类似链表的内存管理方式</li>
</ul>
<p><img src="/../image/c_pic/%E5%9B%BE9.3.png" srcset="/img/loading.gif" lazyload></p>
<p>现在假设需要为程序分配 <strong>100</strong> 个字节的内存，当搜索到图中第一个空闲区域（大小为 <strong>200</strong> 个字节）时，发现满足条件，那么就在这里分配。这时候 <code>malloc()</code> 会把第一个空闲区域拆分成两部分，一部分交给程序使用，剩下的部分任然空闲，如下图所示：</p>
<ul>
<li>为程序分配 <strong>100</strong> 个字节的内存</li>
</ul>
<p><img src="/../image/c_pic/%E5%9B%BE9.4.png" srcset="/img/loading.gif" lazyload></p>
<p>仍然以图 3 为例，当程序释放掉第三个内存块时，就会形成新的空闲区域，<code>free()</code> 会将第二、三、四个连续的空闲区域合并为一个，如下图所示：</p>
<ul>
<li>释放第三个内存块</li>
</ul>
<p><img src="/../image/c_pic/%E5%9B%BE9.5.png" srcset="/img/loading.gif" lazyload></p>
<p>可以看到，<code>malloc()</code> 和 <code>free()</code> 所做的工作主要是对已有内存块的分拆和合并，并没有频繁地向操作系统申请内存，这大大提高了内存分配的效率。</p>
<p>另外，由于单向链表只能向一个方向搜索，在合并或拆分内存块时不方便，所以大部分 <code>malloc()</code> 实现都会在内存块中增加一个 <strong>pre</strong> 指针指向上一个内存块，构成双向链表，如下图所示：</p>
<p><img src="/../image/c_pic/%E5%9B%BE9.6.png" srcset="/img/loading.gif" lazyload></p>
<p>链表是一种经典的堆内存管理方式，经常被用在教学中，很多 <strong>C</strong> 语言教程都会提到“栈内存的分配类似于数据结构中的栈，而堆内存的分配却类似于数据结构中的链表”就是源于此。</p>
<p>链表式内存管理虽然思路简单，容易理解，但存在很多问题，例如：</p>
<ul>
<li><p>一旦链表中的 <strong>pre</strong> 或 <strong>next</strong> 指针被破坏，整个堆就无法工作，而这些数据恰恰很容易被越界读写所接触到。</p>
</li>
<li><p>小的空闲区域往往不容易再次分配，形成很多内存碎片。</p>
</li>
<li><p>经常分配和释放内存会造成链表过长，增加遍历的时间。</p>
</li>
</ul>
<p>针对链表的缺点，后来人们提出了位图和对象池的管理方式，而现在的 <code>malloc()</code> 往往采用多种方式复合而成，不同大小的内存块往往采用不同的措施，以保证内存分配的安全和效率。</p>
<h3 id="10-1-内存池"><a href="#10-1-内存池" class="headerlink" title="10.1 内存池"></a>10.1 内存池</h3><p>不管具体的分配算法是怎样的，为了减少系统调用，减少物理内存碎片，<code>malloc()</code> 的整体思想是先向操作系统申请一块大小适当的内存，然后自己管理，这就是内存池<strong>（Memory Pool）</strong>。</p>
<p>内存池的研究重点不是向操作系统申请内存，而是对已申请到的内存的管理，这涉及到非常复杂的算法，是一个永远也研究不完的课题，除了C标准库自带的 **malloc()**，还有一些第三方的实现，比如 <strong>Goolge</strong> 的 <strong>tcmalloc</strong> 和 <strong>jemalloc</strong>。</p>
<p><strong>C&#x2F;C++</strong> 是编译型语言，没有内存回收机制，程序员需要自己释放不需要的内存，这在给程序带来了很大灵活性的同时，也带来了不少风险，例如<strong>C&#x2F;C++</strong> 程序经常会发生内存泄露，程序刚开始运行时占用内存很少，随着时间的推移，内存使用不断增加，导致整个计算机运行缓慢。</p>
<p>内存泄露的问题往往难于调试和发现，或者只有在特定条件下才会复现，这给代码修改带来了不少障碍。为了提高程序的稳定性和健壮性，后来的 <strong>Java、Python、C#、JavaScript、PHP</strong> 等使用了虚拟机机制的非编译型语言都加入了垃圾内存自动回收机制，这样程序员就不需要管理内存了，系统会自动识别不再使用的内存并把它们释放掉，避免内存泄露。可以说，这些高级语言在底层都实现了自己的内存池，也即有自己的内存管理机制</p>
<h3 id="10-2-池化技术"><a href="#10-2-池化技术" class="headerlink" title="10.2 池化技术"></a>10.2 池化技术</h3><p>在计算机中，有很多使用 <code>“池”</code> 这种技术的地方，除了内存池，还有连接池、线程池、对象池等。以服务器上的线程池为例，它的主要思想是：先启动若干数量的线程，让它们处于睡眠状态，当接收到客户端的请求时，唤醒池中某个睡眠的线程，让它来处理客户端的请求，当处理完这个请求，线程又进入睡眠状态。</p>
<p>所谓 <code>“池化技术”</code>，就是程序先向系统申请过量的资源，然后自己管理，以备不时之需。之所以要申请过量的资源，是因为每次申请该资源都有较大的开销，不如提前申请好了，这样使用时就会变得非常快捷，大大提高程序运行效率。</p>
<h2 id="11-野指针和非法内存操作"><a href="#11-野指针和非法内存操作" class="headerlink" title="11 野指针和非法内存操作"></a>11 野指针和非法内存操作</h2><p>如果一个指针指向的内存没有访问权限，或者指向一块已经释放掉的内存，那么就无法对该指针进行操作，这样的指针称为野指针（<strong>Wild Pointer</strong>）。</p>
<h3 id="11-1-指向没有访问权限的内存"><a href="#11-1-指向没有访问权限的内存" class="headerlink" title="11.1 指向没有访问权限的内存"></a>11.1 指向没有访问权限的内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">char</span> *str;<br>	fgets(str, <span class="hljs-number">10</span>, <span class="hljs-built_in">stdin</span>);<br>	<span class="hljs-built_in">puts</span>(str);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 输出结果 */</span><br>ptr:&lt;error:cannot access memory at address <span class="hljs-number">0x1</span>&gt;    <br></code></pre></td></tr></table></figure>

<ul>
<li><strong>str</strong> 是局部变量，它的值是不确定的，是随机的，不知道指向哪块内存。一般情况下，这块内存要么没有访问权限，要么还没有分配，当 <code>fgets()</code> 函数试图将读取到的字符串写入这块内存时，必然会发生错误。<ul>
<li>当然，如果足够幸运的话，<strong>str</strong> 也可能恰好指向一段分配好的、并且有读写权限的内存，程序就运行成功，但这是小概率事件，一般不会发生。</li>
</ul>
</li>
</ul>
<h3 id="11-2-指向释放掉的内存"><a href="#11-2-指向释放掉的内存" class="headerlink" title="11.2 指向释放掉的内存"></a>11.2 指向释放掉的内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">char</span> *str = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));<br>	<span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;梓语慕晓&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(str);<br>    <span class="hljs-built_in">free</span>(str);<br>    <span class="hljs-keyword">if</span>(str)&#123;<br>		<span class="hljs-built_in">puts</span>(str);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 输出结果 */</span><br>梓语慕晓<br>ptr:&lt;error:cannot access memory at address <span class="hljs-number">0x1</span>&gt; <br></code></pre></td></tr></table></figure>

<p>运行程序，第一次输出 <code>梓语慕晓</code>，第二次输出的是乱码或者什么也不输出。这是因为，<code>freed()</code> 只是释放掉了动态分配的内存，但并未改变 <strong>str</strong> 的值，<strong>str</strong> 的值不是 <strong>NULL</strong>，它仍然指向被释放掉的内存，所以会执行 <strong>if</strong> 语句里面的 <code>puts()</code> 函数。但由于此时的内存已经被释放掉了，原来的字符串已经不在了，所以输出的数据是未知的。</p>
<ul>
<li>使用 <code>free()</code> 释放内存的同时要将指针置为 <strong>NULL</strong>，否则下次就无法判断指向的内存是否有效。</li>
</ul>
<p>还有一种情况是函数外部指针指向函数内部的变量、数组等，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">char</span> **pp)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">char</span> *pstr;<br>	func(&amp;pstr);<br>	<span class="hljs-built_in">puts</span>(pstr);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">char</span> **pp)</span><br>&#123;<br>	<span class="hljs-type">char</span> arr[] = <span class="hljs-string">&quot;梓语慕晓&quot;</span>;<br>	*pp = arr;<br>&#125;<br><span class="hljs-comment">/* 输出结果 */</span><br>未知<br></code></pre></td></tr></table></figure>

<p><strong>arr</strong> 数组在栈上分配内存，字符串 <code>&quot;梓语慕晓&quot;</code> 就存储在这里，<code>func()</code> 函数运行结束后，这块内存被释放掉，但是函数外部的 <strong>pstr</strong> 仍然指向这里，所以执行<code>puts(pstr); </code>时，输出结果是未知的。</p>
<h3 id="11-3-规避野指针"><a href="#11-3-规避野指针" class="headerlink" title="11.3 规避野指针"></a>11.3 规避野指针</h3><p>要想规避野指针，就要养成良好的编程习惯：</p>
<ul>
<li>指针变量如果暂时不需要赋值，一定要初始化为 <strong>NULL</strong>，因为任何指针变量刚被创建时不会自动成为 <strong>NULL</strong> 指针，它的缺省值是随机的。</li>
<li>当指针指向的内存被释放掉时，要将指针的值设置为 <strong>NULL</strong>，因为 <code>free()</code> 只是释放掉了内存，并为改变指针的值。</li>
</ul>
<h2 id="12-内存泄漏（内存丢失）"><a href="#12-内存泄漏（内存丢失）" class="headerlink" title="12 内存泄漏（内存丢失）"></a>12 内存泄漏（内存丢失）</h2><p>使用 <code>malloc()、calloc()、realloc()</code> 动态分配的内存，如果没有指针指向它，就无法进行任何操作，这段内存会一直被程序占用，直到程序运行结束由操作系统回收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">char</span> *p = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));<br>    p = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">50</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));<br>    <span class="hljs-built_in">free</span>(p);<br>    p = <span class="hljs-literal">NULL</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该程序中，第一次分配 <strong>100</strong> 字节的内存，并将 p 指向它；第二次分配 <strong>50</strong> 字节的内存，依然使用 <strong>p</strong> 指向它。这就导致了一个问题，第一次分配的 <strong>100</strong> 字节的内存没有指针指向它了，而且也不知道这块内存的地址，所以就再也无法找回，也没法释放，这块内存就成了垃圾内存，虽然毫无用处，但依然占用资源，唯一的办法就是等程序运行结束后由操作系统回收。</p>
<p>这就是内存泄露（<strong>Memory Leak</strong>），可以理解为程序和内存失去了联系，再也无法对它进行任何操作。</p>
<p>内存泄漏形象的比喻是“操作系统可提供给所有程序使用的内存空间正在被某个程序榨干”，最终结果是程序运行时间越长，占用内存空间越来越多，最终用尽全部内存空间，整个系统崩溃。</p>
<p>再来看一种内存泄露的情况：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *pOld = (<span class="hljs-type">int</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) ); <br><span class="hljs-type">int</span> *pNew = (<span class="hljs-type">int</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) );<br></code></pre></td></tr></table></figure>

<p>这两段代码分别创建了一块内存，并且将内存的地址传给了指针 <strong>pOld</strong> 和 <strong>pNew</strong>。此时指针 <strong>pOld</strong> 和 <strong>pNew</strong> 分别指向两块内存。</p>
<p>如果接下来进行这样的操作：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">pOld</span><span class="hljs-operator">=</span>pNew<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><strong>pOld</strong> 指针就指向了 <strong>pNew</strong> 指向的内存地址，这时候再进行释放内存操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">free</span>(pOld);<br></code></pre></td></tr></table></figure>

<p>此时释放的 <strong>pOld</strong> 所指向的内存空间就是原来 <strong>pNew</strong> 指向的，于是这块空间被释放掉了。但是 <strong>pOld</strong> 原来指向的那块内存空间还没有被释放，不过因为没有指针指向这块内存，所以这块内存就造成了丢失。</p>
<p>另外，你不应该进行类似这面这样的操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) );<br></code></pre></td></tr></table></figure>

<p>这样的操作没有意义，因为没有指针指向分配的内存，无法使用，而且无法通过 <code>free()</code> 释放掉，造成了内存泄露。</p>
<h3 id="12-1-总结"><a href="#12-1-总结" class="headerlink" title="12.1 总结"></a>12.1 总结</h3><p><code>free()</code> 函数的用处在于实时地回收内存，如果程序很简单，程序结束之前也不会使用过多的内存，不会降低系统的性能，那么也可以不用写 <code>free()</code> 函数。当程序结束后，操作系统会释放内存。</p>
<p>但是如果在开发大型程序时不写 <code>free()</code> 函数，后果是很严重的。这是因为很可能在程序中要重复一万次分配 <strong>10MB</strong> 的内存，如果每次进行分配内存后都使用 <code>free()</code> 函数去释放用完的内存空间， 那么这个程序只需要使用 <strong>10MB</strong> 内存就可以运行。但是如果不使用 <code>free()</code> 函数，那么程序就要使用 <strong>100GB</strong> 的内存！这其中包括绝大部分的虚拟内存，而由于虚拟内存的操作需要读写磁盘，因此，这样会极大地影响到系统的性能，系统因此可能崩溃。</p>
<p>因此，在程序中使用 <code>malloc()</code> 分配内存时都对应地写出一个 <code>free()</code> 函数是一个良好的编程习惯。这不但体现在处理大型程序时的必要性，并能在一定程度上体现程序优美的风格和健壮性。</p>
<h2 id="13-变量的存储类别和生存期"><a href="#13-变量的存储类别和生存期" class="headerlink" title="13 变量的存储类别和生存期"></a>13 变量的存储类别和生存期</h2><p>变量是有数据类型的，用以说明它占用多大的内存空间，可以进行什么样的操作。</p>
<p>除了数据类型，变量还有一个属性，称为“存储类别”。存储类别就是变量在内存中的存放区域。在进程的地址空间中，常量区、全局数据区和栈区可以用来存放变量的值。</p>
<p>常量区和全局数据区的内存在程序启动时就已经由操作系统分配好，占用的空间固定，程序运行期间不再改变，程序运行结束后才由操作系统释放；它可以存放全局变量、静态变量、一般常量和字符串常量。</p>
<p>栈区的内存在程序运行期间由系统根据需要来分配（使用到变量才分配内存；如果定义了变量但没有执行到该代码，也不会分配内存），占用的空间实时改变，使用完毕后立即释放，不必等到程序运行结束；它可以存放局部变量、函数参数等。</p>
<p>可以通过 <strong>C</strong> 语言中的关键字来控制变量的存放区域。<strong>C</strong> 语言共有 4 个关键字用来指明变量的存储类别：<strong>auto</strong>（自动的）、<strong>static</strong>（静态的）、<strong>register</strong>（寄存器的）、<strong>extern</strong>（外部的）。</p>
<p>知道了变量的存储类别，就可以知道变量的生存期。通俗地讲，生存期指的是在程序运行过程中，变量从创建到销毁的一段时间，生存期的长短取决于变量的存储类别，也就是它所在的内存区域。</p>
<h3 id="13-1-auto-变量"><a href="#13-1-auto-变量" class="headerlink" title="13.1 auto 变量"></a>13.1 auto 变量</h3><p><strong>auto 是自动或默认的意思，很少用到，因为所有的变量默认就是 auto 的。</strong>也就是说，定义变量时加不加 auto 都一样，所以一般把它省略，不必多次一举。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span> <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br><span class="hljs-comment">/* 两者效果完全一样 */</span><br></code></pre></td></tr></table></figure>

<h3 id="13-2-static-变量"><a href="#13-2-static-变量" class="headerlink" title="13.2 static 变量"></a>13.2 static 变量</h3><p><strong>static</strong> 声明的变量称为静态变量，不管它是全局的还是局部的，都存储在静态数据区（全局变量本来就存储在静态数据区，即使不加 <strong>static</strong>）。</p>
<p>静态数据区的数据在程序启动时就会初始化，直到程序运行结束；对于代码块中的静态局部变量，即使代码块执行结束，也不会销毁。</p>
<p>注意：静态数据区的变量只能初始化（定义）一次，以后只能改变它的值，不能再被初始化，即使有这样的语句，也无效。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">int</span> result, i;<br>	<span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>, i &lt; <span class="hljs-number">100</span>, i++)&#123;<br>		result = sum(i);<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1+2+3...+99+100 = %d\n&quot;</span>, result);<br>	system(<span class="hljs-string">&quot;puase&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>	<span class="hljs-type">static</span> <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>	result += n;<br>	<span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-comment">/* 运行结果 */</span><br><span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span>+...+<span class="hljs-number">99</span>+<span class="hljs-number">100</span> = <span class="hljs-number">5050</span><br></code></pre></td></tr></table></figure>

<p>在 <code>sum()</code> 中定义了一个静态局部变量 <strong>result</strong>，它存储在静态数据区，<code>sum()</code> 函数执行结束也不会销毁，下次调用继续有效。静态数据区的变量只能初始化一次，第一次调用 <code>sum()</code> 时已经对 <strong>result</strong> 进行了初始化，所以再次调用时就不会初始化了，也就是说 <code>static int result = 0;</code> 语句无效。</p>
<p>静态局部变量虽然存储在静态数据区，但是它的作用域仅限于定义它的代码块，<code>sum()</code> 中的 <strong>result</strong> 在函数外无效，与 <code>main()</code> 中的 <strong>result</strong> 不冲突，除了变量名一样，没有任何关系。</p>
<h3 id="13-3-register-变量"><a href="#13-3-register-变量" class="headerlink" title="13.3 register 变量"></a>13.3 register 变量</h3><p>一般情况下，变量的值是存储在内存中的，<strong>CPU</strong> 每次使用数据都要从内存中读取。如果有一些变量使用非常频繁，从内存中读取就会消耗很多时间，例如 <strong>for</strong> 循环中的增量控制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>&#123;<br>	<span class="hljs-comment">//some code </span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行这段代码，<strong>CPU</strong> 为了获得 <strong>i</strong>，会读取 <strong>1000</strong> 次内存。</p>
<p>为了解决这个问题，可以将使用频繁的变量放在 <strong>CPU</strong> 的通用寄存器中，这样使用该变量时就不必访问内存，直接从寄存器中读取，大大提高程序的运行效率。</p>
<p>不过寄存器的数量是有限的，通常是把使用最频繁的变量定义为 register 的。</p>
<p>来看一个计算 <strong>π</strong> 的近似值的例子，求解的一个近似公式如下：</p>
<p><img src="/../image/c_pic/%E5%9B%BE11.1.gif" srcset="/img/loading.gif" lazyload></p>
<p>为了提高精度，循环的次数越多越好，可以将循环的增量控制定义为寄存器变量，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;conio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">double</span> sign = <span class="hljs-number">1.0</span>, res = <span class="hljs-number">0</span>, ad = <span class="hljs-number">1.0</span>;<br>	<span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100000000</span>; i++)&#123;<br>		res += ad;<br>		sign =- sign;<br>		ad = sign/(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>);<br>	&#125;<br>	res *= <span class="hljs-number">4</span>;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pi is %f&quot;</span>, res);<br>	getch();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 输出结果 */</span><br>pi is <span class="hljs-number">3.141593</span><br></code></pre></td></tr></table></figure>

<p>关于寄存器变量有以下事项需要注意：</p>
<ul>
<li><p>为寄存器变量分配寄存器是动态完成的，因此，只有局部变量和形式参数才能定义为寄存器变量。</p>
</li>
<li><p>局部静态变量不能定义为寄存器变量，因为一个变量只能声明为一种存储类别。</p>
</li>
<li><p>寄存器的长度一般和机器的字长一致，只有较短的类型如 <strong>int、char、short</strong> 等才适合定义为寄存器变量，诸如 <strong>double</strong> 等较大的类型，不推荐将其定义为寄存器类型。</p>
</li>
<li><p><strong>CPU</strong> 的寄存器数目有限，即使定义了寄存器变量，编译器可能并不真正为其分配寄存器，而是将其当做普通的 <strong>auto</strong> 变量来对待，为其分配栈内存。当然，有些优秀的编译器，能自动识别使用频繁的变量，如循环控制变量等，在有可用的寄存器时，即使没有使用 <strong>register</strong> 关键字，也自动为其分配寄存器，无须由程序员来指定。</p>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/C%E8%AF%AD%E8%A8%80/" class="category-chain-item">C语言</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%AD%A6%E4%B9%A0/">#学习</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C语言内存</div>
      <div>http://example.com/2023/08/23/C语言内存/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>GeorgyKwe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年8月23日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/08/28/I2C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" title="I2C通信协议">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">I2C通信协议</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/08/22/SRAM%E3%80%81DRAM%E3%80%81PSRAM%E7%AE%80%E4%BB%8B/" title="SRAM、DRAM、PSRAM简介.md">
                        <span class="hidden-mobile">SRAM、DRAM、PSRAM简介.md</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
    
      
            
                  
                      <span id="busuanzi_container_site_uv">
                        本站访客数<span id="busuanzi_value_site_uv"></span>人次
                      </span>
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
